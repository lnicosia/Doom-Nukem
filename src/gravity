add_enemy.c:	enemy.num = env->nb_enemies;
add_enemy.c:	enemy.pos.x = (env->sdl.mx - env->editor.center.x) / env->editor.scale;
add_enemy.c:	enemy.pos.y = (env->sdl.my - env->editor.center.y) / env->editor.scale;
add_enemy.c:	enemy.pos.z = env->sectors[enemy.sector].floor + 5;
add_enemy.c:		enemy.light_color = env->sectors[enemy.sector].light_color;
add_enemy.c:		enemy.brightness = env->sectors[enemy.sector].brightness;
add_enemy.c:	if (!(env->enemies = (t_enemies*)ft_realloc(env->enemies, sizeof(t_enemies) * env->nb_enemies, sizeof(t_enemies) * (env->nb_enemies + 1))))
add_enemy.c:	env->enemies[env->nb_enemies] = enemy;
add_object.c:	object.num = env->nb_objects;
add_object.c:	object.pos.x = (env->sdl.mx - env->editor.center.x) / env->editor.scale;
add_object.c:	object.pos.y = (env->sdl.my - env->editor.center.y) / env->editor.scale;
add_object.c:	object.pos.z = env->sectors[object.sector].floor;
add_object.c:		object.light_color = env->sectors[object.sector].light_color;
add_object.c:		object.brightness = env->sectors[object.sector].brightness;
add_object.c:	if (!(env->objects = (t_object*)ft_realloc(env->objects, sizeof(t_object) * env->nb_objects, sizeof(t_object) * (env->nb_objects + 1))))
add_object.c:	env->objects[env->nb_objects] = object;
add_player.c:	env->player.pos.x = (env->sdl.mx - env->editor.center.x) / env->editor.scale;
add_player.c:	env->player.pos.y = (env->sdl.my - env->editor.center.y) / env->editor.scale;
add_player.c:	env->player.sector = get_sector_no_z(env, env->player.pos);
add_player.c:	env->player.camera.angle = 0;
add_player.c:	env->player.camera.angle_z = 0;
add_player.c:	env->player.camera.pos = env->player.pos;
add_player.c:	env->player.camera.pos.z = 6;
add_player.c:	env->player.eyesight = 6.0;
add_player.c:	ft_printf("player_z: %f | sector_height: %f\n", env->player.eyesight,
add_player.c:	env->sectors[env->player.sector].ceiling - env->sectors[env->player.sector].floor);
add_player.c:	if ((env->sectors[env->player.sector].ceiling
add_player.c:	- env->sectors[env->player.sector].floor) < env->player.eyesight)
add_player.c:		env->player.pos.x = 0;
add_player.c:		env->player.pos.y = 0;
add_player.c:		env->player.sector = -1;
add_player.c:		env->player.camera.angle = 0;
add_player.c:		env->player.camera.angle_z = 0;
add_player.c:		env->player.camera.pos.z = 0;
add_player.c:		env->player.eyesight = 0;
add_player.c:	env->player.pos.x = (env->sdl.mx - env->editor.center.x) / env->editor.scale;
add_player.c:	env->player.pos.y = (env->sdl.my - env->editor.center.y) / env->editor.scale;
add_player.c:	env->player.pos.z = 0;
add_player.c:	env->player.camera.angle = 0;
add_player.c:	env->player.camera.angle_z = 0;
add_player.c:	env->player.camera.pos = env->player.pos;
add_player.c:	env->player.camera.pos.z = 6;
add_player.c:	env->player.eyesight = 6;
add_player.c:	env->player.speed = 0.5;
add_player.c:	env->player.camera.angle_cos = cos(env->player.camera.angle);
add_player.c:	env->player.camera.angle_sin = sin(env->player.camera.angle);
add_player.c:	env->player.camera.perp_cos = cos(env->player.camera.angle - M_PI / 2);
add_player.c:	env->player.camera.perp_sin = sin(env->player.camera.angle - M_PI / 2);
add_player.c:	env->player.sector = get_sector_no_z(env,
add_player.c:			env->player.pos);
add_player.c:	if (env->player.sector != -1)
add_player.c:	env->player.highest_sect = env->player.pos.z;
add_player.c:	env->player.lowest_sect = env->player.pos.z;
add_sector.c:	sector = env->sectors[env->nb_sectors - 1];
add_sector.c:				sector.floor = env->sectors[sector.neighbors[i]].floor;
add_sector.c:				sector.ceiling = env->sectors[sector.neighbors[i]].ceiling;
add_sector.c:			if (sector.floor > env->sectors[sector.neighbors[i]].floor)
add_sector.c:				sector.floor = env->sectors[sector.neighbors[i]].floor;
add_sector.c:			if (sector.ceiling < env->sectors[sector.neighbors[i]].ceiling)
add_sector.c:				sector.ceiling = env->sectors[sector.neighbors[i]].ceiling;
add_sector.c:	env->sectors[env->nb_sectors - 1].floor = sector.floor;
add_sector.c:	env->sectors[env->nb_sectors - 1].ceiling = sector.ceiling;
add_sector.c:	tmp = env->editor.current_vertices;
add_sector.c:	sector.floor_scale.x = env->textures[sector.floor_texture].surface->w / 10;
add_sector.c:	sector.floor_scale.y = env->textures[sector.floor_texture].surface->h / 10;
add_sector.c:	sector.ceiling_scale.x = env->textures[sector.ceiling_texture].surface->w / 10;
add_sector.c:	sector.ceiling_scale.y = env->textures[sector.ceiling_texture].surface->h / 10;
add_sector.c:	sector.num = env->nb_sectors;
add_sector.c:	if (!(env->sectors = (t_sector*)ft_realloc(env->sectors,
add_sector.c:					sizeof(t_sector) * env->nb_sectors,
add_sector.c:					sizeof(t_sector) * (env->nb_sectors + 1))))
add_sector.c:	env->sectors[env->nb_sectors] = sector;
add_sector.c:	env->nb_sectors++;
add_vertex.c:	if (!env->editor.current_vertices)
add_vertex.c:	if (!env->editor.current_vertices->next)
add_vertex.c:		v = (t_vertex*)env->editor.current_vertices->content;
add_vertex.c:		free(env->editor.current_vertices);
add_vertex.c:		env->editor.current_vertices = NULL;
add_vertex.c:		env->editor.start_vertex = -1;
add_vertex.c:	tmp = env->editor.current_vertices;
add_vertex.c:	while (env->editor.current_vertices)
add_vertex.c:		tmp = env->editor.current_vertices;
add_vertex.c:		env->editor.current_vertices = env->editor.current_vertices->next;
add_vertex.c:	if (!(new = ft_lstnew(&env->vertices[num], sizeof(t_vertex))))
add_vertex.c:	ft_lstpushback(&env->editor.current_vertices, new);
add_vertex.c:	vertex.num = env->nb_vertices;
add_vertex.c:	vertex.x = round((env->sdl.mx - env->editor.center.x) / env->editor.scale);
add_vertex.c:	vertex.y = round((env->sdl.my - env->editor.center.y) / env->editor.scale);
add_vertex.c:	if (!(env->vertices = (t_vertex*)ft_realloc(env->vertices, sizeof(t_vertex) * env->nb_vertices, sizeof(t_vertex) * (env->nb_vertices + 1))))
add_vertex.c:	env->vertices[env->nb_vertices] = vertex;
add_vertex.c:	env->nb_vertices++;
animations.c:	if (!env->player_hurt.start)
animations.c:		env->player_hurt.start = SDL_GetTicks();
animations.c:	if (env->time.milli_s > env->player_hurt.start + 160)
animations.c:		env->player_hurt.start = 0;
animations.c:		env->player.hit = 0;
animations.c:	time_spent = env->time.milli_s - env->player_hurt.start;
animations.c:	while (j < env->w * env->h)
animations.c:		env->sdl.texture_pixels[j] = blend_alpha(env->sdl.texture_pixels[j], 0xFFFF0000, color);
animations.c:	if (!env->enemies[i].hurt.start)
animations.c:		env->enemies[i].hurt.start = SDL_GetTicks();
animations.c:	if (env->time.milli_s > env->enemies[i].hurt.start + 160)
animations.c:		env->enemies[i].hurt.start = 0;
animations.c:		env->enemies[i].hit = 0;
animations.c:	time_spent = env->time.milli_s - env->player_hurt.start;
animations.c:	if (env->enemies[i].rest.start == 0)
animations.c:		env->enemies[i].rest.start = SDL_GetTicks();
animations.c:	start = env->enemies[i].rest.start;
animations.c:	time_spent = env->time.milli_s - start;
animations.c:		env->enemies[i].rest.start = 0;
animations.c:		env->enemies[i].sprite = env->sprites[env->enemies[i].sprite].rest_sprite;
animations.c:	if (env->enemies[i].pursue.start == 0)
animations.c:		env->enemies[i].pursue.start = SDL_GetTicks();
animations.c:	start = env->enemies[i].pursue.start;
animations.c:	time_spent = env->time.milli_s - start;
animations.c:		env->enemies[i].pursue.start = 0;
animations.c:		env->enemies[i].sprite = env->sprites[env->enemies[i].sprite].pursuit_sprite;
animations.c:	if (env->enemies[i].death.start == 0)
animations.c:		env->enemies[i].death.start = SDL_GetTicks();
animations.c:	start = env->enemies[i].death.start;
animations.c:	time_spent = env->time.milli_s - start;
animations.c:		env->enemies[i].death.start = 0;
animations.c:		env->enemies[i].exists = 0;
animations.c:	if (env->enemies[i].rand_dir.start == 0)
animations.c:		env->enemies[i].rand_dir.start = SDL_GetTicks();
animations.c:	start = env->enemies[i].rand_dir.start;
animations.c:	time_spent = env->time.milli_s - start;
animations.c:		env->enemies[i].rand_dir.start = 0;
animations.c:		return ((int)env->time.milli_s % 2 == 0);
animations.c:	return (env->enemies[i].dir);
animations.c:	if (env->enemies[i].fire.start == 0)
animations.c:		env->enemies[i].fire.start = SDL_GetTicks();
animations.c:	start = env->enemies[i].fire.start;
animations.c:	time_spent = env->time.milli_s - start;
animations.c:		env->enemies[i].fire.start = 0;
animations.c:		env->enemies[i].sprite = env->sprites[env->enemies[i].sprite].firing_sprite;
animations.c:		env->enemies[i].shot = (env->enemies[i].sprite == env->enemies[i].firing_sprite) ? 1 : 0;
benchmark.c:	ft_dprintf(fd, "Average fps = %f\n", (env->avrg_fps + old.average) / 2);
benchmark.c:	ft_dprintf(fd, "Min fps = %f\n", (env->min_fps + old.min) / 2);
benchmark.c:	ft_dprintf(fd, "Min fps = %f\n", (env->max_fps + old.max) / 2);
benchmark.c:	ft_dprintf(fd, "Average fps = %f\n", (env->avrg_fps2 + new.average) / 2);
benchmark.c:	ft_dprintf(fd, "Min fps = %f\n", (env->min_fps2 + new.min) / 2);
benchmark.c:	ft_dprintf(fd, "Max fps = %f\n", (env->max_fps2 + new.max) / 2);
benchmark.c:		env->avrg_fps, env->min_fps, env->max_fps);
benchmark.c:		env->avrg_fps2, env->min_fps2, env->max_fps2);
benchmark.c:	if (!env->avrg_fps)
benchmark.c:		old.average = env->avrg_fps;
benchmark.c:		old.min = env->min_fps;
benchmark.c:		old.max = env->max_fps;
benchmark.c:		new.average = env->avrg_fps2;
benchmark.c:		new.min = env->min_fps2;
benchmark.c:		new.max = env->max_fps2;
bmp_parse_pixel_data.c:			env->textures[index].str[x + y * parser->w] = get_pixel(byte, str, parser); 
bmp_parser.c:	if (!(env->textures[index].surface = SDL_CreateRGBSurfaceWithFormat(
bmp_parser.c:	env->textures[index].str = env->textures[index].surface->pixels;
bmp_parser.c:	env->textures[index].scale = 1;
bmp_parser.c:	env->textures[index].xpadding = 0;
bmp_parser.c:	env->textures[index].ypadding = 0;
camera.c:	camera->hscale = env->h_w / camera->x2;
camera.c:	camera->vscale = env->h_h / camera->y2;
camera.c:	if (!(camera->screen_pos = (int*)malloc(sizeof(int) * (env->w))))
camera.c:				malloc(sizeof(t_render_vertex*) * env->nb_sectors)))
camera.c:	if (!(camera->sector_computed = (int*)malloc(sizeof(int) * (env->nb_sectors))))
camera.c:	if (!(camera->feet_y = (double*)malloc(sizeof(double) * (env->nb_sectors))))
camera.c:	if (!(camera->head_y = (double*)malloc(sizeof(double) * (env->nb_sectors))))
camera.c:	if (!(camera->xmin = (int*)malloc(sizeof(int) * (env->screen_sectors_size))))
camera.c:	if (!(camera->xmax = (int*)malloc(sizeof(int) * (env->screen_sectors_size))))
camera.c:	if (!(camera->screen_sectors = (int*)malloc(sizeof(int) * (env->screen_sectors_size))))
camera.c:	if (!(camera->rendered_sectors = (short*)malloc(sizeof(short) * (env->screen_sectors_size))))
camera.c:	while (i < env->nb_sectors)
camera.c:					malloc(sizeof(t_render_vertex) * (env->sectors[i].nb_vertices + 1))))
camera.c:		while (j < env->sectors[i].nb_vertices)
camera.c:			if (!(camera->v[i][j].sprite_scale = (t_v2*)malloc(sizeof(t_v2) * env->sectors[i].nb_sprites[j])))
camera.c:	camera->size = env->nb_sectors;
check_parsing.c:	ft_printf("{yellow}Vertex %d\n", env->nb_vertices);
check_parsing.c:	while (i < env->nb_vertices)
check_parsing.c:		ft_printf("vertex	%f %f\n", env->vertices[i].y, env->vertices[i].x);
check_parsing.c:	ft_printf("\nSector %d\n", env->nb_sectors);
check_parsing.c:	while (i < env->nb_sectors)
check_parsing.c:		ft_printf("sector	%f %f	", env->sectors[i].floor,
check_parsing.c:				env->sectors[i].ceiling);
check_parsing.c:		while (j < env->sectors[i].nb_vertices)
check_parsing.c:			ft_printf("%d ", env->sectors[i].vertices[j]);
check_parsing.c:		while (j < env->sectors[i].nb_vertices)
check_parsing.c:			ft_printf("%d ", env->sectors[i].neighbors[j]);
check_parsing.c:	ft_printf("\nplayer	%f %f	%f %d\n{reset}", env->player.pos.y,
check_parsing.c:			env->player.pos.x, env->player.camera.angle, env->player.sector);
clear_image.c:	max = env->w * env->h;
clear_image.c:	pixels = env->sdl.texture_pixels;
clear_image.c:	zbuffer = env->zbuffer;
confirmation_box.c:	if (((env->sdl.event.button.button == SDL_BUTTON_LEFT
confirmation_box.c:					&& env->sdl.my >= box->no.pos.y
confirmation_box.c:					&& env->sdl.my <= box->no.pos.y + box->no.size.y
confirmation_box.c:					&& env->sdl.mx >= box->yes.pos.x
confirmation_box.c:					&& env->sdl.mx <= box->yes.pos.x + box->yes.size.x)
confirmation_box.c:				|| env->sdl.event.key.keysym.sym == SDLK_RETURN))
confirmation_box.c:			SDL_GetRelativeMouseState(&env->sdl.mx, &env->sdl.my);
confirmation_box.c:	if ((env->sdl.event.button.button == SDL_BUTTON_LEFT
confirmation_box.c:					&& env->sdl.my >= box->no.pos.y
confirmation_box.c:					&& env->sdl.my <= box->no.pos.y + box->no.size.y
confirmation_box.c:					&& env->sdl.mx >= box->no.pos.x
confirmation_box.c:					&& env->sdl.mx <= box->no.pos.x + box->no.size.x)
confirmation_box.c:			|| env->sdl.event.key.keysym.sym == SDLK_BACKSPACE)
confirmation_box.c:			env->running = 0;
confirmation_box.c:	if (((env->sdl.event.button.button == SDL_BUTTON_LEFT
confirmation_box.c:					&& env->sdl.my >= box->no.pos.y
confirmation_box.c:					&& env->sdl.my <= box->no.pos.y + box->no.size.y
confirmation_box.c:					&& env->sdl.mx >= box->yes.pos.x
confirmation_box.c:					&& env->sdl.mx <= box->yes.pos.x + box->yes.size.x)
confirmation_box.c:				|| env->sdl.event.key.keysym.sym == SDLK_RETURN)
confirmation_box.c:			&& env->editor.selected_sector != -1)
confirmation_box.c:			delete_sector(env, env->editor.selected_sector);
confirmation_box.c:			env->editor.selected_sector = -1;
confirmation_box.c:			while (i < env->nb_sectors)
confirmation_box.c:				create_portals(env, env->sectors[i]);
confirmation_box.c:	if ((env->sdl.event.button.button == SDL_BUTTON_LEFT
confirmation_box.c:					&& env->sdl.my >= box->no.pos.y
confirmation_box.c:					&& env->sdl.my <= box->no.pos.y + box->no.size.y
confirmation_box.c:					&& env->sdl.mx >= box->no.pos.x
confirmation_box.c:					&& env->sdl.mx <= box->no.pos.x + box->no.size.x)
confirmation_box.c:			|| env->sdl.event.key.keysym.sym == SDLK_BACKSPACE)
confirmation_box.c:	if ((env->sdl.my >= box->no.pos.y
confirmation_box.c:			&& env->sdl.my <= box->no.pos.y + box->no.size.y
confirmation_box.c:			&& env->sdl.mx >= box->yes.pos.x
confirmation_box.c:			&& env->sdl.mx <= box->yes.pos.x + box->yes.size.x
confirmation_box.c:			&& env->inputs.left_click) || env->inputs.enter)
confirmation_box.c:	if ((env->sdl.my >= box->no.pos.y
confirmation_box.c:			&& env->sdl.my <= box->no.pos.y + box->no.size.y
confirmation_box.c:			&&env->sdl.mx >= box->no.pos.x
confirmation_box.c:			&& env->sdl.mx <= box->no.pos.x + box->no.size.x
confirmation_box.c:			&& env->inputs.left_click) || env->inputs.backspace)
confirmation_box.c:	box->no.pos.x = env->w / 2 - box->size.x / 2;
confirmation_box.c:	box->no.pos.y = env->h / 2 + box->size.y / 2 - height - 5;
confirmation_box.c:	box->yes.pos.x = env->w / 2;
confirmation_box.c:	box->yes.pos.y = env->h / 2 + box->size.y / 2 - height - 5;
confirmation_box.c:			new_point(env->w / 2 - box.size.x / 2 + 5 , env->h / 2 - box.size.y / 3),
confirmation_box.c:			new_point(env->w / 2 - box.size.x / 2, env->h / 2 - box.size.y / 2),
confirmation_box.c:	print_text(new_point(env->h / 2 - box.size.y / 3,
confirmation_box.c:				env->w / 2 - box.size.x / 2 + 10),
create_portals.c:	while (i < env->nb_sectors)
create_portals.c:		while (j < env->sectors[i].nb_vertices)
create_portals.c:			env->sectors[i].neighbors[j] = -1;
create_portals.c:	while (i < env->sectors[sector.num].nb_vertices)
create_portals.c:				env->sectors[sector.num].neighbors[i - 1] = data.father;
create_portals.c:				env->sectors[data.father].neighbors[data.index] = sector.num;
create_portals.c:				env->sectors[sector.num].neighbors[sector.nb_vertices - 1] = data.father;
create_portals.c:				env->sectors[data.father].neighbors[data.index] = sector.num;
create_portals.c:				env->sectors[sector.num].neighbors[i] = data.father;
create_portals.c:				env->sectors[data.father].neighbors[data.index] = sector.num;
create_portals.c:	while (i < env->nb_sectors)
create_portals.c:			find_common_wall(env, env->sectors[i], data);
death.c:	while (i < env->nb_enemies)
death.c:		env->enemies[i].pos = env->enemies[i].enemies_init_data.pos;
death.c:		env->enemies[i].health = env->enemies[i].enemies_init_data.health;
death.c:		env->enemies[i].sector = env->enemies[i].enemies_init_data.sector;
death.c:		env->enemies[i].angle = env->enemies[i].enemies_init_data.angle;
death.c:		env->enemies[i].sprite = env->enemies[i].main_sprite;
death.c:		env->enemies[i].saw_player = 0;
death.c:	env->player.pos = env->player.player_init_data.pos;
death.c:	env->player.killed = 0;
death.c:	env->player.touched = 0;
death.c:	env->player.nb_shots = 0;
death.c:	env->player.accuracy = 0;
death.c:	env->player.health = env->player.player_init_data.health;
death.c:	env->player.sector = env->player.player_init_data.sector;
death.c:	env->player.camera = env->player.player_init_data.camera;
death.c:	while (i < env->nb_objects)
death.c:		env->objects[i].pos = env->objects[i].object_init_data.pos;
death.c:		env->objects[i].sector = env->objects[i].object_init_data.sector;
death.c:		env->objects[i].angle = env->objects[i].object_init_data.angle;
death.c:	env->player.highest_sect = find_highest_sector(env, new_movement(env->player.sector, env->player.size_2d, env->player.eyesight, env->player.pos));
death.c:	if (env->player.nb_shots > 0)
death.c:		env->player.accuracy = (int)((env->player.touched / env->player.nb_shots) * 100);
death.c:	if (!env->confirmation_box.state)
death.c:		env->confirmation_box.state = 1;
death.c:		if (!(env->confirmation_box.str = ft_strdup("You Died...\nRespawn?")))
death.c:		new_confirmation_box(&env->confirmation_box, env);
death.c:		while (++i < env->nb_enemies)
death.c:			env->enemies[i].state = RESTING;
delete_action.c:	if (env->editor.selected_vertex != -1
delete_action.c:			&& !current_vertices_contains(env, env->editor.selected_vertex))
delete_action.c:		delete_vertex(env, env->editor.selected_vertex);
delete_action.c:		env->editor.selected_vertex = -1;
delete_action.c:		while (i < env->nb_sectors)
delete_action.c:			create_portals(env, env->sectors[i]);
delete_action.c:	if (env->editor.selected_sector != -1)
delete_action.c:		if (!env->confirmation_box.state)
delete_action.c:			env->confirmation_box.state = 1;
delete_action.c:			if (!(env->confirmation_box.str = ft_strdup("Delete the selected sector?")))
delete_action.c:			new_confirmation_box(&env->confirmation_box, env);
delete_action.c:	if (env->editor.selected_object != -1)
delete_action.c:		delete_object(env, env->editor.selected_object);
delete_action.c:		env->editor.selected_object = -1;
delete_action.c:	if (env->editor.selected_player != -1)
delete_action.c:		env->editor.new_player = 0;
delete_action.c:		env->editor.selected_player = -1;
delete_action.c:	env->inputs.del = 0;
delete_enemy.c:	env->enemies = ft_delindex(env->enemies,
delete_enemy.c:			sizeof(t_enemies) * env->nb_enemies,
delete_enemy.c:	env->nb_enemies--;
delete_enemy.c:	env->selected_enemy = -1;
delete_object.c:	env->objects = ft_delindex(env->objects,
delete_object.c:			sizeof(t_object) * env->nb_objects,
delete_object.c:	env->nb_objects--;
delete_object.c:	env->editor.selected_object = -1;
delete_sector.c:	while (i < env->nb_sectors)
delete_sector.c:		while (j < env->sectors[i].nb_vertices)
delete_sector.c:			if (env->sectors[i].neighbors[j] >= sector)
delete_sector.c:				env->sectors[i].neighbors[j]--;
delete_sector.c:	ft_memdel((void**)&env->sectors[sector].vertices);
delete_sector.c:	ft_memdel((void**)&env->sectors[sector].neighbors);
delete_sector.c:	ft_memdel((void**)&env->sectors[sector].textures);
delete_sector.c:	ft_memdel((void**)&env->sectors[sector].floors);
delete_sector.c:	ft_memdel((void**)&env->sectors[sector].ceilings);
delete_sector.c:	ft_memdel((void**)&env->sectors[sector].clipped_ceilings1);
delete_sector.c:	ft_memdel((void**)&env->sectors[sector].clipped_ceilings2);
delete_sector.c:	ft_memdel((void**)&env->sectors[sector].clipped_floors1);
delete_sector.c:	ft_memdel((void**)&env->sectors[sector].clipped_floors2);
delete_sector.c:	ft_memdel((void**)&env->sectors[sector].wall_width);
delete_sector.c:	env->sectors = ft_delindex(env->sectors,
delete_sector.c:			 sizeof(t_sector) * env->nb_sectors,
delete_sector.c:	env->nb_sectors--;
delete_sector.c:	while (i < env->nb_sectors)
delete_sector.c:		env->sectors[i].num--;
delete_sector.c:	while (i < env->nb_sectors)
delete_sector.c:		create_portals(env, env->sectors[i]);
delete_sector.c:	while (i < env->nb_sectors)
delete_sector.c:		if (env->sectors[i].nb_vertices < 3)
delete_vertex.c:	while (i < env->nb_sectors)
delete_vertex.c:		while (j < env->sectors[i].nb_vertices)
delete_vertex.c:			if (env->sectors[i].vertices[j] == vertex)
delete_vertex.c:					env->sectors[i].vertices = ft_delindex(env->sectors[i].vertices,
delete_vertex.c:							sizeof(short) * (env->sectors[i].nb_vertices + 1),
delete_vertex.c:					env->sectors[i].nb_vertices--;
delete_vertex.c:			if (env->sectors[i].vertices[j] > vertex)
delete_vertex.c:				env->sectors[i].vertices[j]--;
delete_vertex.c:		env->sectors[i].vertices[env->sectors[i].nb_vertices] = env->sectors[i].vertices[0];
delete_vertex.c:	env->vertices = ft_delindex(env->vertices,
delete_vertex.c:			sizeof(t_vertex) * env->nb_vertices,
delete_vertex.c:	env->nb_vertices--;
delete_vertex.c:	while (i < env->nb_vertices)
delete_vertex.c:		env->vertices[i].num--;
delete_vertex.c:	if (env->nb_sectors)
delete_vertex.c:	env->editor.selected_vertex = -1;
delete_vertex.c:	while (i < env->nb_vertices)
doom.c:	env->player.speed = 0.5;
doom.c:	env->player.size_2d = 0.5;
doom.c:	Mix_PlayMusic(env->sound.background, -1);
doom.c:	env->flag = 0;
doom.c:	env->player.fall = 1;*/
doom.c:	while (env->running)
doom.c:		if (env->player.sector == -1)
doom.c:		env->player.health = 100;
doom.c:		Mix_VolumeMusic(MIX_MAX_VOLUME/env->sound.g_music);
doom.c:		SDL_GetRelativeMouseState(&env->sdl.mouse_x, &env->sdl.mouse_y);
doom.c:		SDL_GetMouseState(&env->sdl.mx, &env->sdl.my);
doom.c:		while (SDL_PollEvent(&env->sdl.event))
doom.c:			if (env->sdl.event.type == SDL_QUIT || (env->sdl.event.type == SDL_KEYUP && env->sdl.event.key.keysym.sym == SDLK_ESCAPE))
doom.c:				env->running = 0;
doom.c:			else if (env->sdl.event.type == SDL_KEYDOWN
doom.c:					|| env->sdl.event.type == SDL_KEYUP || env->sdl.event.type == SDL_MOUSEBUTTONDOWN
doom.c:					|| env->sdl.event.type == SDL_MOUSEBUTTONUP || env->sdl.event.type == SDL_MOUSEWHEEL)
doom.c:			if (env->sdl.event.type == SDL_KEYUP || env->sdl.event.type == SDL_MOUSEBUTTONUP)
doom.c:			if (env->sdl.event.type == SDL_MOUSEWHEEL && !env->weapon_change.on_going && !env->shot.on_going && env->player.health > 0)
doom.c:		if (env->player.health > 0)
doom.c:		if (env->player.health <= 0)
doom.c:		if (env->confirmation_box.state)
doom.c:			confirmation_box_keys(&env->confirmation_box, env);
doom.c:		if (env->menu_start)
doom.c:			if (env->option)
draw_ceiling.c:	pixels = env->sdl.texture_pixels;
draw_ceiling.c:	zbuffer = env->zbuffer;
draw_ceiling.c:	texture_w = env->textures[sector.ceiling_texture].surface->w;
draw_ceiling.c:	texture_h = env->textures[sector.ceiling_texture].surface->h;
draw_ceiling.c:	texture_pixels = env->textures[sector.ceiling_texture].str;
draw_ceiling.c:		coord = vline.x + env->w * i;
draw_ceiling.c:		if (env->editor.select && vline.x == env->h_w && i == env->h_h)
draw_ceiling.c:			env->selected_wall1 = -1;
draw_ceiling.c:			env->selected_wall2 = -1;
draw_ceiling.c:			env->selected_ceiling = render.sector;
draw_ceiling.c:			env->selected_floor = -1;
draw_ceiling.c:			env->selected_object = -1;
draw_ceiling.c:			env->selected_enemy = -1;
draw_ceiling.c:			env->editor.selected_wall = -1;
draw_ceiling.c:			if (!env->options.lighting && !env->playing)
draw_ceiling.c:			if (env->editor.in_game && !env->editor.select && env->selected_ceiling == render.sector)
draw_ceiling.c:			if (env->options.zbuffer || env->options.contouring)
draw_ceiling.c:					pixels[vline.x + env->w * i] = 0xFFFF0000;
draw_ceiling.c:	pixels = env->sdl.texture_pixels;
draw_ceiling.c:	zbuffer = env->zbuffer;
draw_ceiling.c:		coord = vline.x + env->w * vline.start;
draw_ceiling.c:		if (env->editor.select && vline.x == env->h_w && vline.start == env->h_h)
draw_ceiling.c:			env->selected_wall1 = -1;
draw_ceiling.c:			env->selected_wall2 = -1;
draw_ceiling.c:			env->selected_ceiling = render.sector;
draw_ceiling.c:			env->selected_floor = -1;
draw_ceiling.c:			env->selected_object = -1;
draw_ceiling.c:			env->selected_enemy = -1;
draw_ceiling.c:			env->editor.selected_wall = -1;
draw_ceiling.c:		if (env->editor.in_game && !env->editor.select && env->selected_floor == render.sector)
draw_ceiling.c:	vline.start = env->ymin[vline.x];
draw_ceiling.c:	vline.end = ft_min(render.current_ceiling, env->ymax[vline.x]);
draw_ceiling2.c:	pixels = env->sdl.texture_pixels;
draw_ceiling2.c:	zbuffer = env->zbuffer;
draw_ceiling2.c:	texture = env->textures[sector.ceiling_texture];
draw_ceiling2.c:	line = render.y * env->w;
draw_ceiling2.c:		vline_data = env->vline_data[x];
draw_circle.c:		if (p1.x >= 200 && p1.x < env->w && p1.y >= 0 && p1.y < env->h)
draw_circle.c:		env->sdl.texture_pixels[p1.x + p1.y * env->w] = color;
draw_circle.c:		if (p1.x >= 200 && p1.x < env->w && p1.y >= 0 && p1.y < env->h)
draw_circle.c:			env->sdl.texture_pixels[p1.x + p1.y * env->w] = color;
draw_circle.c:		if (circle.center.x + x >= 200 && circle.center.x + x < env->w
draw_circle.c:				&& circle.center.y + y >= 0 && circle.center.y + y < env->h)
draw_circle.c:		env->sdl.texture_pixels[circle.center.x + x + env->w * (circle.center.y + y)] = circle.line_color;
draw_circle.c:		if (circle.center.x - x >= 200 && circle.center.x - x < env->w
draw_circle.c:				&& circle.center.y + y >= 0 && circle.center.y + y < env->h)
draw_circle.c:		env->sdl.texture_pixels[circle.center.x - x + env->w * (circle.center.y + y)] = circle.line_color;
draw_circle.c:		if (circle.center.x + x >= 200 && circle.center.x + x < env->w
draw_circle.c:				&& circle.center.y - y >= 0 && circle.center.y - y < env->h)
draw_circle.c:		env->sdl.texture_pixels[circle.center.x + x + env->w * (circle.center.y - y)] = circle.line_color;
draw_circle.c:		if (circle.center.x - x >= 200 && circle.center.x - x < env->w
draw_circle.c:				&& circle.center.y - y >= 0 && circle.center.y - y < env->h)
draw_circle.c:		env->sdl.texture_pixels[circle.center.x - x + env->w * (circle.center.y - y)] = circle.line_color;
draw_circle.c:		if (circle.center.x + y >= 200 && circle.center.x + y < env->w
draw_circle.c:				&& circle.center.y + x >= 0 && circle.center.y + x < env->h)
draw_circle.c:		env->sdl.texture_pixels[circle.center.x + y + env->w * (circle.center.y + x)] = circle.line_color;
draw_circle.c:		if (circle.center.x - y >= 200 && circle.center.x - y < env->w
draw_circle.c:				&& circle.center.y + x >= 0 && circle.center.y + x < env->h)
draw_circle.c:		env->sdl.texture_pixels[circle.center.x - y + env->w * (circle.center.y + x)] = circle.line_color;
draw_circle.c:		if (circle.center.x + y >= 200 && circle.center.x + y < env->w
draw_circle.c:				&& circle.center.y - x >= 0 && circle.center.y - x < env->h)
draw_circle.c:		env->sdl.texture_pixels[circle.center.x + y + env->w * (circle.center.y - x)] = circle.line_color;
draw_circle.c:		if (circle.center.x - y >= 200 && circle.center.x - y < env->w
draw_circle.c:				&& circle.center.y - x >= 0 && circle.center.y - x < env->h)
draw_circle.c:		env->sdl.texture_pixels[circle.center.x - y + env->w * (circle.center.y - x)] = circle.line_color;
draw_circle_free.c:		if (p1.x >= 0 && p1.x < env->w && p1.y >= 0 && p1.y < env->h)
draw_circle_free.c:		env->sdl.texture_pixels[p1.x + p1.y * env->w] = color;
draw_circle_free.c:		if (p1.x >= 0 && p1.x < env->w && p1.y >= 0 && p1.y < env->h)
draw_circle_free.c:			env->sdl.texture_pixels[p1.x + p1.y * env->w] = color;
draw_circle_free.c:		if (circle.center.x + x >= 0 && circle.center.x + x < env->w
draw_circle_free.c:				&& circle.center.y + y >= 0 && circle.center.y + y < env->h)
draw_circle_free.c:		env->sdl.texture_pixels[circle.center.x + x + env->w * (circle.center.y + y)] = circle.line_color;
draw_circle_free.c:		if (circle.center.x - x >= 0 && circle.center.x - x < env->w
draw_circle_free.c:				&& circle.center.y + y >= 0 && circle.center.y + y < env->h)
draw_circle_free.c:		env->sdl.texture_pixels[circle.center.x - x + env->w * (circle.center.y + y)] = circle.line_color;
draw_circle_free.c:		if (circle.center.x + x >= 0 && circle.center.x + x < env->w
draw_circle_free.c:				&& circle.center.y - y >= 0 && circle.center.y - y < env->h)
draw_circle_free.c:		env->sdl.texture_pixels[circle.center.x + x + env->w * (circle.center.y - y)] = circle.line_color;
draw_circle_free.c:		if (circle.center.x - x >= 0 && circle.center.x - x < env->w
draw_circle_free.c:				&& circle.center.y - y >= 0 && circle.center.y - y < env->h)
draw_circle_free.c:		env->sdl.texture_pixels[circle.center.x - x + env->w * (circle.center.y - y)] = circle.line_color;
draw_circle_free.c:		if (circle.center.x + y >= 0 && circle.center.x + y < env->w
draw_circle_free.c:				&& circle.center.y + x >= 0 && circle.center.y + x < env->h)
draw_circle_free.c:		env->sdl.texture_pixels[circle.center.x + y + env->w * (circle.center.y + x)] = circle.line_color;
draw_circle_free.c:		if (circle.center.x - y >= 0 && circle.center.x - y < env->w
draw_circle_free.c:				&& circle.center.y + x >= 0 && circle.center.y + x < env->h)
draw_circle_free.c:		env->sdl.texture_pixels[circle.center.x - y + env->w * (circle.center.y + x)] = circle.line_color;
draw_circle_free.c:		if (circle.center.x + y >= 0 && circle.center.x + y < env->w
draw_circle_free.c:				&& circle.center.y - x >= 0 && circle.center.y - x < env->h)
draw_circle_free.c:		env->sdl.texture_pixels[circle.center.x + y + env->w * (circle.center.y - x)] = circle.line_color;
draw_circle_free.c:		if (circle.center.x - y >= 0 && circle.center.x - y < env->w
draw_circle_free.c:				&& circle.center.y - x >= 0 && circle.center.y - x < env->h)
draw_circle_free.c:		env->sdl.texture_pixels[circle.center.x - y + env->w * (circle.center.y - x)] = circle.line_color;
draw_enemies.c:	while (i < env->nb_enemies)
draw_enemies.c:		if (env->enemies[i].sector == env->sectors[env->selected_floor].num)
draw_enemies.c:			env->enemies[i].pos.z = get_floor_at_pos(env->sectors[env->selected_floor], new_v2(env->enemies[i].pos.x, env->enemies[i].pos.y), env);
draw_enemies.c:	sprite = env->sprites[enemy.sprite];
draw_enemies.c:	texture = env->textures[sprite.texture];
draw_enemies.c:	pixels = env->sdl.texture_pixels;
draw_enemies.c:	zbuffer = env->zbuffer;
draw_enemies.c:			if ((enemy.rotated_pos.z < zbuffer[x + y * env->w]
draw_enemies.c:				env->enemies[enemy.num].seen = 1;
draw_enemies.c:				if (env->editor.select && x == env->h_w && y == env->h_h)
draw_enemies.c:					env->selected_wall1 = -1;
draw_enemies.c:					env->selected_wall2 = -1;
draw_enemies.c:					env->selected_floor = -1;
draw_enemies.c:					env->selected_ceiling = -1;
draw_enemies.c:					env->selected_object = -1;
draw_enemies.c:					env->selected_enemy = enemy.num;
draw_enemies.c:					env->editor.selected_wall = -1;
draw_enemies.c:				if (!env->options.lighting)
draw_enemies.c:					pixels[x + y * env->w] = texture_pixels[textx + texty * texture.surface->w];
draw_enemies.c:					pixels[x + y * env->w] = apply_light(texture_pixels[textx + texty * texture.surface->w], orender.light_color, orender.brightness);
draw_enemies.c:				if (env->enemies[enemy.num].hit)
draw_enemies.c:					pixels[x + y * env->w] = blend_alpha(pixels[x + y * env->w], 0xFFFF0000, enemy_hurt(env, enemy.num));
draw_enemies.c:				if (env->editor.in_game && !env->editor.select && env->selected_enemy == enemy.num)
draw_enemies.c:					pixels[x + y * env->w] = blend_alpha(pixels[x + y * env->w], 0xFF00FF00, 128);
draw_enemies.c:				zbuffer[x + y * env->w] = enemy.rotated_pos.z;
draw_enemies.c:		enemy->sprite = env->sprites[enemy->sprite].death_counterpart;
draw_enemies.c:	sprite = env->sprites[enemy->sprite];	
draw_enemies.c:	orender.xstart = ft_clamp(orender.x1, 0, env->w - 1);
draw_enemies.c:	orender.ystart = ft_clamp(orender.y1 + 1, 0, env->h - 1);
draw_enemies.c:	orender.xend = ft_clamp(orender.x2, 0, env->w - 1);
draw_enemies.c:	orender.yend = ft_clamp(orender.y2, 0, env->h - 1);
draw_enemies.c:	env->current_enemy = 0;
draw_enemies.c:		enemies_threads[i].xstart = env->nb_enemies / (double)THREADS * i;
draw_enemies.c:		enemies_threads[i].xend = env->nb_enemies / (double)THREADS * (i + 1);
draw_enemies.c:	while (i < env->nb_enemies)
draw_enemies.c:		if (env->enemies[i].state == FIRING)
draw_enemies.c:		if (env->enemies[i].rotated_pos.z > 1 && env->enemies[i].exists)
draw_enemies.c:			env->enemies[i].seen = 0;
draw_enemies.c:			if (!env->editor.in_game)
draw_enemies.c:				if (env->enemies[i].health <= 0)
draw_enemies.c:					dying_sprite = dying_enemy(env, i, env->sprites[env->enemies[i].sprite].nb_death_sprites);
draw_enemies.c:				if (env->enemies[i].state == RESTING)
draw_enemies.c:				else if (env->enemies[i].state == PURSUING)
draw_enemies.c:			if (env->enemies[i].exists)
draw_enemies.c:				draw_enemy(camera, &env->enemies[i], env, dying_sprite);
draw_floor.c:	pixels = env->sdl.texture_pixels;
draw_floor.c:	zbuffer = env->zbuffer;
draw_floor.c:	texture_w = env->textures[sector.floor_texture].surface->w;
draw_floor.c:	texture_h = env->textures[sector.floor_texture].surface->h;
draw_floor.c:	texture_pixels = env->textures[sector.floor_texture].str;
draw_floor.c:		coord = vline.x + env->w * i;
draw_floor.c:		if (env->editor.select && vline.x == env->h_w && i == env->h_h)
draw_floor.c:			env->selected_wall1 = -1;
draw_floor.c:			env->selected_wall2 = -1;
draw_floor.c:			env->selected_floor = render.sector;
draw_floor.c:			env->selected_ceiling = -1;
draw_floor.c:			env->selected_object = -1;
draw_floor.c:			env->selected_enemy = -1;
draw_floor.c:			env->editor.selected_wall = -1;
draw_floor.c:			if (!env->options.lighting && !env->playing)
draw_floor.c:			if (env->editor.in_game && !env->editor.select && env->selected_floor == render.sector)
draw_floor.c:			if (env->options.zbuffer || env->options.contouring)
draw_floor.c:					pixels[vline.x + env->w * i] = 0xFFFF0000;
draw_floor.c:	pixels = env->sdl.texture_pixels;
draw_floor.c:		coord = vline.x + env->w * vline.start;
draw_floor.c:		if (env->editor.select && vline.x == env->h_w && vline.start == env->h_h)
draw_floor.c:			env->selected_wall1 = -1;
draw_floor.c:			env->selected_wall2 = -1;
draw_floor.c:			env->selected_floor = render.sector;
draw_floor.c:			env->selected_ceiling = -1;
draw_floor.c:			env->selected_object = -1;
draw_floor.c:			env->selected_enemy = -1;
draw_floor.c:			env->editor.selected_wall = -1;
draw_floor.c:		if (env->editor.in_game && !env->editor.select && env->selected_floor == render.sector)
draw_floor.c:	vline.end = env->ymax[vline.x];
draw_floor2.c:	pixels = env->sdl.texture_pixels;
draw_floor2.c:	zbuffer = env->zbuffer;
draw_floor2.c:	texture = env->textures[sector.floor_texture];
draw_floor2.c:	line = render.y * env->w;
draw_floor2.c:		vline_data = env->vline_data[x];
draw_game.c:	SDL_GetRelativeMouseState(&env->sdl.mouse_x, &env->sdl.mouse_y);
draw_game.c:	env->test_time = SDL_GetTicks();
draw_game.c:	if (draw_render(&env->player.camera, env))
draw_game.c:	if (((env->inputs.left_click && !env->shot.on_going && !env->weapon_change.on_going) || env->shot.on_going) && env->player.health > 0)
draw_game.c:		weapon_animation(env, env->player.curr_weapon);
draw_game.c:	else if (env->player.health > 0)
draw_game.c:		draw_weapon(env, env->weapons[env->player.curr_weapon].first_sprite);
draw_game.c:	if (env->weapon_change.on_going && !env->shot.on_going)
draw_game.c:	if (env->options.show_fps)
draw_game.c:	if (env->options.test)
draw_game.c:	if (env->options.show_minimap)
draw_game.c:	if (env->player.health > 0)
draw_game.c:	if (env->player.hit)
draw_game.c:	if (env->options.test)
draw_game.c:		while (i < env->nb_enemies)
draw_game.c:			if (env->enemies[i].exists)
draw_game.c:				draw_line(new_point(env->enemies[i].left, env->enemies[i].top), new_point(env->enemies[i].right, env->enemies[i].top), *env, 0xFF00FF00);
draw_game.c:				draw_line(new_point(env->enemies[i].right, env->enemies[i].top), new_point(env->enemies[i].right, env->enemies[i].bottom), *env, 0xFF00FF00);
draw_game.c:				draw_line(new_point(env->enemies[i].right, env->enemies[i].bottom), new_point(env->enemies[i].left, env->enemies[i].bottom), *env, 0xFF00FF00);
draw_game.c:				draw_line(new_point(env->enemies[i].left, env->enemies[i].bottom), new_point(env->enemies[i].left, env->enemies[i].top), *env, 0xFF00FF00);
draw_game.c:	if (env->confirmation_box.state)
draw_game.c:		draw_confirmation_box(env->confirmation_box, env);
draw_game.c:	if (env->options.zbuffer)
draw_game.c:	if (env->player.health > 0)
draw_grid.c:	pixels = env->sdl.texture_pixels;
draw_grid.c:	x = env->editor.center.x;
draw_grid.c:	if (x >= 200 && x < env->w)
draw_grid.c:		y = ft_clamp(env->editor.center.y - 10, 0, env->h - 1);
draw_grid.c:		max = ft_clamp(env->editor.center.y, 0, env->h - 1);
draw_grid.c:			pixels[x + y * env->w] = 0xFFFF0000;
draw_grid.c:		y = ft_clamp(env->editor.center.y + 10, 0, env->h - 1);
draw_grid.c:			pixels[x + y * env->w] = 0xFFFF0000;
draw_grid.c:	y = env->editor.center.y;
draw_grid.c:	if (y >= 0 && y < env->h)
draw_grid.c:		x = ft_clamp(env->editor.center.x - 10, 199, env->w);
draw_grid.c:		max = ft_clamp(env->editor.center.x, 199, env->w - 1);
draw_grid.c:			pixels[x + y * env->w] = 0xFFFF0000;
draw_grid.c:		x = ft_clamp(env->editor.center.x + 10, 199, env->w - 1);
draw_grid.c:			pixels[x + y * env->w] = 0xFFFF0000;
draw_grid_enemy.c:	if (env->editor.dragged_enemy != -1)
draw_grid_enemy.c:		scale = env->editor.scale / 2.0;
draw_grid_enemy.c:		center.x = env->sdl.mx;
draw_grid_enemy.c:		center.y = env->sdl.my;
draw_grid_enemy.c:	while (i < env->nb_enemies)
draw_grid_enemy.c:		center.x = env->enemies[i].pos.x * env->editor.scale + env->editor.center.x;
draw_grid_enemy.c:		center.y = env->enemies[i].pos.y * env->editor.scale + env->editor.center.y;
draw_grid_enemy.c:		if (env->sdl.mx > center.x - env->editor.scale / 2.0
draw_grid_enemy.c:				&& env->sdl.mx < center.x + env->editor.scale / 2.0
draw_grid_enemy.c:				&& env->sdl.my > center.y - env->editor.scale / 2.0
draw_grid_enemy.c:				&& env->sdl.my < center.y + env->editor.scale / 2.0)
draw_grid_enemy.c:			scale = env->editor.scale;
draw_grid_enemy.c:			if (env->inputs.left_click
draw_grid_enemy.c:					&& !env->confirmation_box.state
draw_grid_enemy.c:					&& env->editor.start_vertex == -1
draw_grid_enemy.c:					&& env->editor.dragged_player == -1
draw_grid_enemy.c:					&& env->editor.dragged_enemy == -1
draw_grid_enemy.c:					&& env->editor.dragged_vertex == -1
draw_grid_enemy.c:					&& env->editor.dragged_object == -1
draw_grid_enemy.c:					&& !env->teleport.create)
draw_grid_enemy.c:				env->editor.dragged_enemy = i;
draw_grid_enemy.c:				env->selected_enemy = i;
draw_grid_enemy.c:				env->editor.selected_vertex = -1;
draw_grid_enemy.c:				env->editor.selected_sector = -1;
draw_grid_enemy.c:				env->editor.selected_player = -1;
draw_grid_enemy.c:				env->editor.selected_object = -1;
draw_grid_enemy.c:			scale = env->editor.scale / 2.0;
draw_grid_enemy.c:		if (env->selected_enemy == i)
draw_grid_enemy.c:		if (env->editor.dragged_enemy != i)
draw_grid_enemy.c:		/*v[0] = new_v3(center.x + cos(env->enemies[i].angle - M_PI / 2) * scale / 2,
draw_grid_enemy.c:				center.y + sin(env->enemies[i].angle - M_PI / 2) * scale / 2,
draw_grid_enemy.c:		v[2] = new_v3(center.x - cos(env->enemies[i].angle - M_PI / 2) * scale / 2,
draw_grid_enemy.c:				center.y - sin(env->enemies[i].angle - M_PI / 2) * scale / 2,
draw_grid_enemy.c:		v[1] = new_v3(center.x + cos(env->enemies[i].angle) * scale * 2,
draw_grid_enemy.c:				center.y + sin(env->enemies[i].angle) * scale * 2,
draw_grid_objects.c:	if (env->editor.dragged_object != -1)
draw_grid_objects.c:		scale = env->editor.scale / 2.0;
draw_grid_objects.c:		center.x = env->sdl.mx;
draw_grid_objects.c:		center.y = env->sdl.my;
draw_grid_objects.c:	while (i < env->nb_objects)
draw_grid_objects.c:		center.x = env->objects[i].pos.x * env->editor.scale + env->editor.center.x;
draw_grid_objects.c:		center.y = env->objects[i].pos.y * env->editor.scale + env->editor.center.y;
draw_grid_objects.c:		if (env->sdl.mx > center.x - env->editor.scale / 2.0
draw_grid_objects.c:				&& env->sdl.mx < center.x + env->editor.scale / 2.0
draw_grid_objects.c:				&& env->sdl.my > center.y - env->editor.scale / 2.0
draw_grid_objects.c:				&& env->sdl.my < center.y + env->editor.scale / 2.0)
draw_grid_objects.c:			scale = env->editor.scale;
draw_grid_objects.c:			if (env->inputs.left_click
draw_grid_objects.c:					&& !env->confirmation_box.state
draw_grid_objects.c:					&& env->editor.start_vertex == -1
draw_grid_objects.c:					&& env->editor.dragged_player == -1
draw_grid_objects.c:					&& env->editor.dragged_object == -1
draw_grid_objects.c:					&& env->editor.dragged_vertex == -1
draw_grid_objects.c:					&& env->editor.dragged_enemy == -1
draw_grid_objects.c:					&& !env->teleport.create)
draw_grid_objects.c:				env->editor.dragged_object = i;
draw_grid_objects.c:				env->editor.selected_object = i;
draw_grid_objects.c:				env->editor.selected_vertex = -1;
draw_grid_objects.c:				env->editor.selected_sector = -1;
draw_grid_objects.c:				env->editor.selected_player = -1;
draw_grid_objects.c:				env->selected_enemy = -1;
draw_grid_objects.c:			scale = env->editor.scale / 2.0;
draw_grid_objects.c:		if (env->editor.selected_object == i)
draw_grid_objects.c:		if (env->editor.dragged_object != i)
draw_grid_objects.c:	/*	v[0] = new_v3(center.x + cos(env->objects[i].angle - M_PI / 2) * scale / 2,
draw_grid_objects.c:				center.y + sin(env->objects[i].angle - M_PI / 2) * scale / 2,
draw_grid_objects.c:		v[2] = new_v3(center.x - cos(env->objects[i].angle - M_PI / 2) * scale / 2,
draw_grid_objects.c:				center.y - sin(env->objects[i].angle - M_PI / 2) * scale / 2,
draw_grid_objects.c:		v[1] = new_v3(center.x + cos(env->objects[i].angle) * scale * 2,
draw_grid_objects.c:				center.y + sin(env->objects[i].angle) * scale * 2,
draw_grid_player.c:	if (env->editor.dragged_player == 1)
draw_grid_player.c:		circle.center.x = env->sdl.mx;
draw_grid_player.c:		circle.center.y = env->sdl.my;
draw_grid_player.c:		circle.radius = env->editor.scale;
draw_grid_player.c:		circle.center.x = (env->player.pos.x * env->editor.scale) + env->editor.center.x;
draw_grid_player.c:		circle.center.y = (env->player.pos.y * env->editor.scale) + env->editor.center.y;
draw_grid_player.c:		if (env->sdl.mx > circle.center.x - env->editor.scale / 2
draw_grid_player.c:				&& env->sdl.mx < circle.center.x + env->editor.scale / 2
draw_grid_player.c:				&& env->sdl.my > circle.center.y - env->editor.scale / 2
draw_grid_player.c:				&& env->sdl.my < circle.center.y + env->editor.scale / 2)
draw_grid_player.c:			circle.radius = env->editor.scale;
draw_grid_player.c:			if (env->inputs.left_click
draw_grid_player.c:					&& !env->confirmation_box.state
draw_grid_player.c:					&& env->editor.start_vertex == -1
draw_grid_player.c:					&& env->editor.dragged_player == -1
draw_grid_player.c:					&& env->editor.dragged_object == -1
draw_grid_player.c:					&& env->editor.dragged_vertex == -1
draw_grid_player.c:					&& !env->teleport.create)
draw_grid_player.c:				env->editor.dragged_player = 1;
draw_grid_player.c:				env->editor.selected_player = 1;
draw_grid_player.c:				env->editor.selected_object = -1;
draw_grid_player.c:				env->editor.selected_vertex = -1;
draw_grid_player.c:				env->editor.selected_sector = -1;
draw_grid_player.c:			circle.radius = env->editor.scale / 2;
draw_grid_player.c:	if (env->editor.selected_player == 1)
draw_grid_player.c:	v[0] = new_v3(circle.center.x + env->player.camera.perp_cos * circle.radius / 2,
draw_grid_player.c:			circle.center.y + env->player.camera.perp_sin * circle.radius / 2,
draw_grid_player.c:	v[2] = new_v3(circle.center.x - env->player.camera.perp_cos * circle.radius / 2,
draw_grid_player.c:			circle.center.y - env->player.camera.perp_sin * circle.radius / 2,
draw_grid_player.c:	v[1] = new_v3(circle.center.x + env->player.camera.angle_cos * circle.radius * 2,
draw_grid_player.c:			circle.center.y + env->player.camera.angle_sin * circle.radius * 2,
draw_grid_player.c:	/*if (env->editor.selected_player == 1)
draw_grid_vertices.c:	if (env->editor.dragged_vertex != -1)
draw_grid_vertices.c:		scale = env->editor.scale / 5.0;
draw_grid_vertices.c:		env->vertices[env->editor.dragged_vertex].x = round((env->sdl.mx - env->editor.center.x) / env->editor.scale);
draw_grid_vertices.c:		env->vertices[env->editor.dragged_vertex].y = round((env->sdl.my - env->editor.center.y) / env->editor.scale);
draw_grid_vertices.c:		center.x = env->vertices[env->editor.dragged_vertex].x * env->editor.scale + env->editor.center.x;
draw_grid_vertices.c:		center.y = env->vertices[env->editor.dragged_vertex].y * env->editor.scale + env->editor.center.y;
draw_grid_vertices.c:	while (i < env->nb_vertices)
draw_grid_vertices.c:		vertex = env->vertices[i];
draw_grid_vertices.c:		center = new_point(env->editor.center.x + vertex.x * env->editor.scale,
draw_grid_vertices.c:				env->editor.center.y + vertex.y * env->editor.scale);
draw_grid_vertices.c:		if (env->sdl.mx > center.x - env->editor.scale / 3.0
draw_grid_vertices.c:				&& env->sdl.mx < center.x + env->editor.scale / 3.0
draw_grid_vertices.c:				&& env->sdl.my > center.y - env->editor.scale / 3.0
draw_grid_vertices.c:				&& env->sdl.my < center.y + env->editor.scale / 3.0)
draw_grid_vertices.c:			scale = env->editor.scale / 3.0;
draw_grid_vertices.c:			if (env->inputs.left_click
draw_grid_vertices.c:					&& !env->confirmation_box.state
draw_grid_vertices.c:					&& env->editor.start_vertex == -1
draw_grid_vertices.c:					&& env->editor.dragged_vertex == -1
draw_grid_vertices.c:					&& env->editor.dragged_player == -1
draw_grid_vertices.c:					&& env->editor.dragged_object == -1
draw_grid_vertices.c:					&& !env->teleport.create)
draw_grid_vertices.c:				env->editor.dragged_vertex = i;
draw_grid_vertices.c:				env->editor.selected_vertex = i;
draw_grid_vertices.c:				env->editor.selected_object = -1;
draw_grid_vertices.c:				env->editor.selected_player = -1;
draw_grid_vertices.c:				env->editor.selected_sector = -1;
draw_grid_vertices.c:				env->editor.start_pos.x = env->vertices[env->editor.selected_vertex].x;
draw_grid_vertices.c:				env->editor.start_pos.y = env->vertices[env->editor.selected_vertex].y;
draw_grid_vertices.c:			scale = env->editor.scale / 5.0;
draw_grid_vertices.c:		if (env->editor.dragged_vertex == i || env->editor.selected_vertex == i)
draw_grid_walls.c:	tmp = env->editor.current_vertices;
draw_grid_walls.c:	v1.x = env->editor.center.x + v->x * env->editor.scale;
draw_grid_walls.c:	v1.y = env->editor.center.y + v->y * env->editor.scale;
draw_grid_walls.c:		v2.x = env->editor.center.x + v->x * env->editor.scale;
draw_grid_walls.c:		v2.y = env->editor.center.y + v->y * env->editor.scale;
draw_grid_walls.c:	if (env->drawing)
draw_grid_walls.c:		v2.x = env->sdl.mx;
draw_grid_walls.c:		v2.y = env->sdl.my;
draw_grid_walls.c:		v1.x = env->editor.center.x +
draw_grid_walls.c:			env->vertices[sector.vertices[i]].x * env->editor.scale;
draw_grid_walls.c:		v1.y = env->editor.center.y +
draw_grid_walls.c:			env->vertices[sector.vertices[i]].y * env->editor.scale;
draw_grid_walls.c:		v2.x = env->editor.center.x +
draw_grid_walls.c:			env->vertices[sector.vertices[i + 1]].x * env->editor.scale;
draw_grid_walls.c:		v2.y = env->editor.center.y +
draw_grid_walls.c:			env->vertices[sector.vertices[i + 1]].y * env->editor.scale;
draw_grid_walls.c:	while (i < env->nb_sectors)
draw_grid_walls.c:		if (i == env->editor.selected_sector)
draw_grid_walls.c:			draw_grid_sector(env->sectors[i], 0xFF00FF00, env);
draw_grid_walls.c:			draw_grid_sector(env->sectors[i], 0xFFFFFFFF, env);
draw_hud.c:	window_w = (int)(env->w)/*  - env->textures[ARMOR_LIFE_HUD].surface->w */;
draw_hud.c:	window_h = (env->h - env->textures[ARMOR_LIFE_HUD].surface->h);
draw_hud.c:	while (x < env->textures[ARMOR_LIFE_HUD].surface->w && window_w + x < env->w)
draw_hud.c:		while (y < env->textures[ARMOR_LIFE_HUD].surface->h  && (window_h + y) < env->h)
draw_hud.c:			if (env->textures[ARMOR_LIFE_HUD].str[x + env->textures[ARMOR_LIFE_HUD].surface->w * y] != 0xFFC10099)
draw_hud.c:				env->sdl.texture_pixels[(window_w + x) + env->w * (window_h + y)] = 
draw_hud.c:					env->textures[ARMOR_LIFE_HUD].str[x + env->textures[ARMOR_LIFE_HUD].surface->w * y];
draw_hud.c:	window_w = (int)(env->w) - env->textures[AMMO_HUD].surface->w;
draw_hud.c:	window_h = (env->h - env->textures[AMMO_HUD].surface->h);
draw_hud.c:	while (x < env->textures[AMMO_HUD].surface->w)
draw_hud.c:		while (y < env->textures[AMMO_HUD].surface->h  && (window_h + y) < env->h)
draw_hud.c:			if (env->textures[AMMO_HUD].str[x + env->textures[AMMO_HUD].surface->w * y] != 0xFFC10099)
draw_hud.c:				env->sdl.texture_pixels[(window_w + x) + env->w * (window_h + y)] = 
draw_hud.c:					env->textures[AMMO_HUD].str[x + env->textures[AMMO_HUD].surface->w * y];
draw_hud.c:	str = ft_sitoa(env->player.health);
draw_hud.c:	print_text(new_point(830, 300), new_printable_text(str, env->sdl.fonts.amazdoom50, 0xA1A1A100, 0), env);
draw_hud.c:	str = ft_sitoa(env->player.armor);
draw_hud.c:	print_text(new_point(830, 80), new_printable_text(str, env->sdl.fonts.amazdoom50, 0xA1A1A100, 0), env);
draw_objects.c:	while (i < env->nb_objects)
draw_objects.c:		if (env->objects[i].sector == env->sectors[env->selected_floor].num)
draw_objects.c:			env->objects[i].pos.z = get_floor_at_pos(env->sectors[env->selected_floor], new_v2(env->objects[i].pos.x, env->objects[i].pos.y), env);
draw_objects.c:	sprite = env->sprites[object.sprite];
draw_objects.c:	texture = env->textures[sprite.texture];
draw_objects.c:	pixels = env->sdl.texture_pixels;
draw_objects.c:	zbuffer = env->zbuffer;
draw_objects.c:			if ((object.rotated_pos.z < zbuffer[x + y * env->w]
draw_objects.c:				if (env->editor.select && x == env->h_w && y == env->h_h)
draw_objects.c:					env->selected_wall1 = -1;
draw_objects.c:					env->selected_wall2 = -1;
draw_objects.c:					env->selected_floor = -1;
draw_objects.c:					env->selected_ceiling = -1;
draw_objects.c:					env->selected_object = object.num;
draw_objects.c:					env->selected_enemy = -1;
draw_objects.c:					env->editor.selected_wall = -1;
draw_objects.c:				if (!env->options.lighting)
draw_objects.c:					pixels[x + y * env->w] = texture_pixels[textx + texty * texture.surface->w];
draw_objects.c:					pixels[x + y * env->w] = apply_light(texture_pixels[textx + texty * texture.surface->w], orender.light_color, orender.brightness);
draw_objects.c:				if (env->editor.in_game && !env->editor.select && env->selected_object == object.num)
draw_objects.c:					pixels[x + y * env->w] = blend_alpha(pixels[x + y * env->w], 0xFF00FF00, 128);
draw_objects.c:				zbuffer[x + y * env->w] = object.rotated_pos.z;
draw_objects.c:	sprite = env->sprites[object->sprite];
draw_objects.c:	orender.xstart = ft_clamp(orender.x1, 0, env->w - 1);
draw_objects.c:	orender.ystart = ft_clamp(orender.y1 + 1, 0, env->h - 1);
draw_objects.c:	orender.xend = ft_clamp(orender.x2, 0, env->w - 1);
draw_objects.c:	orender.yend = ft_clamp(orender.y2, 0, env->h - 1);
draw_objects.c:	env->current_object = 0;
draw_objects.c:		object_threads[i].xstart = env->nb_objects / (double)THREADS * i;
draw_objects.c:		object_threads[i].xend = env->nb_objects / (double)THREADS * (i + 1);
draw_objects.c:	while (i < env->nb_objects)
draw_objects.c:		if (env->objects[i].rotated_pos.z > 1 && env->objects[i].exists)
draw_objects.c:			draw_object(camera, &env->objects[i], env);
draw_players.c:	if (camera.pos.x == env->player.pos.x && camera.pos.y == env->player.pos.y
draw_players.c:			&& camera.pos.z == env->player.head_z)
draw_players.c:	player.pos = env->player.pos;
draw_players.c:	if (env->player.camera.angle < 0)
draw_players.c:		player.angle = 360 + (int)(env->player.camera.angle * CONVERT_DEGREES) % 360;
draw_players.c:		player.angle = (int)(env->player.camera.angle * CONVERT_DEGREES) % 360;
draw_rectangle.c:	if (pos.x < 0 || pos.y < 0 || pos.x >= env->w || pos.y >= env->h
draw_rectangle.c:	while (++y <= pos.y + size.y && y < env->h)
draw_rectangle.c:		while (++x <= pos.x + size.x && x < env->w)
draw_rectangle.c:				env->sdl.texture_pixels[x + y * env->w] = r.line_color;
draw_rectangle.c:				env->sdl.texture_pixels[x + y * env->w] = r.inside_color;
draw_skybox.c:	v1 = env->skybox[skybox.i];
draw_skybox.c:	if ((!wall_data.mode && env->selected_ceiling == render.sector)
draw_skybox.c:			|| (wall_data.mode && env->sectors[render.sector].selected[render.i]))
draw_skybox.c:		min = env->ymin[x];
draw_skybox.c:			+ skybox.alpha / env->skybox[skybox.i + 1].vz);
draw_skybox.c:	skybox.divider = 1 / (env->skybox[skybox.i + 1].vz
draw_skybox.c:			env->ymin[x], env->ymax[x]);
draw_skybox.c:			env->ymin[x], env->ymax[x]);
draw_skybox.c:		if ((env->options.zbuffer || env->options.contouring)
draw_skybox.c:				&& (x == (int)v1.x || x == (int)env->skybox[skybox.i + 1].x))
draw_skybox.c:		if (!env->skybox[i].draw
draw_skybox.c:				|| env->skybox[i].clipped_x1 >= env->skybox[i].clipped_x2
draw_skybox.c:				|| env->skybox[i].clipped_x1 > render.x
draw_skybox.c:				|| env->skybox[i].clipped_x2 < render.x)
draw_skybox.c:		skybox.ceiling_horizon = env->player.camera.horizon;
draw_skybox.c:		skybox.floor_horizon = env->player.camera.horizon;
draw_skybox2.c:	v1 = env->skybox[skybox.i];
draw_skybox2.c:	if ((!wall_data.mode && env->selected_ceiling == render.sector)
draw_skybox2.c:			|| (wall_data.mode && env->sectors[render.sector].selected[render.i]))
draw_skybox2.c:		if (!env->skybox[i].draw
draw_skybox2.c:				|| env->skybox[i].clipped_x1 >= env->skybox[i].clipped_x2)
draw_wall.c:	pixels = env->sdl.texture_pixels;
draw_wall.c:	texture_pixels = env->textures[render.texture].str;
draw_wall.c:	zbuffer = env->zbuffer;
draw_wall.c:		coord = vline.x + env->w * i;
draw_wall.c:		if (env->editor.select && vline.x == env->h_w && i == env->h_h)
draw_wall.c:			if (env->editor.in_game && !env->teleport.create)
draw_wall.c:				env->editor.selected_sector = env->sectors[render.sector].num;
draw_wall.c:				env->editor.selected_wall = render.i;
draw_wall.c:			env->selected_wall1 = env->sectors[render.sector].vertices[render.i];
draw_wall.c:			env->selected_wall2 = env->sectors[render.sector].vertices[render.i + 1];
draw_wall.c:			env->selected_floor = -1;
draw_wall.c:			env->selected_ceiling = -1;
draw_wall.c:			env->selected_object = -1;
draw_wall.c:			env->selected_enemy = -1;
draw_wall.c:		if (!env->options.lighting && !env->playing)
draw_wall.c:		if (env->editor.in_game && sector.selected[render.i] && !env->editor.select)
draw_wall.c:		if (env->options.zbuffer || env->options.contouring)
draw_wall.c:	pixels = env->sdl.texture_pixels;
draw_wall.c:		coord = vline.x + env->w * vline.start;
draw_wall.c:	if ((env->options.zbuffer || env->options.contouring)
draw_wall.c:	if ((env->options.zbuffer || env->options.contouring)
draw_wall.c:	if ((env->options.zbuffer || env->options.contouring)
draw_wall.c:	if (env->options.zbuffer || env->options.contouring)
draw_wall.c:				&& render.z < env->sdl.texture_pixels[env->w * (vline.start)
draw_wall.c:			env->sdl.texture_pixels[env->w * (vline.start)
draw_wall.c:				&& render.z < env->sdl.texture_pixels[env->w * (vline.end)
draw_wall.c:			env->sdl.texture_pixels[env->w * (vline.end)
draw_wall2.c:	pixels = env->sdl.texture_pixels;
draw_wall2.c:	zbuffer = env->zbuffer;
draw_wall2.c:	texture = env->textures[render.texture];
draw_wall2.c:	line = render.y * env->w;
draw_wall2.c:		vline_data = env->vline_data[x];
draw_wall_sprites.c:	zbuffer = env->zbuffer;
draw_wall_sprites.c:	pixels = env->sdl.texture_pixels;
draw_wall_sprites.c:	sprite_pixels = env->textures[env->sprites[sector.sprites[render.i]
draw_wall_sprites.c:	sprite_w = env->textures[env->sprites[sector.sprites[render.i]
draw_wall_sprites.c:	start = env->sprites[sector.sprites[render.i].sprite[sprite]].start[0].y;
draw_wall_sprites.c:	end = env->sprites[sector.sprites[render.i].sprite[sprite]].end[0].y;
draw_wall_sprites.c:		coord = render.x + env->w * i;
draw_wall_sprites.c:			/*if (env->editor.select && render.sprite_x == env->h_w && y == env->h_h)
draw_wall_sprites.c:				env->selected_wall1 = -1;
draw_wall_sprites.c:				env->selected_wall2 = -1;
draw_wall_sprites.c:				env->selected_floor = -1;
draw_wall_sprites.c:				env->selected_ceiling = -1;
draw_wall_sprites.c:				env->selected_object = -1;
draw_wall_sprites.c:				env->selected_enemy = -1;
draw_wall_sprites.c:				env->editor.selected_wall = -1;
draw_wall_sprites.c:				env->selected_wall_sprite_wall = render.i;
draw_wall_sprites.c:				env->selected_wall_sprite_sprite = sprite;
draw_wall_sprites.c:			if (!env->options.lighting && !env->playing)
draw_wall_sprites.c:			if (env->editor.in_game && !env->editor.select
draw_wall_sprites.c:				&& env->selected_wall_sprite_wall == render.i
draw_wall_sprites.c:				&& env->selected_wall_sprite_sprite == sprite)
draw_wall_sprites.c:			start = env->sprites[sector.sprites[render.i].sprite[i]].start[0].x;
draw_wall_sprites.c:			end = env->sprites[sector.sprites[render.i].sprite[i]].end[0].x;
editor.c:	while (env->running)
editor.c:		SDL_GetRelativeMouseState(&env->sdl.mouse_x, &env->sdl.mouse_y);
editor.c:		SDL_GetMouseState(&env->sdl.mx, &env->sdl.my);
editor.c:		while (SDL_PollEvent(&env->sdl.event))
editor.c:			if (env->sdl.event.type == SDL_QUIT || (env->sdl.event.type == SDL_KEYUP && env->sdl.event.key.keysym.sym == SDLK_ESCAPE))
editor.c:				env->running = 0;
editor.c:			else if (env->sdl.event.type == SDL_KEYDOWN
editor.c:					|| env->sdl.event.type == SDL_KEYUP || env->sdl.event.type == SDL_MOUSEBUTTONDOWN
editor.c:					|| env->sdl.event.type == SDL_MOUSEBUTTONUP || env->sdl.event.type == SDL_MOUSEWHEEL)
editor.c:			if (env->sdl.event.type == SDL_KEYUP || env->sdl.event.type == SDL_MOUSEBUTTONUP)
editor.c:			if (!env->editor.in_game && env->sdl.event.type == SDL_MOUSEWHEEL)
editor.c:				if (env->sdl.event.wheel.y > 0 && env->editor.scale * 1.1 < 100)
editor.c:					env->editor.center.x = env->sdl.mx + ((env->editor.center.x - env->sdl.mx) * 1.1);
editor.c:					env->editor.center.y = env->sdl.my + ((env->editor.center.y - env->sdl.my) * 1.1);
editor.c:					env->editor.scale *= 1.1;
editor.c:				if (env->sdl.event.wheel.y < 0 && env->editor.scale / 1.1 > 1)
editor.c:					env->editor.center.x = env->sdl.mx + ((env->editor.center.x - env->sdl.mx) / 1.1);
editor.c:					env->editor.center.y = env->sdl.my + ((env->editor.center.y - env->sdl.my) / 1.1);
editor.c:					env->editor.scale /= 1.1;
editor.c:		if (!env->editor.in_game)
editor.c:			if (env->editor.new_player || env->editor.dragged_player == 1)
editor.c:			if (env->editor.dragged_object != -1 || env->nb_objects > 0)
editor.c:			if (env->editor.dragged_enemy != -1 || env->nb_enemies > 0)
editor.c:			if (env->editor.start_vertex != -1)
editor.c:		if (env->confirmation_box.state)
editor.c:			draw_confirmation_box(env->confirmation_box, env);
editor.c:		if (env->options.zbuffer && env->editor.in_game)
editor_hud.c:	if (env->selected_enemy != -1)
editor_hud.c:		print_text(new_point(90 + env->selected_stat * 40, 240), new_printable_text("->|                              |<-",
editor_hud.c:				env->sdl.fonts.alice30, 0xFF00FF00, 30), env);
editor_hud.c:	else if (env->editor.selected_sector != -1)
editor_hud.c:		print_text(new_point(90 + env->selected_stat * 120, 240), new_printable_text("->|                             |<-",
editor_hud.c:				env->sdl.fonts.alice30, 0xFF00FF00, 30), env);
editor_hud.c:				env->sdl.fonts.alice30, 0xFFFFFFFF, 30), env);
editor_hud.c:	print_text(new_point(10, 480), new_printable_text(ft_sitoa(env->editor.selected_vertex),
editor_hud.c:				env->sdl.fonts.alice30, 0xFFFFFFFF, 30), env);
editor_hud.c:	print_text(new_point(90, 280), new_printable_text("Coordonates:", env->sdl.fonts.alice30, 0xFFFFFFFF, 30), env);
editor_hud.c:	print_text(new_point(140, 300), new_printable_text("X:", env->sdl.fonts.alice30, 0xFFFFFFFF, 30), env);
editor_hud.c:	print_text(new_point(140, 400), new_printable_text(ft_sitoa(env->vertices[env->editor.selected_vertex].x), env->sdl.fonts.alice30, 0xFFFFFFFF, 30), env);
editor_hud.c:	print_text(new_point(180, 300), new_printable_text("Y:", env->sdl.fonts.alice30, 0xFFFFFFFF, 30), env);
editor_hud.c:	print_text(new_point(180, 400), new_printable_text(ft_sitoa(env->vertices[env->editor.selected_vertex].y), env->sdl.fonts.alice30, 0xFFFFFFFF, 30), env);
editor_hud.c:	print_text(new_point(10, 390), new_printable_text("sector ", env->sdl.fonts.alice30, 0xFFFFFFFF, 30), env);
editor_hud.c:	print_text(new_point(10, 480), new_printable_text(ft_sitoa(env->editor.selected_sector), env->sdl.fonts.alice30, 0xFFFFFFFF, 30), env);
editor_hud.c:	print_text(new_point(90, 280), new_printable_text("floor: ", env->sdl.fonts.alice30, 0xFFFFFFFF, 30), env);
editor_hud.c:	print_text(new_point(90, 440), new_printable_text(ft_sitoa(env->sectors[env->editor.selected_sector].floor), env->sdl.fonts.alice30, 0xFFFFFFFF, 30), env);
editor_hud.c:	print_text(new_point(130, 280), new_printable_text("(f) Slope: ", env->sdl.fonts.alice30, 0xFFFFFFFF, 30), env);
editor_hud.c:	print_text(new_point(130, 440), new_printable_text(ft_sitoa(env->sectors[env->editor.selected_sector].floor_slope), env->sdl.fonts.alice30, 0xFFFFFFFF, 30), env);
editor_hud.c:	print_text(new_point(170, 280), new_printable_text("Texture: ", env->sdl.fonts.alice30, 0xFFFFFFFF, 30), env);
editor_hud.c:	print_text(new_point(170, 440), new_printable_text(ft_sitoa(env->sectors[env->editor.selected_sector].floor_texture), env->sdl.fonts.alice30, 0xFFFFFFFF, 30), env);
editor_hud.c:	print_text(new_point(210, 280), new_printable_text("Ceiling: ", env->sdl.fonts.alice30, 0xFFFFFFFF, 30), env);
editor_hud.c:	print_text(new_point(210, 440), new_printable_text(ft_sitoa(env->sectors[env->editor.selected_sector].ceiling), env->sdl.fonts.alice30, 0xFFFFFFFF, 30), env);
editor_hud.c:	print_text(new_point(250, 280), new_printable_text("(C) Slope: ", env->sdl.fonts.alice30, 0xFFFFFFFF, 30), env);
editor_hud.c:	print_text(new_point(250, 440), new_printable_text(ft_sitoa(env->sectors[env->editor.selected_sector].ceiling_slope), env->sdl.fonts.alice30, 0xFFFFFFFF, 30), env);
editor_hud.c:	print_text(new_point(290, 280), new_printable_text("Texture: ", env->sdl.fonts.alice30, 0xFFFFFFFF, 30), env);
editor_hud.c:	print_text(new_point(290, 440), new_printable_text(ft_sitoa(env->sectors[env->editor.selected_sector].ceiling_texture), env->sdl.fonts.alice30, 0xFFFFFFFF, 30), env);
editor_hud.c:	print_text(new_point(330, 280), new_printable_text("Bright: ", env->sdl.fonts.alice30, 0xFFFFFFFF, 30), env);
editor_hud.c:	print_text(new_point(330, 420), new_printable_text(ft_sitoa(env->sectors[env->editor.selected_sector].brightness), env->sdl.fonts.alice30, 0xFFFFFFFF, 30), env);
editor_hud.c:	print_text(new_point(370, 280), new_printable_text("status: ", env->sdl.fonts.alice30, 0xFFFFFFFF, 30), env);
editor_hud.c:	print_text(new_point(370, 420), new_printable_text(ft_sitoa(env->sectors[env->editor.selected_sector].status), env->sdl.fonts.alice30, 0xFFFFFFFF, 30), env);
editor_hud.c:	if (env->editor.tab)
editor_hud.c:	print_text(new_point(10, 390), new_printable_text("object ", env->sdl.fonts.alice30, 0xFFFFFFFF, 30), env);
editor_hud.c:	print_text(new_point(10, 480), new_printable_text(ft_sitoa(env->editor.selected_object), env->sdl.fonts.alice30, 0xFFFFFFFF, 30), env);
editor_hud.c:	print_text(new_point(90, 280), new_printable_text("Coordonates:", env->sdl.fonts.alice30, 0xFFFFFFFF, 30), env);
editor_hud.c:	if (env->editor.selected_object != -1)
editor_hud.c:		print_text(new_point(130, 300), new_printable_text("pos_x : ", env->sdl.fonts.alice30, 0xFFFFFFFF, 30), env);
editor_hud.c:		print_text(new_point(130, 430), new_printable_text(ft_sitoa(env->objects[env->editor.selected_object].pos.x), env->sdl.fonts.alice30, 0xFFFFFFFF, 30), env);
editor_hud.c:		print_text(new_point(170, 300), new_printable_text("pos_y : ", env->sdl.fonts.alice30, 0xFFFFFFFF, 30), env);
editor_hud.c:		print_text(new_point(170, 430), new_printable_text(ft_sitoa(env->objects[env->editor.selected_object].pos.y), env->sdl.fonts.alice30, 0xFFFFFFFF, 30), env);
editor_hud.c:		print_text(new_point(210, 300), new_printable_text("pos_z : ", env->sdl.fonts.alice30, 0xFFFFFFFF, 30), env);
editor_hud.c:		print_text(new_point(210, 430), new_printable_text(ft_sitoa(env->objects[env->editor.selected_object].pos.z), env->sdl.fonts.alice30, 0xFFFFFFFF, 30), env);
editor_hud.c:		print_text(new_point(130, 300), new_printable_text("pos_x : ", env->sdl.fonts.alice30, 0xFFFFFFFF, 30), env);
editor_hud.c:		print_text(new_point(130, 430), new_printable_text(ft_sitoa(env->objects[env->selected_object].pos.x), env->sdl.fonts.alice30, 0xFFFFFFFF, 30), env);
editor_hud.c:		print_text(new_point(170, 300), new_printable_text("pos_y : ", env->sdl.fonts.alice30, 0xFFFFFFFF, 30), env);
editor_hud.c:		print_text(new_point(170, 430), new_printable_text(ft_sitoa(env->objects[env->selected_object].pos.y), env->sdl.fonts.alice30, 0xFFFFFFFF, 30), env);
editor_hud.c:		print_text(new_point(210, 300), new_printable_text("pos_z : ", env->sdl.fonts.alice30, 0xFFFFFFFF, 30), env);
editor_hud.c:		print_text(new_point(210, 430), new_printable_text(ft_sitoa(env->objects[env->selected_object].pos.z), env->sdl.fonts.alice30, 0xFFFFFFFF, 30), env);
editor_hud.c:	print_text(new_point(90, 280), new_printable_text("Coordonates:", env->sdl.fonts.alice30, 0xFFFFFFFF, 30), env);
editor_hud.c:	print_text(new_point(10, 400), new_printable_text("player ", env->sdl.fonts.alice30, 0xFFFFFFFF, 30), env);
editor_hud.c:	print_text(new_point(130, 300), new_printable_text("pos_x : ", env->sdl.fonts.alice30, 0xFFFFFFFF, 30), env);
editor_hud.c:	print_text(new_point(130, 430), new_printable_text(ft_sitoa(env->player.pos.x), env->sdl.fonts.alice30, 0xFFFFFFFF, 30), env);
editor_hud.c:	print_text(new_point(170, 300), new_printable_text("pos_y : ", env->sdl.fonts.alice30, 0xFFFFFFFF, 30), env);
editor_hud.c:	print_text(new_point(170, 430), new_printable_text(ft_sitoa(env->player.pos.y), env->sdl.fonts.alice30, 0xFFFFFFFF, 30), env);
editor_hud.c:	print_text(new_point(210, 300), new_printable_text("pos_z : ", env->sdl.fonts.alice30, 0xFFFFFFFF, 30), env);
editor_hud.c:	print_text(new_point(210, 430), new_printable_text(ft_sitoa(env->player.pos.z), env->sdl.fonts.alice30, 0xFFFFFFFF, 30), env);
editor_hud.c:	print_text(new_point(10, 390), new_printable_text("Wall ", env->sdl.fonts.alice30, 0xFFFFFFFF, 30), env);
editor_hud.c:	print_text(new_point(10, 480), new_printable_text(ft_sitoa(env->editor.selected_wall), env->sdl.fonts.alice30, 0xFFFFFFFF, 30), env);
editor_hud.c:	print_text(new_point(220, 280), new_printable_text("Texture:", env->sdl.fonts.alice30, 0xFFFFFFFF, 30), env);
editor_hud.c:	print_text(new_point(220, 470), new_printable_text(ft_sitoa(env->sectors[env->editor.selected_sector].textures[env->editor.selected_wall]), env->sdl.fonts.alice30, 0xFFFFFFFF, 30), env);
editor_hud.c:				env->sdl.fonts.alice30, 0xFFFFFFFF, 30), env);
editor_hud.c:	print_text(new_point(10, 480), new_printable_text(ft_sitoa(env->selected_ceiling),
editor_hud.c:				env->sdl.fonts.alice30, 0xFFFFFFFF, 30), env);
editor_hud.c:	print_text(new_point(90, 240), new_printable_text("Ceiling: ", env->sdl.fonts.alice30, 0xFFFFFFFF, 30), env);
editor_hud.c:	print_text(new_point(90, 470), new_printable_text(ft_sitoa(env->sectors[env->selected_ceiling].ceiling), env->sdl.fonts.alice30, 0xFFFFFFFF, 30), env);
editor_hud.c:	print_text(new_point(130, 240), new_printable_text("Ceiling slope: ", env->sdl.fonts.alice30, 0xFFFFFFFF, 30), env);
editor_hud.c:	print_text(new_point(130, 470), new_printable_text(ft_sitoa(env->sectors[env->selected_ceiling].ceiling_slope), env->sdl.fonts.alice30, 0xFFFFFFFF, 30), env);
editor_hud.c:	print_text(new_point(170, 240), new_printable_text("Texture: ", env->sdl.fonts.alice30, 0xFFFFFFFF, 30), env);
editor_hud.c:	print_text(new_point(170, 470), new_printable_text(ft_sitoa(env->sectors[env->selected_ceiling].ceiling_texture), env->sdl.fonts.alice30, 0xFFFFFFFF, 30), env);
editor_hud.c:				env->sdl.fonts.alice30, 0xFFFFFFFF, 30), env);
editor_hud.c:	print_text(new_point(10, 480), new_printable_text(ft_sitoa(env->selected_floor),
editor_hud.c:				env->sdl.fonts.alice30, 0xFFFFFFFF, 30), env);
editor_hud.c:	print_text(new_point(90, 240), new_printable_text("floor: ", env->sdl.fonts.alice30, 0xFFFFFFFF, 30), env);
editor_hud.c:	print_text(new_point(90, 470), new_printable_text(ft_sitoa(env->sectors[env->selected_floor].floor), env->sdl.fonts.alice30, 0xFFFFFFFF, 30), env);
editor_hud.c:	print_text(new_point(130, 240), new_printable_text("floor slope: ", env->sdl.fonts.alice30, 0xFFFFFFFF, 30), env);
editor_hud.c:	print_text(new_point(130, 470), new_printable_text(ft_sitoa(env->sectors[env->selected_floor].floor_slope), env->sdl.fonts.alice30, 0xFFFFFFFF, 30), env);
editor_hud.c:	print_text(new_point(170, 240), new_printable_text("Texture: ", env->sdl.fonts.alice30, 0xFFFFFFFF, 30), env);
editor_hud.c:	print_text(new_point(170, 470), new_printable_text(ft_sitoa(env->sectors[env->selected_floor].floor_texture), env->sdl.fonts.alice30, 0xFFFFFFFF, 30), env);
editor_hud.c:				env->sdl.fonts.alice30, 0xFFFFFFFF, 30), env);
editor_hud.c:	print_text(new_point(10, 480), new_printable_text(ft_sitoa(env->selected_enemy),
editor_hud.c:				env->sdl.fonts.alice30, 0xFFFFFFFF, 30), env);
editor_hud.c:	print_text(new_point(90, 280), new_printable_text("health: ", env->sdl.fonts.alice30, 0xFFFFFFFF, 30), env);
editor_hud.c:	print_text(new_point(90, 430), new_printable_text(ft_sitoa(env->enemies[env->selected_enemy].health), env->sdl.fonts.alice30, 0xFFFFFFFF, 30), env);
editor_hud.c:	print_text(new_point(130, 280), new_printable_text("speed: ", env->sdl.fonts.alice30, 0xFFFFFFFF, 30), env);
editor_hud.c:	print_text(new_point(130, 430), new_printable_text(ft_sitoa(env->enemies[env->selected_enemy].speed), env->sdl.fonts.alice30, 0xFFFFFFFF, 30), env);
editor_hud.c:	print_text(new_point(170, 280), new_printable_text("damages: ", env->sdl.fonts.alice30, 0xFFFFFFFF, 30), env);
editor_hud.c:	print_text(new_point(170, 430), new_printable_text(ft_sitoa(env->enemies[env->selected_enemy].damage), env->sdl.fonts.alice30, 0xFFFFFFFF, 30), env);
editor_hud.c:	print_text(new_point(210, 280), new_printable_text("sprite: ", env->sdl.fonts.alice30, 0xFFFFFFFF, 30), env);
editor_hud.c:	print_text(new_point(210, 430), new_printable_text(ft_sitoa(env->enemies[env->selected_enemy].sprite), env->sdl.fonts.alice30, 0xFFFFFFFF, 30), env);
editor_hud.c:	if (env->editor.in_game)
editor_hud.c:	if (!env->editor.in_game)
editor_hud.c:		print_text(new_point(50, 60), new_printable_text("Player", env->sdl.fonts.alice30, 0xFFFFFFFF, 30), env);
editor_hud.c:		print_text(new_point(150, 60), new_printable_text("Object", env->sdl.fonts.alice30, 0xFFFFFFFF, 30), env);
editor_hud.c:		print_text(new_point(250, 60), new_printable_text("enemy", env->sdl.fonts.alice30, 0xFFFFFFFF, 30), env);
editor_hud.c:	if (env->editor.tab)
editor_hud.c:		print_text(new_point(10, 240), new_printable_text("Selected: ", env->sdl.fonts.alice30, 0xFFFFFFFF, 30), env);
editor_hud.c:		if (env->editor.selected_vertex != -1)
editor_hud.c:		else if (env->editor.selected_player != -1)
editor_hud.c:		else if (env->editor.selected_object != -1 || env->selected_object != -1)
editor_hud.c:		else if (env->editor.selected_sector != -1 && !env->editor.in_game)
editor_hud.c:		else if (env->editor.selected_wall != -1)
editor_hud.c:		else if (env->selected_ceiling != -1)
editor_hud.c:		else if (env->selected_floor != -1)
editor_hud.c:		else if (env->selected_enemy != -1)
editor_hud.c:			print_text(new_point(10, 430), new_printable_text("none", env->sdl.fonts.alice30, 0xFFFFFFFF, 30), env);
editor_keys.c:	if (env->inputs.space
editor_keys.c:			&& env->editor.dragged_player == -1
editor_keys.c:			&& env->editor.dragged_object == -1
editor_keys.c:			&& env->editor.dragged_vertex == -1)
editor_keys.c:			add_vertex_to_current_sector(env, env->nb_vertices - 1);
editor_keys.c:			if (env->editor.start_vertex == -1) //Nouveau secteur
editor_keys.c:				env->editor.start_vertex = env->nb_vertices - 1;
editor_keys.c:			if (env->editor.start_vertex == -1)
editor_keys.c:				env->editor.start_vertex = clicked_vertex;
editor_keys.c:				if (clicked_vertex == ((t_vertex*)env->editor.current_vertices->content)->num
editor_keys.c:						&& ft_lstlen(env->editor.current_vertices) > 2
editor_keys.c:					env->editor.reverted = get_clockwise_order(env) ? 0 : 1;
editor_keys.c:					env->editor.start_vertex = -1;
editor_keys.c:					update_sector_slope(env, &env->sectors[env->nb_sectors - 1]);
editor_keys.c:		env->inputs.space = 0;
editor_keys.c:	if (env->inputs.backspace && !env->confirmation_box.state)
editor_keys.c:		env->inputs.backspace = 0;
editor_keys.c:	if (env->inputs.del)
editor_keys.c:	if (env->confirmation_box.state)
editor_keys.c:		confirmation_box_keys(&env->confirmation_box, env);
editor_keys.c:	if (env->sdl.mx > 200 && env->inputs.left_click
editor_keys.c:			&& !env->confirmation_box.state
editor_keys.c:			&& env->editor.start_vertex == -1
editor_keys.c:			&& env->editor.dragged_player == -1
editor_keys.c:			&& env->editor.dragged_object == -1
editor_keys.c:			&& env->editor.dragged_vertex == -1
editor_keys.c:			&& env->editor.dragged_enemy == -1
editor_keys.c:			&& !env->teleport.create)
editor_keys.c:		env->editor.selected_sector = get_sector_no_z(env,
editor_keys.c:				new_v3((env->sdl.mx - env->editor.center.x) / env->editor.scale,
editor_keys.c:					(env->sdl.my - env->editor.center.y) / env->editor.scale,
editor_keys.c:		env->editor.selected_vertex = -1;
editor_keys.c:		env->editor.selected_object = -1;
editor_keys.c:		env->editor.selected_player = -1;
editor_keys.c:		env->selected_enemy = -1;
editor_keys.c:	if (env->inputs.right_click)
editor_keys.c:		env->editor.center.x += env->sdl.mouse_x;
editor_keys.c:		env->editor.center.y += env->sdl.mouse_y;
editor_keys.c:	if (env->inputs.enter && !env->confirmation_box.state)
editor_keys.c:			env->editor.selected_vertex = -1;
editor_keys.c:			env->editor.selected_sector = -1;
editor_keys.c:			env->editor.selected_player = -1;
editor_keys.c:			env->editor.selected_object = -1;
editor_keys.c:			env->selected_enemy = -1;
editor_keys.c:			env->editor.in_game = 1;
editor_keys.c:			env->inputs.enter = 0;
editor_keys.c:			env->screen_sectors_size = ft_min(env->nb_sectors, env->w);
editor_keys.c:			free_camera(&env->player.camera);
editor_keys.c:			if (init_camera_arrays(&env->player.camera, env))
editor_keys.c:			if (env->sector_list)
editor_keys.c:				ft_memdel((void**)&env->sector_list);
editor_keys.c:			if (!(env->sector_list = (int*)malloc(sizeof(int) * env->nb_sectors)))
editor_keys.c:			update_camera_position(&env->player.camera);
editor_keys.c:			ft_bzero(&env->inputs, sizeof(env->inputs));
editor_keys.c:			SDL_GetRelativeMouseState(&env->sdl.mouse_x, &env->sdl.mouse_y);
editor_keys.c:		env->inputs.enter = 0;
editor_keys.c:	if (env->inputs.left && !env->editor.tab && !env->inputs.ctrl)
editor_keys.c:		env->editor.center.x -= 3;
editor_keys.c:	if (env->inputs.right && !env->editor.tab && !env->inputs.ctrl)
editor_keys.c:		env->editor.center.x += 3;
editor_keys.c:	if (env->inputs.forward && !env->editor.tab && !env->inputs.ctrl)
editor_keys.c:		env->editor.center.y -= 3;
editor_keys.c:	if (env->inputs.backward && !env->editor.tab && !env->inputs.ctrl)
editor_keys.c:		env->editor.center.y += 3;
editor_keys.c:	if (env->inputs.s && env->inputs.ctrl && !valid_map(env) && !env->editor.in_game)
editor_keys.c:		env->inputs.s = 0;
editor_keys.c:		env->inputs.ctrl = 0;
editor_keys.c:	if (env->editor.tab && env->editor.selected_sector != -1 && !env->editor.in_game)
editor_keys.c:		if (!env->time.tick2)
editor_keys.c:			env->time.tick2 = SDL_GetTicks();
editor_keys.c:		if (env->inputs.backward && env->selected_stat < 2 && time - env->time.tick2 > 300)
editor_keys.c:			env->time.tick2 = time;
editor_keys.c:			env->selected_stat++;
editor_keys.c:		else if (env->inputs.forward && env->selected_stat > 0 && time - env->time.tick2 > 300)
editor_keys.c:			env->time.tick2 = time;
editor_keys.c:			env->selected_stat--;
editor_keys.c:	if ((env->inputs.plus || env->inputs.minus) && !env->editor.in_game && env->editor.selected_sector != -1)
editor_keys.c:		if (!env->time.tick4)
editor_keys.c:			env->time.tick4 = SDL_GetTicks();
editor_keys.c:		if (env->inputs.plus && env->sectors[env->editor.selected_sector].status < 3
editor_keys.c:		&& time - env->time.tick4 > 300)
editor_keys.c:			env->sectors[env->editor.selected_sector].status++;
editor_keys.c:			env->time.tick4 = time;
editor_keys.c:		if (env->inputs.minus && env->sectors[env->editor.selected_sector].status > 0
editor_keys.c:		&& time - env->time.tick4 > 300)
editor_keys.c:			env->sectors[env->editor.selected_sector].status--;
editor_keys.c:			env->time.tick4 = time;
editor_keys.c:		if (env->sectors[env->editor.selected_sector].status == 3)
editor_keys.c:			env->teleport.create = 1;
editor_keys.c:	if (env->inputs.left_click && env->teleport.create)
editor_keys.c:		env->teleport.tmp_pos.x = (env->sdl.mx - env->editor.center.x) / env->editor.scale;
editor_keys.c:		env->teleport.tmp_pos.y = (env->sdl.my - env->editor.center.y) / env->editor.scale;
editor_keyup.c:	if (env->sdl.event.key.keysym.sym == SDLK_c)
editor_keyup.c:		env->options.contouring = env->options.contouring ? 0 : 1;
editor_keyup.c:	if (env->sdl.event.key.keysym.sym == SDLK_r)
editor_keyup.c:	if (env->sdl.event.key.keysym.sym == SDLK_l)
editor_keyup.c:		env->options.lighting = env->options.lighting ? 0 : 1;
editor_keyup.c:	if (env->sdl.event.key.keysym.sym == SDLK_m)
editor_keyup.c:		env->options.show_minimap = env->options.show_minimap ? 0 : 1;
editor_keyup.c:	if (env->sdl.event.key.keysym.sym == SDLK_f)
editor_keyup.c:		env->options.show_fps = env->options.show_fps ? 0 : 1;
editor_keyup.c:	if (env->sdl.event.key.keysym.sym == SDLK_x)
editor_keyup.c:		env->options.wall_lover = env->options.wall_lover ? 0 : 1;
editor_keyup.c:	if (env->sdl.event.key.keysym.sym == SDLK_j)
editor_keyup.c:		env->options.color_clipping = env->options.color_clipping ? 0 : 1;
editor_keyup.c:	if (env->sdl.event.key.keysym.sym == SDLK_g)
editor_keyup.c:		env->options.wall_color = env->options.wall_color ? 0 : 1;
editor_keyup.c:	if (env->sdl.event.key.keysym.sym == SDLK_t)
editor_keyup.c:		env->options.test = env->options.test ? 0 : 1;
editor_keyup.c:	if (env->sdl.event.key.keysym.sym == SDLK_i)
editor_keyup.c:		env->options.clipping = env->options.clipping ? 0 : 1;
editor_keyup.c:	if (env->sdl.event.key.keysym.sym == SDLK_n)
editor_keyup.c:		env->drawing = env->drawing ? 0 : 1;
editor_keyup.c:	if (env->sdl.event.key.keysym.sym == SDLK_TAB)
editor_keyup.c:		env->editor.tab = env->editor.tab ? 0 : 1;
editor_keyup.c:	if (env->editor.in_game && env->sdl.event.key.keysym.sym == SDLK_z)
editor_keyup.c:		env->options.zbuffer = env->options.zbuffer ? 0 : 1;
editor_keyup.c:	if (env->confirmation_box.state)
editor_keyup.c:		confirmation_box_keyup(&env->confirmation_box, env);
editor_keyup.c:	if (env->editor.in_game && env->sdl.event.button.button == SDL_BUTTON_LEFT)
editor_keyup.c:		env->editor.select = 1;
editor_render.c:	if (env->inputs.enter)
editor_render.c:		env->editor.in_game = 0;
editor_render.c:		env->selected_floor = -1;
editor_render.c:		env->selected_ceiling = -1;
editor_render.c:		env->selected_object = -1;
editor_render.c:		env->selected_enemy = -1;
editor_render.c:		env->selected_wall1 = -1;
editor_render.c:		env->selected_wall2 = -1;
editor_render.c:		env->inputs.enter = 0;
editor_render.c:	if (draw_walls(&env->player.camera, env))
editor_render.c:	draw_objects(env->player.camera, env);
editor_render.c:	draw_enemies(env->player.camera, env);
editor_render.c:	if (env->options.show_fps)
editor_render.c:	env->editor.select = 0;
elevator.c:   get_nb_floors(env, &env->sectors[env->player.sector]);
elevator.c:	if (!env->elevator.on)
elevator.c:				if ((env->sectors[sector.neighbors[i]].status == 2
elevator.c:				|| env->sectors[sector.neighbors[i]].status == 1 )
elevator.c:				&& env->sectors[sector.neighbors[i]].floor != sector.floor)
elevator.c:					env->elevator.next_stop = env->sectors[sector.neighbors[i]].floor;
elevator.c:		if (env->elevator.next_stop > sector.floor)
elevator.c:			env->elevator.down = 0;
elevator.c:			env->elevator.up = 1;
elevator.c:		if (env->elevator.next_stop < sector.floor)
elevator.c:			env->elevator.up = 0;
elevator.c:			env->elevator.down = 1;	
elevator.c:	if (env->sectors[elevator].floor > sector.floor)
elevator.c:		env->elevator.down = 1;
elevator.c:		env->elevator.up = 0;
elevator.c:	if (env->sectors[elevator].floor < sector.floor)
elevator.c:		env->elevator.up = 1;
elevator.c:		env->elevator.down = 0;	
elevator.c:	if (env->elevator.called_from == -1)
elevator.c:		env->elevator.called_from = env->player.sector;
elevator.c:	sector = env->sectors[env->elevator.called_from];
elevator.c:	if (env->elevator.sector == -1)
elevator.c:			if (sector.neighbors[i] != -1 && env->sectors[sector.neighbors[i]].status == 1)
elevator.c:				env->elevator.sector = sector.neighbors[i];
elevator.c:	if ((env->sectors[env->elevator.sector].floor
elevator.c:	!= env->sectors[env->elevator.called_from].floor) || env->elevator.call)
elevator.c:		env->elevator.call = 1;
elevator.c:		find_call(env, sector, env->elevator.sector);
elevator.c:		env->elevator.on = 1;
elevator.c:		if (!env->elevator.time)
elevator.c:			env->elevator.start_floor = env->sectors[env->elevator.sector].floor;
elevator.c:			env->elevator.time = SDL_GetTicks();
elevator.c:		env->time.d_time = time - env->elevator.time;
elevator.c:		if (env->elevator.down)
elevator.c:			new_floor = env->elevator.start_floor - (env->elevator.speed * env->time.d_time);
elevator.c:			env->sectors[env->elevator.sector].floor = new_floor;
elevator.c:			env->sectors[env->elevator.sector].ceiling
elevator.c:				= env->sectors[env->elevator.sector].floor + 10;
elevator.c:		else if (env->elevator.up)
elevator.c:			new_floor = env->elevator.start_floor + (env->elevator.speed * env->time.d_time);
elevator.c:			env->sectors[env->elevator.sector].floor = new_floor;
elevator.c:			env->sectors[env->elevator.sector].ceiling
elevator.c:				= env->sectors[env->elevator.sector].floor + 10;
elevator.c:		update_sector_slope(env, &env->sectors[env->elevator.sector]);
elevator.c:		if ((env->sectors[env->elevator.sector].floor > env->sectors[env->elevator.called_from].floor && env->elevator.up)
elevator.c:				|| (env->sectors[env->elevator.sector].floor < env->sectors[env->elevator.called_from].floor && env->elevator.down))
elevator.c:			env->sectors[env->elevator.sector].floor = env->sectors[env->elevator.called_from].floor;
elevator.c:			env->sectors[env->elevator.sector].ceiling
elevator.c:				= env->sectors[env->elevator.sector].floor + 10;
elevator.c:			update_sector_slope(env, &env->sectors[env->elevator.sector]);
elevator.c:			env->elevator.next_stop = 0;
elevator.c:			env->elevator.on = 0;
elevator.c:			env->elevator.up = 0;
elevator.c:			env->elevator.down = 0;
elevator.c:			env->elevator.off = 1;
elevator.c:			env->elevator.sector = -1;
elevator.c:			env->elevator.call = 0;
elevator.c:			env->elevator.called_from = -1;
elevator.c:			env->elevator.time = 0;
elevator.c:		env->elevator.called_from = -1;
elevator.c:		env->elevator.sector = -1;
elevator.c:	sector = env->sectors[env->player.sector];
elevator.c:	if ((sector.status == 1 && !env->elevator.call) || env->elevator.used)
elevator.c:		env->elevator.on = 1;
elevator.c:		env->elevator.used = 1;
elevator.c:		if (env->elevator.used)
elevator.c:		if (env->elevator.sector == -1)
elevator.c:			env->elevator.sector = env->player.sector;
elevator.c:		if (!env->elevator.time)
elevator.c:			env->elevator.start_floor = env->sectors[env->elevator.sector].floor;
elevator.c:			env->elevator.time = SDL_GetTicks();
elevator.c:;		env->time.d_time = time - env->elevator.time;
elevator.c:		if (env->elevator.down)
elevator.c:			new_floor = env->elevator.start_floor - (env->elevator.speed * env->time.d_time);
elevator.c:			env->sectors[env->elevator.sector].floor = new_floor;
elevator.c:			env->sectors[env->elevator.sector].ceiling
elevator.c:				= env->sectors[env->player.sector].floor + 10;
elevator.c:		else if (env->elevator.up)
elevator.c:			new_floor = env->elevator.start_floor + (env->elevator.speed * env->time.d_time);
elevator.c:			env->sectors[env->elevator.sector].floor = new_floor;
elevator.c:			env->sectors[env->elevator.sector].ceiling
elevator.c:				= env->sectors[env->elevator.sector].floor + 10;
elevator.c:		update_sector_slope(env, &env->sectors[env->elevator.sector]);
elevator.c:		if ((env->sectors[env->elevator.sector].floor > env->elevator.next_stop && env->elevator.up)
elevator.c:				|| (env->sectors[env->elevator.sector].floor < env->elevator.next_stop && env->elevator.down))
elevator.c:			env->sectors[env->elevator.sector].floor = env->elevator.next_stop;
elevator.c:			env->sectors[env->elevator.sector].ceiling
elevator.c:				= env->sectors[env->elevator.sector].floor + 10;
elevator.c:			update_sector_slope(env, &env->sectors[env->elevator.sector]);
elevator.c:			env->elevator.next_stop = 0;
elevator.c:			env->elevator.on = 0;
elevator.c:			env->elevator.up = 0;
elevator.c:			env->elevator.down = 0;
elevator.c:			env->elevator.off = 1;
elevator.c:			env->elevator.sector = -1;
elevator.c:			env->elevator.used  = 0;
elevator.c:			env->time.d_time = 0;
elevator.c:			env->elevator.time = 0;
elevator.c:			env->elevator.start_floor = 0;
elevator.c:	else if (!env->elevator.used)
enemy_selection.c:	if (env->inputs.left_click
enemy_selection.c:			&& env->sdl.mx > 80
enemy_selection.c:			&& env->sdl.mx < 120
enemy_selection.c:			&& env->sdl.my > 280
enemy_selection.c:			&& env->sdl.my < 320
enemy_selection.c:			&& env->editor.start_vertex == -1
enemy_selection.c:			&& env->editor.dragged_player == -1
enemy_selection.c:			&& env->editor.dragged_vertex == -1
enemy_selection.c:			&& env->editor.dragged_object == -1
enemy_selection.c:			&& env->editor.dragged_enemy == -1
enemy_selection.c:			&& !env->teleport.create)
enemy_selection.c:		env->editor.dragged_enemy = env->nb_enemies;
enemy_selection.c:	if (!env->inputs.left_click && env->editor.dragged_enemy != -1)
enemy_selection.c:		if (env->sdl.mx > 200)
enemy_selection.c:			if (env->editor.dragged_enemy == env->nb_enemies)
enemy_selection.c:				env->nb_enemies++;
enemy_selection.c:				env->enemies[env->editor.dragged_enemy].pos.x =	(env->sdl.mx - env->editor.center.x) / env->editor.scale;
enemy_selection.c:				env->enemies[env->editor.dragged_enemy].pos.y =	(env->sdl.my - env->editor.center.y) / env->editor.scale;
enemy_selection.c:			delete_enemy(env, env->editor.dragged_enemy);
enemy_selection.c:		env->editor.dragged_enemy = -1;
enemy_utils.c:	while (i < env->sectors[sector].nb_vertices)
enemy_utils.c:		wall.p1.x = env->vertices[env->sectors[sector].vertices[i]].x;
enemy_utils.c:		wall.p1.y = env->vertices[env->sectors[sector].vertices[i]].y;
enemy_utils.c:		wall.p2.x = env->vertices[env->sectors[sector].vertices[i + 1]].x;
enemy_utils.c:		wall.p2.y = env->vertices[env->sectors[sector].vertices[i + 1]].y;
enemy_utils.c:			if (env->sectors[sector].neighbors[i] < 0)
enemy_utils.c:	while (i < env->sectors[sector].nb_vertices)
enemy_utils.c:		if (sector == env->player.sector)
enemy_utils.c:		if (env->sectors[sector].neighbors[i] >= 0 && env->sector_list[env->sectors[sector].neighbors[i]] == 0)
enemy_utils.c:			if (env->player.sector == env->sectors[sector].neighbors[i])
enemy_utils.c:			env->sector_list[env->sectors[sector].neighbors[i]] = 1;
enemy_utils.c:			sector_check = check_segment_in_sector(env, enemy, player, env->sectors[sector].neighbors[i]);
enemy_utils.c:				sector = env->sectors[sector].neighbors[i];
enemy_utils.c:	angle_left = env->enemies[nb].angle + 65;
enemy_utils.c:	angle_right = env->enemies[nb].angle - 65;
enemy_utils.c:	env->enemies[nb].far_left.x = 1000 * cos(angle_left * CONVERT_RADIANS) + env->enemies[nb].pos.x;
enemy_utils.c:	env->enemies[nb].far_left.y = 1000 * sin(angle_left * CONVERT_RADIANS) + env->enemies[nb].pos.y;
enemy_utils.c:	env->enemies[nb].far_right.x = 1000 * cos(angle_right * CONVERT_RADIANS) + env->enemies[nb].pos.x;
enemy_utils.c:	env->enemies[nb].far_right.y = 1000 * sin(angle_right * CONVERT_RADIANS) + env->enemies[nb].pos.y;
enemy_utils.c:	angle_left = env->enemies[nb].angle + 90;
enemy_utils.c:	angle_right = env->enemies[nb].angle - 90;
enemy_utils.c:	radius = env->enemies[nb].size_2d / 2;
enemy_utils.c:	env->enemies[nb].left_arm.x = radius * cos(angle_left * CONVERT_RADIANS) + env->enemies[nb].pos.x;
enemy_utils.c:	env->enemies[nb].left_arm.y = radius * sin(angle_left * CONVERT_RADIANS) + env->enemies[nb].pos.y;
enemy_utils.c:	env->enemies[nb].right_arm.x = radius * cos(angle_right * CONVERT_RADIANS) + env->enemies[nb].pos.x;
enemy_utils.c:	env->enemies[nb].right_arm.y = radius * sin(angle_right * CONVERT_RADIANS) + env->enemies[nb].pos.y;
enemy_utils.c:	distance = distance_two_points(env->enemies[i].pos.x, env->enemies[i].pos.y, env->player.pos.x, env->player.pos.y);
enemy_utils.c:	env->enemies[i].saw_player = is_in_enemy_fov(env->enemies[i], env->player, distance);
enemy_utils.c:		env->enemies[i].saw_player = 1;
enemy_utils.c:	if (env->enemies[i].saw_player)
enemy_utils.c:		env->enemies[i].saw_player = enemy_line_of_sight(env, new_v2(env->enemies[i].pos.x, env->enemies[i].pos.y), new_v2(env->player.pos.x, env->player.pos.y), env->enemies[i].sector);
enemy_utils.c:	if (env->enemies[i].hit && !shot_flag)
enemy_utils.c:		env->enemies[i].saw_player = 1; //oblig de mettre a apres pour eviter de pouvoir tirer sur un ennemi en restant a moiti cach
enemy_utils.c:			env->enemies[i].state = PURSUING;
enemy_utils.c:				env->enemies[i].dir = rand_dir(env, i);
enemy_utils.c:				if (env->enemies[i].dir == 0)
enemy_utils.c:				else if (env->enemies[i].dir == 1)
enemy_utils.c:			env->enemies[i].pos.x += move.x;
enemy_utils.c:			env->enemies[i].pos.y += move.y;
enemy_utils.c:			if (env->enemies[i].type == AERIAL)
enemy_utils.c:				env->enemies[i].pos.z += direction.z;
enemy_utils.c:			env->enemies[i].sector = get_sector_no_z_origin(env, env->enemies[i].pos, env->enemies[i].sector);
enemy_utils.c:			env->enemies[i].angle = atan2(enemy.last_player_pos.y - env->enemies[i].pos.y, enemy.last_player_pos.x - env->enemies[i].pos.x) * CONVERT_DEGREES;
enemy_utils.c:		env->enemies[i].state = PURSUING;
enemy_utils.c:			env->enemies[i].dir = rand_dir(env, i);
enemy_utils.c:			if (env->enemies[i].dir == 0)
enemy_utils.c:			else if (env->enemies[i].dir == 1)
enemy_utils.c:		env->enemies[i].pos.x += move.x;
enemy_utils.c:		env->enemies[i].pos.y += move.y;
enemy_utils.c:		env->enemies[i].sector = get_sector_no_z_origin(env, env->enemies[i].pos, env->enemies[i].sector);
enemy_utils.c:		if (env->enemies[i].type == AERIAL)
enemy_utils.c:			env->enemies[i].pos.z += direction.z;
enemy_utils.c:	if (env->enemies[i].saw_player)
enemy_utils.c:		env->enemies[i].angle = atan2(enemy.last_player_pos.y - env->enemies[i].pos.y, enemy.last_player_pos.x - env->enemies[i].pos.x) * CONVERT_DEGREES;
enemy_utils.c:	env->enemies[i].saw_player = 0;
enemy_utils.c:	if (distance <= 31 && env->enemies[i].saw_player/*
enemy_utils.c:		&& enemy_line_of_sight(env, new_v2(env->enemies[i].left_arm.x, env->enemies[i].left_arm.y), new_v2(env->player.pos.x, env->player.pos.y), env->enemies[i].sector)
enemy_utils.c:		&& enemy_line_of_sight(env, new_v2(env->enemies[i].right_arm.x, env->enemies[i].right_arm.y), new_v2(env->player.pos.x, env->player.pos.y), env->enemies[i].sector)*/)
enemy_utils.c:		env->enemies[i].state = FIRING;
enemy_utils.c:		if (env->enemies[i].shot)
enemy_utils.c:			env->player.health -= env->enemies[i].damage;
enemy_utils.c:			if (env->player.health < 0)
enemy_utils.c:				env->player.health = 0;
enemy_utils.c:			env->player.hit = 1;
enemy_utils.c:		env->enemies[i].shot = 0;
enemy_utils.c:	while (i < env->nb_enemies)
enemy_utils.c:		env->enemies[i].state = RESTING;
enemy_utils.c:		if (env->enemies[i].exists && env->enemies[i].health > 0 && env->enemies[i].saw_player)
enemy_utils.c:			env->enemies[i].last_player_pos.x = env->player.pos.x;
enemy_utils.c:			env->enemies[i].last_player_pos.y = env->player.pos.y;
enemy_utils.c:			env->enemies[i].last_player_pos.z = env->player.head_z;
enemy_utils.c:		if (env->enemies[i].behavior == MELEE)
enemy_utils.c:			melee_ai(env, env->enemies[i], distance, i);
enemy_utils.c:		else if (env->enemies[i].behavior == RANGED)
enemy_utils.c:			ranged_ai(env, env->enemies[i], distance, i);
enemy_utils.c:	while (i < env->nb_enemies)
enemy_utils.c:		if (env->enemies[i].health > 0 && distance_two_points(env->enemies[i].pos.x, env->enemies[i].pos.y, PLAYER_XPOS, PLAYER_YPOS) < 1.75 && env->enemies[i].exists
enemy_utils.c:			&& env->enemies[i].pos.z >= PLAYER_ZPOS - 1 && env->enemies[i].pos.z <= env->player.eyesight + env->player.pos.z + 1 && env->enemies[i].behavior == MELEE)
enemy_utils.c:			env->player.hit = 1;
enemy_utils.c:			env->player.health -= env->enemies[i].damage;
enemy_utils.c:			if (env->player.health < 0)
enemy_utils.c:				env->player.health = 0;
enemy_utils.c:			env->enemies[i].exists = 0;
fill_new_sector.c:		if (env->editor.reverted)
fill_new_sector.c:	tmp = env->editor.current_vertices;
fill_new_sector.c:		if (env->editor.reverted)
fill_new_sector.c:		sector->sprites[index].scale[0] = new_v2(env->textures[sector->textures[index]].surface->w,
fill_new_sector.c:env->textures[sector->textures[index]].surface->h);
fill_new_sector.c:		sector->scale[index] = new_v2(env->textures[sector->textures[index]].surface->w,
fill_new_sector.c:env->textures[sector->textures[index]].surface->h);
fill_new_sector.c:	if (!env->editor.reverted)
fps.c:	fps = 1000 / (new_time - env->sdl.time);
fps.c:	env->fps = ft_sitoa(fps);
fps.c:		if (env->options.p)
fps.c:			if (!env->avrg_fps)
fps.c:				env->avrg_fps = fps;
fps.c:			if (fps > env->max_fps)
fps.c:				env->max_fps = fps;
fps.c:			if (fps < env->min_fps)
fps.c:				env->min_fps = fps;
fps.c:			env->avrg_fps = (env->avrg_fps + fps) / 2;
fps.c:			if (!env->avrg_fps2)
fps.c:				env->avrg_fps2 = fps;
fps.c:			if (fps > env->max_fps2)
fps.c:				env->max_fps2 = fps;
fps.c:			if (fps < env->min_fps2)
fps.c:				env->min_fps2 = fps;
fps.c:			env->avrg_fps2 = (env->avrg_fps2 + fps) / 2;
fps.c:	if (new_time - env->render_swap_time > 1000)
fps.c:	//	env->options.p = env->options.p ? 0 : 1;
fps.c:		env->render_swap_time = new_time;
fps.c:	if (env->options.show_fps)
fps.c:					env->fps,
fps.c:					env->sdl.fonts.amazdoom50,
fps.c:	env->sdl.time = new_time;
free_all.c:		if (env->textures[i].surface)
free_all.c:			SDL_FreeSurface(env->textures[i].surface);
free_all.c:	while (i < env->nb_sectors)
free_all.c:		if (env->sectors[i].vertices)
free_all.c:			ft_memdel((void**)&env->sectors[i].vertices);
free_all.c:		if (env->sectors[i].ceilings)
free_all.c:			ft_memdel((void**)&env->sectors[i].ceilings);
free_all.c:		if (env->sectors[i].floors)
free_all.c:			ft_memdel((void**)&env->sectors[i].floors);
free_all.c:		if (env->sectors[i].clipped_ceilings1)
free_all.c:			ft_memdel((void**)&env->sectors[i].clipped_ceilings1);
free_all.c:		if (env->sectors[i].clipped_floors1)
free_all.c:			ft_memdel((void**)&env->sectors[i].clipped_floors1);
free_all.c:		if (env->sectors[i].clipped_ceilings2)
free_all.c:			ft_memdel((void**)&env->sectors[i].clipped_ceilings2);
free_all.c:		if (env->sectors[i].clipped_floors2)
free_all.c:			ft_memdel((void**)&env->sectors[i].clipped_floors2);
free_all.c:		if (env->sectors[i].wall_width)
free_all.c:			ft_memdel((void**)&env->sectors[i].wall_width);
free_all.c:		if (env->sectors[i].textures)
free_all.c:			ft_memdel((void**)&env->sectors[i].textures);
free_all.c:		if (env->sectors[i].align)
free_all.c:			ft_memdel((void**)&env->sectors[i].align);
free_all.c:		if (env->sectors[i].scale)
free_all.c:			ft_memdel((void**)&env->sectors[i].scale);
free_all.c:		if (env->sectors[i].neighbors)
free_all.c:			ft_memdel((void**)&env->sectors[i].neighbors);
free_all.c:		if (env->sectors[i].sprites)
free_all.c:			ft_memdel((void**)&env->sectors[i].sprites);
free_all.c:		if (env->sectors[i].xmin)
free_all.c:			ft_memdel((void**)&env->sectors[i].xmin);
free_all.c:		if (env->sectors[i].xmax)
free_all.c:			ft_memdel((void**)&env->sectors[i].xmax);
free_all.c:		if (env->sectors[i].nb_sprites)
free_all.c:			ft_memdel((void**)&env->sectors[i].nb_sprites);
free_all.c:	ft_memdel((void**)&env->sectors);
free_all.c:	if (env->sdl.window)
free_all.c:		SDL_DestroyWindow(env->sdl.window);
free_all.c:	if (env->sdl.renderer)
free_all.c:		SDL_DestroyRenderer(env->sdl.renderer);
free_all.c:	if (env->sdl.texture)
free_all.c:		SDL_DestroyTexture(env->sdl.texture);
free_all.c:	if (env->sdl.texture_pixels)
free_all.c:		ft_memdel((void**)&env->sdl.texture_pixels);
free_all.c:	if (env->zbuffer)
free_all.c:		ft_memdel((void**)&env->zbuffer);
free_all.c:	if (env->max_ceiling)
free_all.c:		ft_memdel((void**)&env->max_ceiling);
free_all.c:	if (env->max_floor)
free_all.c:		ft_memdel((void**)&env->max_floor);
free_all.c:	if (env->current_ceiling)
free_all.c:		ft_memdel((void**)&env->current_ceiling);
free_all.c:	if (env->current_floor)
free_all.c:		ft_memdel((void**)&env->current_floor);
free_all.c:	if (env->z)
free_all.c:		ft_memdel((void**)&env->z);
free_all.c:	if (env->z_near_z)
free_all.c:		ft_memdel((void**)&env->z_near_z);
free_all.c:	if (env->alpha)
free_all.c:		ft_memdel((void**)&env->alpha);
free_all.c:	if (env->clipped_alpha)
free_all.c:		ft_memdel((void**)&env->clipped_alpha);
free_all.c:	if (env->line_height)
free_all.c:		ft_memdel((void**)&env->line_height);
free_all.c:	if (env->no_slope_current_ceiling)
free_all.c:		ft_memdel((void**)&env->no_slope_current_ceiling);
free_all.c:	if (env->no_slope_current_floor)
free_all.c:		ft_memdel((void**)&env->no_slope_current_floor);
free_all.c:	if (env->ceiling_start)
free_all.c:		ft_memdel((void**)&env->ceiling_start);
free_all.c:	if (env->floor_start)
free_all.c:		ft_memdel((void**)&env->floor_start);
free_all.c:	if (env->divider)
free_all.c:		ft_memdel((void**)&env->divider);
free_all.c:	if (env->neighbor_max_ceiling)
free_all.c:		ft_memdel((void**)&env->neighbor_max_ceiling);
free_all.c:	if (env->neighbor_max_floor)
free_all.c:		ft_memdel((void**)&env->neighbor_max_floor);
free_all.c:	if (env->neighbor_current_ceiling)
free_all.c:		ft_memdel((void**)&env->neighbor_current_ceiling);
free_all.c:	if (env->neighbor_current_floor)
free_all.c:		ft_memdel((void**)&env->neighbor_current_floor);
free_all.c:	if (env->texel)
free_all.c:		ft_memdel((void**)&env->texel);
free_all.c:	if (env->texel_near_z)
free_all.c:		ft_memdel((void**)&env->texel_near_z);
free_all.c:	if (env->camera_z)
free_all.c:		ft_memdel((void**)&env->camera_z);
free_all.c:	if (env->texel_camera_range)
free_all.c:		ft_memdel((void**)&env->texel_camera_range);
free_all.c:	if (env->zrange)
free_all.c:		ft_memdel((void**)&env->zrange);
free_all.c:	if (env->xmin)
free_all.c:		ft_memdel((void**)&env->xmin);
free_all.c:	if (env->xmax)
free_all.c:		ft_memdel((void**)&env->xmax);
free_all.c:	if (env->ymin)
free_all.c:		ft_memdel((void**)&env->ymin);
free_all.c:	if (env->ymax)
free_all.c:		ft_memdel((void**)&env->ymax);
free_all.c:	if (env->wall_texel)
free_all.c:		ft_memdel((void**)&env->wall_texel);
free_all.c:	if (env->vline_data)
free_all.c:		ft_memdel((void**)&env->vline_data);
free_all.c:	if (env->sdl.fonts.amazdoom70)
free_all.c:		TTF_CloseFont(env->sdl.fonts.amazdoom70);
free_all.c:	if (env->sdl.fonts.amazdoom50)
free_all.c:		TTF_CloseFont(env->sdl.fonts.amazdoom50);
free_all.c:	if (env->sdl.fonts.amazdoom20)
free_all.c:		TTF_CloseFont(env->sdl.fonts.amazdoom20);
free_all.c:	if (env->sdl.fonts.alice30)
free_all.c:		TTF_CloseFont(env->sdl.fonts.alice30);
free_all.c:	if (env->sdl.fonts.alice70)
free_all.c:		TTF_CloseFont(env->sdl.fonts.alice70);
free_all.c:	if (env->sdl.fonts.bebasneue)
free_all.c:		TTF_CloseFont(env->sdl.fonts.bebasneue);
free_all.c:	if (env->confirmation_box.str)
free_all.c:		ft_strdel(&env->confirmation_box.str);
free_all.c:	if (env->sectors)
free_all.c:	if (env->vertices)
free_all.c:		ft_memdel((void**)&env->vertices);
free_all.c:	if (env->objects)
free_all.c:		ft_memdel((void**)&env->objects);
free_all.c:	if (env->sprites)
free_all.c:		ft_memdel((void**)&env->sprites);
free_all.c:	if (env->sound.background)
free_all.c:		Mix_FreeMusic(env->sound.background);
free_all.c:	if (env->sound.footstep)
free_all.c:		Mix_FreeChunk(env->sound.footstep);
free_all.c:	if (env->sound.jump)
free_all.c:		Mix_FreeChunk(env->sound.jump);
free_all.c:	if (env->sector_list)
free_all.c:		ft_memdel((void**)&env->sector_list);
free_all.c:	if (env->res[0])
free_all.c:		ft_strdel(&env->res[0]);
free_all.c:	if (env->res[1])
free_all.c:		ft_strdel(&env->res[1]);
free_all.c:	if (env->res[2])
free_all.c:		ft_strdel(&env->res[2]);
free_all.c:		if (env->weapons[i].empty)
free_all.c:			Mix_FreeChunk(env->weapons[i].empty);
free_all.c:		if (env->weapons[i].sound)
free_all.c:			Mix_FreeChunk(env->weapons[i].sound);
free_all.c:	free_camera(&env->player.camera);
game_menu.c:	print_text(new_point(780, 850), new_printable_text("START", env->sdl.fonts.amazdoom70, 0xFFFFFFFF, 70), env);
get_clockwise_order.c:	vertex2 = env->vertices[0];
get_clockwise_order.c:	while (i < env->sectors[index].nb_vertices - 1)
get_clockwise_order.c:		num = env->sectors[index].vertices[i];
get_clockwise_order.c:		vertex1 = env->vertices[num];
get_clockwise_order.c:		num = env->sectors[index].vertices[i + 1];
get_clockwise_order.c:		vertex2 = env->vertices[num];
get_clockwise_order.c:	num = env->sectors[index].vertices[0];
get_clockwise_order.c:	vertex2 = env->vertices[num];
get_clockwise_order.c:	tmp = env->editor.current_vertices;
get_clockwise_order.c:	vertex2 = (t_vertex*)env->editor.current_vertices->content;
get_existing_vertex.c:	while (i < env->nb_vertices)
get_existing_vertex.c:		vertex = env->vertices[i];
get_existing_vertex.c:		if (round((env->sdl.mx - env->editor.center.x) / env->editor.scale) == vertex.x
get_existing_vertex.c:				&& round((env->sdl.my - env->editor.center.y) / env->editor.scale) == vertex.y
get_existing_vertex.c:				&& vertex.num != env->vertices[env->editor.selected_vertex].num)
get_existing_vertex.c:	while (i < env->nb_vertices)
get_existing_vertex.c:		vertex = env->vertices[i];
get_existing_vertex.c:		if (round((env->sdl.mx - env->editor.center.x) / env->editor.scale) == vertex.x
get_existing_vertex.c:				&& round((env->sdl.my - env->editor.center.y) / env->editor.scale) == vertex.y)
get_screen_sectors.c:	size = env->screen_sectors_size;
get_screen_sectors.c:	camera_range = env->player.camera.near_right - env->player.camera.near_left;
get_screen_sectors.c:	while (x < env->w)
get_screen_sectors.c:		tmp = (x / (double)(env->w - 1)) * camera_range + env->player.camera.near_left;
get_screen_sectors.c:		curr.y = -env->player.camera.near_z;
get_screen_sectors.c:		curr.x = tmp * -env->player.angle_sin - curr.y * env->player.angle_cos + env->player.pos.x;
get_screen_sectors.c:		curr.y = tmp * env->player.angle_cos - curr.y * env->player.angle_sin + env->player.pos.y;
get_screen_sectors.c:		curr.z = env->player.head_z;
get_screen_sectors.c:		sect = get_sector(env, curr, env->player.sector);
get_screen_sectors.c:		env->screen_pos[x] = sect;
get_screen_sectors.c:		while (i < size && env->screen_sectors[i] != -1 && env->screen_sectors[i] != sect)
get_screen_sectors.c:		if (i < size && env->screen_sectors[i] == -1 && sect != -1)
get_screen_sectors.c:			env->screen_sectors[i] = sect;
get_screen_sectors.c:			env->xmin[i] = x;
get_screen_sectors.c:		else if (i < size && env->screen_sectors[i] == sect)
get_screen_sectors.c:			env->xmax[i] = x;
get_screen_sectors.c:		tmp = (x / (double)(env->w - 1)) * camera->range + camera->near_left;
get_screen_sectors.c:		curr.y = -env->player.camera.near_z;
get_screen_sectors.c:		camera->screen_pos[x] = get_sector(env, curr, env->player.sector);
get_screen_sectors.c:	size = env->screen_sectors_size;
get_screen_sectors.c:	while (x < env->w)
get_screen_sectors.c:		pt[i].start = env->w / (double)THREADS * i;
get_screen_sectors.c:		pt[i].end = env->w / (double)THREADS * (i + 1);
get_sector.c:	if (origin < 0 || origin >= env->nb_sectors)
get_sector.c:	while (i < env->sectors[origin].nb_vertices)
get_sector.c:		if (env->sectors[origin].neighbors[i] >= 0)
get_sector.c:			if (is_in_sector(env, env->sectors[origin].neighbors[i], pos))
get_sector.c:				return (env->sectors[origin].neighbors[i]);
get_sector.c:	while (i < env->nb_sectors)
get_sector.c:	while (i < env->nb_sectors)
get_sector.c:	while (i < env->nb_sectors)
get_sector.c:	if (origin < 0 || origin >= env->nb_sectors)
get_sector.c:	while (i < env->sectors[origin].nb_vertices)
get_sector.c:		if (env->sectors[origin].neighbors[i] >= 0)
get_sector.c:			if (is_in_sector_no_z(env, env->sectors[origin].neighbors[i], new_v2(pos.x, pos.y)))
get_sector.c:				return (env->sectors[origin].neighbors[i]);
get_sector.c:	while (i < env->nb_sectors)
get_sector.c:	ft_printf("Player current sector = %d\n", env->player.sector);
get_slope.c:	sector = env->sectors[index];
get_slope.c:	v1 = env->vertices[sector.vertices[0]];
get_slope.c:	v2 = env->vertices[sector.vertices[1]];
get_slope.c:	v0 = env->vertices[sector.vertices[0]];
get_slope.c:	v1 = env->vertices[sector.vertices[1]];
get_slope.c:	vi = env->vertices[sector.vertices[vertex_nb]];
get_slope.c:	v0 = env->vertices[sector.vertices[0]];
get_slope.c:	v0 = env->vertices[sector.vertices[0]];
get_slope.c:	while (i < env->nb_sectors)
get_slope.c:		ft_printf("sector %d normal = [%f,%f]\n", i, env->sectors[i].normal.x, env->sectors[i].normal.y);
get_slope.c:		ft_printf("floor = %f\nceiling = %f\n", env->sectors[i].floor, env->sectors[i].ceiling);
get_slope.c:		ft_printf("floor_slope = %f\nceiling_slope = %f\n", env->sectors[i].floor_slope, env->sectors[i].ceiling_slope);
get_slope.c:		while (j < env->sectors[i].nb_vertices)
get_slope.c:			printf("vertex %d floor = %f ceiling = %f\n", j, env->sectors[i].floors[j], env->sectors[i].ceilings[j]);
get_slope.c:	if (sector->num < 0 || sector->num > env->nb_sectors)
get_slope.c:		v1 = env->vertices[sector->vertices[i]];
get_slope.c:				pow(env->vertices[sector->vertices[i + 1]].x
get_slope.c:					- env->vertices[sector->vertices[i]].x, 2)
get_slope.c:				+ pow(env->vertices[sector->vertices[i + 1]].y
get_slope.c:					- env->vertices[sector->vertices[i]].y, 2));
get_slope.c:	while (i < env->nb_sectors)
get_slope.c:		env->sectors[i].normal = get_sector_normal(env->sectors[i], env);
get_slope.c:		update_sector_slope(env, &env->sectors[i]);
get_vline_data.c:	texture_w = env->textures[render.texture].surface->w;
get_vline_data.c:	texture_h = env->textures[render.texture].surface->h;
get_vline_data.c:		env->vline_data[x].alpha = (x - v1.x) / v1.xrange;
get_vline_data.c:		env->vline_data[x].clipped_alpha = (x - v1.clipped_x1) / v1.clipped_xrange;
get_vline_data.c:		env->vline_data[x].max_ceiling = env->vline_data[x].clipped_alpha * v1.ceiling_range + v1.c1;
get_vline_data.c:		env->vline_data[x].current_ceiling = ft_clamp(env->vline_data[x].max_ceiling,
get_vline_data.c:				env->ymin[x], env->ymax[x]);
get_vline_data.c:		env->vline_data[x].max_floor = env->vline_data[x].clipped_alpha * v1.floor_range + v1.f1;
get_vline_data.c:		env->vline_data[x].current_floor = ft_clamp(env->vline_data[x].max_floor,
get_vline_data.c:				env->ymin[x], env->ymax[x]);
get_vline_data.c:		env->vline_data[x].divider = 1 / (render.camera->v[sector.num][render.i + 1].vz
get_vline_data.c:				+ env->vline_data[x].alpha * v1.zrange);
get_vline_data.c:		env->vline_data[x].z = v1.zcomb * env->vline_data[x].divider;
get_vline_data.c:		env->vline_data[x].z_near_z = env->vline_data[x].z * render.camera->near_z;
get_vline_data.c:		env->vline_data[x].no_slope_current_floor = env->vline_data[x].clipped_alpha
get_vline_data.c:		env->vline_data[x].no_slope_current_ceiling = env->vline_data[x].clipped_alpha
get_vline_data.c:		env->vline_data[x].inv_line_height = 1 / (env->vline_data[x].no_slope_current_floor - env->vline_data[x].no_slope_current_ceiling);
get_vline_data.c:		env->vline_data[x].ceiling_start = env->vline_data[x].max_ceiling - render.ceiling_horizon;
get_vline_data.c:		env->vline_data[x].floor_start = env->vline_data[x].max_floor - render.floor_horizon;
get_vline_data.c:		env->vline_data[x].wall_texel = env->vline_data[x].alpha * render.texture_scale.x
get_vline_data.c:			* env->vline_data[x].z + sector.align[render.i].x;
get_vline_data.c:		env->vline_data[x].falpha_divider = 1 / (render.camera->feet_y[render.sector] - env->vline_data[x].max_floor);
get_vline_data.c:		env->vline_data[x].calpha_divider = 1 / (env->vline_data[x].max_ceiling - render.camera->head_y[render.sector]);
get_vline_data.c:		if (!(env->vline_data[x].wall_texel != env->vline_data[x].wall_texel))
get_vline_data.c:			while (env->vline_data[x].wall_texel >= texture_w)
get_vline_data.c:				env->vline_data[x].wall_texel -= texture_w;
get_vline_data.c:			while (env->vline_data[x].wall_texel < 0)
get_vline_data.c:				env->vline_data[x].wall_texel += texture_w;
get_vline_data.c:		if (env->vline_data[x].current_ceiling > env->ymin[x]
get_vline_data.c:				|| env->vline_data[x].current_floor < env->ymax[x])
get_vline_data.c:			env->vline_data[x].texel.x = (v1.x0z1 + env->vline_data[x].alpha * v1.xzrange)
get_vline_data.c:				* env->vline_data[x].divider;
get_vline_data.c:			env->vline_data[x].texel.y = (v1.y0z1 + env->vline_data[x].alpha * v1.yzrange)
get_vline_data.c:				* env->vline_data[x].divider;
get_vline_data.c:			env->vline_data[x].texel_near_z.x = env->vline_data[x].texel.x * render.camera->near_z;
get_vline_data.c:			env->vline_data[x].texel_near_z.y = env->vline_data[x].texel.y * render.camera->near_z;
get_vline_data.c:			env->vline_data[x].camera_z.x = render.camera->pos.x * env->vline_data[x].z;
get_vline_data.c:			env->vline_data[x].camera_z.y = render.camera->pos.y * env->vline_data[x].z;
get_vline_data.c:			env->vline_data[x].texel_camera_range.x = env->vline_data[x].camera_z.x
get_vline_data.c:				- env->vline_data[x].texel_near_z.x;
get_vline_data.c:			env->vline_data[x].texel_camera_range.y = env->vline_data[x].camera_z.y
get_vline_data.c:				- env->vline_data[x].texel_near_z.y;
get_vline_data.c:			env->vline_data[x].zrange = env->vline_data[x].z - render.camera->near_z;
get_vline_data.c:	texture_w = env->textures[render.texture].surface->w;
get_vline_data.c:	texture_h = env->textures[render.texture].surface->h;
get_vline_data.c:		env->vline_data[x].alpha = (x - v1.x) / v1.xrange;
get_vline_data.c:		env->vline_data[x].clipped_alpha = (x - v1.clipped_x1) / v1.clipped_xrange;
get_vline_data.c:		env->vline_data[x].max_ceiling = env->vline_data[x].clipped_alpha * v1.ceiling_range + v1.c1;
get_vline_data.c:		env->vline_data[x].current_ceiling = ft_clamp(env->vline_data[x].max_ceiling,
get_vline_data.c:				env->ymin[x], env->ymax[x]);
get_vline_data.c:		env->vline_data[x].max_floor = env->vline_data[x].clipped_alpha * v1.floor_range + v1.f1;
get_vline_data.c:		env->vline_data[x].current_floor = ft_clamp(env->vline_data[x].max_floor,
get_vline_data.c:				env->ymin[x], env->ymax[x]);
get_vline_data.c:		env->vline_data[x].divider = 1 / (render.camera->v[sector.num][render.i + 1].vz
get_vline_data.c:				+ env->vline_data[x].alpha * v1.zrange);
get_vline_data.c:		env->vline_data[x].z = v1.zcomb * env->vline_data[x].divider;
get_vline_data.c:		env->vline_data[x].z_near_z = env->vline_data[x].z * render.camera->near_z;
get_vline_data.c:		env->vline_data[x].no_slope_current_floor = env->vline_data[x].clipped_alpha
get_vline_data.c:		env->vline_data[x].no_slope_current_ceiling = env->vline_data[x].clipped_alpha
get_vline_data.c:		env->vline_data[x].inv_line_height = 1 / (env->vline_data[x].no_slope_current_floor - env->vline_data[x].no_slope_current_ceiling);
get_vline_data.c:		env->vline_data[x].ceiling_start = env->vline_data[x].max_ceiling - render.ceiling_horizon;
get_vline_data.c:		env->vline_data[x].floor_start = env->vline_data[x].max_floor - render.floor_horizon;
get_vline_data.c:		env->vline_data[x].wall_texel = env->vline_data[x].alpha * render.texture_scale.x
get_vline_data.c:			* env->vline_data[x].z + sector.align[render.i].x;
get_vline_data.c:		env->vline_data[x].falpha_divider = 1 / (render.camera->feet_y[render.sector] - env->vline_data[x].max_floor);
get_vline_data.c:		env->vline_data[x].calpha_divider = 1 / (env->vline_data[x].max_ceiling - render.camera->head_y[render.sector]);
get_vline_data.c:		if (!(env->vline_data[x].wall_texel != env->vline_data[x].wall_texel))
get_vline_data.c:			while (env->vline_data[x].wall_texel >= texture_w)
get_vline_data.c:				env->vline_data[x].wall_texel -= texture_w;
get_vline_data.c:			while (env->vline_data[x].wall_texel < 0)
get_vline_data.c:				env->vline_data[x].wall_texel += texture_w;
get_vline_data.c:		if (env->vline_data[x].current_ceiling > env->ymin[x]
get_vline_data.c:				|| env->vline_data[x].current_floor < env->ymax[x])
get_vline_data.c:			env->vline_data[x].texel.x = (v1.x0z1 + env->vline_data[x].alpha * v1.xzrange)
get_vline_data.c:				* env->vline_data[x].divider;
get_vline_data.c:			env->vline_data[x].texel.y = (v1.y0z1 + env->vline_data[x].alpha * v1.yzrange)
get_vline_data.c:				* env->vline_data[x].divider;
get_vline_data.c:			env->vline_data[x].texel_near_z.x = env->vline_data[x].texel.x * render.camera->near_z;
get_vline_data.c:			env->vline_data[x].texel_near_z.y = env->vline_data[x].texel.y * render.camera->near_z;
get_vline_data.c:			env->vline_data[x].camera_z.x = render.camera->pos.x * env->vline_data[x].z;
get_vline_data.c:			env->vline_data[x].camera_z.y = render.camera->pos.y * env->vline_data[x].z;
get_vline_data.c:			env->vline_data[x].texel_camera_range.x = env->vline_data[x].camera_z.x
get_vline_data.c:				- env->vline_data[x].texel_near_z.x;
get_vline_data.c:			env->vline_data[x].texel_camera_range.y = env->vline_data[x].camera_z.y
get_vline_data.c:				- env->vline_data[x].texel_near_z.y;
get_vline_data.c:			env->vline_data[x].zrange = env->vline_data[x].z - render.camera->near_z;
gravity.c:	pos.x = env->player.pos.x;
gravity.c:	pos.y = env->player.pos.y;
gravity.c:	slope = get_floor_at_pos(env->sectors[env->player.highest_sect], pos, env);
gravity.c:	if ((!env->player.state.fall
gravity.c:	&& env->player.pos.z > slope + 2)
gravity.c:	|| (env->player.state.jump && !env->player.state.fall))
gravity.c:		env->player.state.walk = 0;
gravity.c:		env->time.last_fall = SDL_GetTicks() / 1000.0;
gravity.c:		env->player.state.fall = 1;
gravity.c:		env->player.start_pos = env->player.pos.z;
gravity.c:		env->player.velocity_start = env->gravity.velocity;
gravity.c:	if (env->player.state.fall)
gravity.c:		env->time.d_time = time - env->time.last_fall;
gravity.c:		env->gravity.acceleration = -9.81 * 3.3;
gravity.c:		new_pos = env->player.start_pos +  (env->gravity.velocity * env->time.d_time)
gravity.c:			+ env->gravity.acceleration * env->time.d_time * env->time.d_time * 0.5;
gravity.c:		new_velocity = env->player.velocity_start + env->gravity.acceleration * env->time.d_time;
gravity.c:		env->player.pos.z = new_pos;
gravity.c:		env->gravity.velocity = new_velocity;
gravity.c:	if (env->player.pos.z < slope && env->player.state.fall && env->time.d_time)
gravity.c:		env->player.pos.z = slope;
gravity.c:		env->gravity.velocity = 0;
gravity.c:		env->gravity.acceleration = 0;
gravity.c:		env->player.state.jump = 0;
gravity.c:		env->time.d_time = 0;
gravity.c:		env->player.state.fall = 0;
gravity.c:	env->player.head_z = env->player.pos.z + env->player.eyesight;
grid_tools.c:	while (x < env->w)
grid_tools.c:		env->sdl.texture_pixels[x + y * env->w] = 0xFF888888;
grid_tools.c:	while (y < env->h)
grid_tools.c:		env->sdl.texture_pixels[x + y * env->w] = 0xFF888888;
grid_tools.c:	i = env->editor.center.y;
grid_tools.c:		i += env->editor.scale;
grid_tools.c:	while (i < env->h)
grid_tools.c:		i += env->editor.scale;
grid_tools.c:	i = env->editor.center.y - env->editor.scale;
grid_tools.c:	while (i >= env->h)
grid_tools.c:		i -= env->editor.scale;
grid_tools.c:		i -= env->editor.scale;
grid_tools.c:	i = env->editor.center.x;
grid_tools.c:		i += env->editor.scale;
grid_tools.c:	while (i < env->w)
grid_tools.c:		i += env->editor.scale;
grid_tools.c:	i = env->editor.center.x - env->editor.scale;
grid_tools.c:	while (i >= env->w)
grid_tools.c:		i -= env->editor.scale;
grid_tools.c:		i -= env->editor.scale;
init_animations.c:	env->time.start = 0;
init_animations.c:	env->time.end = 0;
init_animations.c:	env->jump.start = 0;
init_animations.c:	env->jump.nb_frame = 15;
init_animations.c:	env->jump.end = 300;
init_animations.c:	env->crouch.on_going = 0;
init_animations.c:	env->crouch.start = 0;
init_animations.c:	env->crouch.end = 150;
init_animations.c:	env->crouch.nb_frame = 6;
init_animations.c:	env->crouch.tick = env->crouch.end / env->crouch.nb_frame;
init_animations.c:	env->shot.on_going = 0;
init_animations.c:	env->shot.start = 0;
init_animations.c:	env->player_hurt.start = 0;
init_animations.c:	env->weapon_change.on_going = 0;
init_animations.c:	env->weapon_change.start = 0;
init_animations.c:	env->elevator.next_stop = 0;
init_animations.c:	env->elevator.on = 0;
init_animations.c:	env->elevator.off = 0;
init_animations.c:	env->elevator.sector = -1;
init_animations.c:	env->elevator.called_from = -1;
init_animations.c:	env->elevator.call = 0;
init_animations.c:	env->elevator.used = 0;
init_animations.c:	env->elevator.speed = 0.01;
init_animations.c:	env->elevator.time = 0;
init_animations.c:	while (i < env->nb_enemies)
init_animations.c:		env->enemies[i].death.start = 0;
init_animations.c:		env->enemies[i].rest.start = 0;
init_animations.c:		env->enemies[i].hurt.start = 0;
init_animations.c:		env->enemies[i].pursue.start = 0;
init_animations.c:		env->enemies[i].rand_dir.start = 0;
init_animations.c:		env->enemies[i].fire.start = 0;
init_editor.c:	env->editor.in_game = 0;
init_editor.c:	env->editor.center.x = env->h_w;
init_editor.c:	env->editor.center.y = env->h_h;
init_editor.c:	env->editor.scale = 20;
init_editor.c:	env->editor.current_vertices = NULL;
init_editor.c:	env->editor.start_vertex = -1;
init_editor.c:	env->editor.reverted = 0;
init_editor.c:	env->editor.new_player = 0;
init_editor.c:	env->nb_vertices = 0;
init_editor.c:	env->nb_sectors = 0;
init_editor.c:	env->nb_objects = 0;
init_editor.c:	env->player.sector = -1;
init_editor.c:	env->editor.select = 0;
init_editor.c:	env->editor.start_pos.x = 0;
init_editor.c:	env->editor.start_pos.y = 0;
init_editor.c:	env->editor.selected_sector = -1;
init_editor.c:	env->editor.selected_object = -1;
init_editor.c:	env->editor.selected_vertex = -1;
init_editor.c:	env->editor.selected_player = -1;
init_editor.c:	env->editor.selected_wall = -1;
init_editor.c:	env->editor.selected_wall_sprite = -1;
init_editor.c:	env->editor.dragged_object = -1;
init_editor.c:	env->editor.dragged_vertex = -1;
init_editor.c:	env->editor.dragged_player = -1;
init_editor.c:	env->editor.dragged_enemy = -1;
init_editor.c:	env->editor.tab = 0;
init_editor.c:	env->selected_wall1 = -1;
init_editor.c:	env->selected_wall2 = -1;
init_editor.c:	env->selected_floor = -1;
init_editor.c:	env->selected_ceiling = -1;
init_editor.c:	env->selected_wall_sprite_sprite = -1;
init_editor.c:	env->selected_wall_sprite_wall = -1;
init_editor.c:	env->selected_enemy = -1;
init_editor.c:	env->selected_object = -1;
init_editor.c:	env->selected_stat = 0;
init_editor.c:	env->time.tick = 0;
init_editor.c:	env->time.tick2 = 0;
init_editor.c:	env->time.tick3 = 0;
init_game.c:	while (i < env->nb_enemies)
init_game.c:		env->enemies[i].enemies_init_data.pos = env->enemies[i].pos;
init_game.c:		env->enemies[i].enemies_init_data.health = env->enemies[i].health;
init_game.c:		env->enemies[i].enemies_init_data.sector = env->enemies[i].sector;
init_game.c:		env->enemies[i].enemies_init_data.angle = env->enemies[i].angle;
init_game.c:		env->enemies[i].enemies_init_data.main_sprite = env->enemies[i].main_sprite;
init_game.c:	env->player.player_init_data.pos = env->player.pos;
init_game.c:	env->player.player_init_data.health = env->player.health;
init_game.c:	env->player.player_init_data.sector = env->player.sector;
init_game.c:	env->player.player_init_data.camera = env->player.camera;
init_game.c:	while (i < env->nb_objects)
init_game.c:		env->objects[i].object_init_data.pos = env->objects[i].pos;
init_game.c:		env->objects[i].object_init_data.sector = env->objects[i].sector;
init_game.c:		env->objects[i].object_init_data.angle = env->objects[i].angle;
init_keys.c:	env->keys.forward = SDLK_w;
init_keys.c:	env->keys.s = SDLK_s;
init_keys.c:	env->keys.left = SDLK_a;
init_keys.c:	env->keys.right = SDLK_d;
init_keys.c:	env->keys.forward2 = SDLK_UP;
init_keys.c:	env->keys.backward2 = SDLK_DOWN;
init_keys.c:	env->keys.left2 = SDLK_LEFT;
init_keys.c:	env->keys.right2 = SDLK_RIGHT;
init_keys.c:	env->keys.plus = SDLK_KP_PLUS;
init_keys.c:	env->keys.minus = SDLK_KP_MINUS;
init_keys.c:	env->keys.shift = SDLK_LSHIFT;
init_keys.c:	env->keys.ctrl = SDLK_LCTRL;
init_keys.c:	env->keys.space = SDLK_SPACE;
init_keys.c:	env->keys.up = SDLK_PAGEUP;
init_keys.c:	env->keys.down = SDLK_PAGEDOWN;
init_keys.c:	env->keys.option = SDLK_o;
init_keys.c:	env->keys.enter = SDLK_RETURN;
init_keys.c:	env->keys.backspace = SDLK_BACKSPACE;
init_keys.c:	env->keys.del = SDLK_DELETE;
init_keys.c:	env->keys.tab = SDLK_TAB;
init_keys.c:	env->keys.comma = SDLK_COMMA;
init_keys.c:	env->keys.period = SDLK_PERIOD;
init_keys.c:	env->keys.minus1 = SDLK_MINUS;
init_keys.c:	env->keys.equals = SDLK_EQUALS;
init_keys.c:	env->keys.p = SDLK_p;
init_obj_enemies_data.c:	while (i < env->nb_enemies)
init_obj_enemies_data.c:		env->enemies[i].hit = 0;
init_obj_enemies_data.c:		env->enemies[i].state = 0;
init_obj_enemies_data.c:		env->enemies[i].shot = 0;
init_obj_enemies_data.c:		env->enemies[i].exists = 1;
init_obj_enemies_data.c:		env->enemies[i].saw_player = 0;
init_obj_enemies_data.c:		if (env->enemies[i].sprite == 1 || env->enemies[i].sprite == 3 || 
init_obj_enemies_data.c:			env->enemies[i].sprite == 7 || env->enemies[i].sprite == 8)
init_obj_enemies_data.c:			env->enemies[i].main_sprite = LOST_SOUL;
init_obj_enemies_data.c:			env->enemies[i].type = AERIAL;
init_obj_enemies_data.c:			env->enemies[i].behavior = MELEE;
init_obj_enemies_data.c:			env->enemies[i].size_2d = 0.75;
init_obj_enemies_data.c:			env->enemies[i].eyesight = 1;
init_obj_enemies_data.c:		else if (env->enemies[i].sprite == 2 || env->enemies[i].sprite == 5)
init_obj_enemies_data.c:			env->enemies[i].eyesight = 6;
init_obj_enemies_data.c:			env->enemies[i].main_sprite = CYBER_DEMON;
init_obj_enemies_data.c:			env->enemies[i].firing_sprite = 10;
init_obj_enemies_data.c:			env->enemies[i].type = TERRESTRIAL;
init_obj_enemies_data.c:			env->enemies[i].behavior = RANGED;
init_obj_enemies_data.c:			env->enemies[i].size_2d = 1.5;
init_obj_enemies_data.c:		env->enemies[i].seen = 0;
init_obj_enemies_data.c:		env->enemies[i].dir = 0;
init_obj_enemies_data.c:		env->enemies[i].sector = get_sector_no_z(env, env->enemies[i].pos);
init_obj_enemies_data.c:		env->enemies[i].last_player_pos = env->enemies[i].pos;
init_options.c:	env->options.contouring = 0;
init_options.c:	env->options.render_sectors = 1;
init_options.c:	env->options.lighting = 1;
init_options.c:	env->options.show_minimap = 1;
init_options.c:	env->options.wall_lover = 0;
init_options.c:	env->options.show_fps = 1;
init_options.c:	env->options.color_clipping = 0;
init_options.c:	env->options.wall_color = 1;
init_options.c:	env->options.test = 0;
init_options.c:	env->options.minimap_scale = 10;
init_options.c:	env->options.clipping = 1;
init_options.c:	env->option = 0;
init_options.c:	env->options.show_ennemies = 1;
init_options.c:	env->options.zbuffer = 0;
init_options.c:	env->options.p = 1;
init_pointers.c:	env->sectors = NULL;
init_pointers.c:	env->vertices = NULL;
init_pointers.c:	env->objects = NULL;
init_pointers.c:	env->sprites = NULL;
init_pointers.c:	env->sdl.window = NULL;
init_pointers.c:	env->sdl.renderer = NULL;
init_pointers.c:	env->sdl.texture = NULL;
init_pointers.c:	env->sdl.texture_pixels = NULL;
init_pointers.c:	env->zbuffer = NULL;
init_pointers.c:	env->player.camera.rendered_sectors = NULL;
init_pointers.c:	env->player.camera.screen_sectors = NULL;
init_pointers.c:	env->player.camera.screen_pos = NULL;
init_pointers.c:	env->player.camera.xmin = NULL;
init_pointers.c:	env->player.camera.xmax = NULL;
init_pointers.c:	env->sdl.fonts.amazdoom20 = NULL;
init_pointers.c:	env->sdl.fonts.amazdoom50 = NULL;
init_pointers.c:	env->sdl.fonts.bebasneue = NULL;
init_pointers.c:	env->sdl.fonts.alice30 = NULL;
init_pointers.c:	env->sdl.fonts.alice70 = NULL;
init_pointers.c:	env->sound.background = NULL;
init_pointers.c:	env->sound.footstep = NULL;
init_pointers.c:	env->sound.jump = NULL;
init_pointers.c:	env->sector_list = NULL;
init_pointers.c:	env->res[0] = NULL;
init_pointers.c:	env->res[1] = NULL;
init_pointers.c:	env->res[2] = NULL;
init_pointers.c:		env->textures[i].surface = NULL;
init_pointers.c:		env->textures[i].str = NULL;
init_pointers.c:		env->weapons[i].sound = NULL;
init_pointers.c:		env->weapons[i].empty = NULL;
init_pointers.c:	env->player.health = 100;
init_sdl.c:	/*env->w = 1280;
init_sdl.c:	env->h = 720;*/
init_sdl.c:	if (!(env->sdl.window = SDL_CreateWindow(
init_sdl.c:					env->w,
init_sdl.c:					env->h,
init_sdl.c:	if (!(env->sdl.renderer = SDL_CreateRenderer(
init_sdl.c:					env->sdl.window,
init_sdl.c:	SDL_GetRendererInfo(env->sdl.renderer, &info);
init_sdl.c:	/*if (SDL_SetRenderDrawBlendMode(env->sdl.renderer, SDL_BLENDMODE_NONE))
init_sdl.c:	if (!(env->sdl.texture = SDL_CreateTexture(
init_sdl.c:					env->sdl.renderer,
init_sdl.c:					env->w,
init_sdl.c:					env->h)))
init_sdl.c:	if (!(env->sdl.texture_pixels = (Uint32*)malloc(sizeof(Uint32) * env->w * env->h)))
init_sdl.c:	if (!(env->zbuffer = (double*)malloc(sizeof(double) * env->w * env->h)))
init_sdl.c:	if (!(env->ymin = (int*)malloc(sizeof(int) * env->w)))
init_sdl.c:	if (!(env->ymax = (int*)malloc(sizeof(int) * env->w)))
init_sdl.c:	if (!(env->xmin = (int*)malloc(sizeof(int) * env->h)))
init_sdl.c:	if (!(env->xmax = (int*)malloc(sizeof(int) * env->h)))
init_sdl.c:	if (!(env->current_ceiling = (double*)malloc(sizeof(double) * env->w)))
init_sdl.c:	if (!(env->current_floor = (double*)malloc(sizeof(double) * env->w)))
init_sdl.c:	if (!(env->max_ceiling = (double*)malloc(sizeof(double) * env->w)))
init_sdl.c:	if (!(env->max_floor = (double*)malloc(sizeof(double) * env->w)))
init_sdl.c:	if (!(env->z = (double*)malloc(sizeof(double) * env->w)))
init_sdl.c:	if (!(env->alpha = (double*)malloc(sizeof(double) * env->w)))
init_sdl.c:	if (!(env->clipped_alpha = (double*)malloc(sizeof(double) * env->w)))
init_sdl.c:	if (!(env->line_height = (double*)malloc(sizeof(double) * env->w)))
init_sdl.c:	if (!(env->divider = (double*)malloc(sizeof(double) * env->w)))
init_sdl.c:	if (!(env->no_slope_current_floor = (double*)malloc(sizeof(double) * env->w)))
init_sdl.c:	if (!(env->no_slope_current_ceiling = (double*)malloc(sizeof(double) * env->w)))
init_sdl.c:	if (!(env->ceiling_start = (double*)malloc(sizeof(double) * env->w)))
init_sdl.c:	if (!(env->floor_start = (double*)malloc(sizeof(double) * env->w)))
init_sdl.c:	if (!(env->z_near_z = (double*)malloc(sizeof(double) * env->w)))
init_sdl.c:	if (!(env->neighbor_current_floor = (double*)malloc(sizeof(double) * env->w)))
init_sdl.c:	if (!(env->neighbor_current_ceiling = (double*)malloc(sizeof(double) * env->w)))
init_sdl.c:	if (!(env->neighbor_max_floor = (double*)malloc(sizeof(double) * env->w)))
init_sdl.c:	if (!(env->neighbor_max_ceiling = (double*)malloc(sizeof(double) * env->w)))
init_sdl.c:	if (!(env->zrange = (double*)malloc(sizeof(double) * env->w)))
init_sdl.c:	if (!(env->texel = (t_v2*)malloc(sizeof(t_v2) * env->w)))
init_sdl.c:	if (!(env->texel_near_z = (t_v2*)malloc(sizeof(t_v2) * env->w)))
init_sdl.c:	if (!(env->texel_camera_range = (t_v2*)malloc(sizeof(t_v2) * env->w)))
init_sdl.c:	if (!(env->camera_z = (t_v2*)malloc(sizeof(t_v2) * env->w)))
init_sdl.c:	if (!(env->wall_texel = (t_v2*)malloc(sizeof(t_v2) * env->w)))
init_sdl.c:	if (!(env->vline_data = (t_vline_data*)malloc(sizeof(t_vline_data) * env->w)))
init_sdl.c:				env->sdl.renderer,
init_sdl.c:				env->sdl.texture,
init_sdl.c:	SDL_RenderPresent(env->sdl.renderer);
init_sdl.c:	SDL_SetWindowDisplayMode(env->sdl.window, NULL);
init_sdl.c:	SDL_GetRelativeMouseState(&env->sdl.mouse_x, &env->sdl.mouse_y);
init_sdl.c:	env->time.milli_s =  0;
init_sound.c:	env->sound.b_jump = 20;
init_sound.c:	env->sound.b_footstep = 20;
init_sound.c:	env->sound.b_weapon = 20;
init_sound.c:	env->sound.g_music = 20;
init_sound.c:	if(!(env->sound.background = Mix_LoadMUS("audio/at_dooms_gate.wav")))
init_sound.c:	if (!(env->sound.footstep = Mix_LoadWAV("audio/footstep.wav")))
init_sound.c:	if (!(env->sound.jump = Mix_LoadWAV("audio/jump.wav")))
init_sound.c:	if (!(env->weapons[0].sound = Mix_LoadWAV("audio/shotgun_shot.wav")))
init_sound.c:	if (!(env->weapons[0].empty = Mix_LoadWAV("audio/shotgun_no_ammo.wav")))
init_sound.c:	if (!(env->weapons[1].sound = Mix_LoadWAV("audio/raygun_shot.wav")))
init_sound.c:	if (!(env->weapons[1].empty = Mix_LoadWAV("audio/shotgun_no_ammo.wav")))
init_sound.c:	Mix_VolumeChunk(env->sound.jump, MIX_MAX_VOLUME / env->sound.b_jump);
init_sound.c:	Mix_VolumeChunk(env->sound.footstep, MIX_MAX_VOLUME / env->sound.b_footstep);
init_sound.c:	Mix_VolumeChunk(env->weapons[0].sound, MIX_MAX_VOLUME / env->sound.b_weapon);
init_sound.c:	Mix_VolumeChunk(env->weapons[1].sound, MIX_MAX_VOLUME / env->sound.b_weapon);
init_sprites.c:	if (!(env->sprites = (t_sprite*)malloc(sizeof(t_sprite) * 13)))
init_sprites.c:	env->sprites[0].texture = 33;
init_sprites.c:	env->sprites[0].death_counterpart = 0;
init_sprites.c:	env->sprites[0].oriented = 0;
init_sprites.c:	env->sprites[0].rest_sprite = 0;
init_sprites.c:	env->sprites[0].reversed[0] = 0;
init_sprites.c:	env->sprites[0].start[0].x = 511;
init_sprites.c:	env->sprites[0].start[0].y = 78;
init_sprites.c:	env->sprites[0].end[0].x = 562;
init_sprites.c:	env->sprites[0].end[0].y = 102;
init_sprites.c:	env->sprites[0].size[0].x = 51;
init_sprites.c:	env->sprites[0].size[0].y = 24;
init_sprites.c:	env->sprites[1].texture = 34;
init_sprites.c:	env->sprites[1].death_counterpart = 4;
init_sprites.c:	env->sprites[1].pursuit_sprite = 7;
init_sprites.c:	env->sprites[1].firing_sprite = 1;
init_sprites.c:	env->sprites[1].rest_sprite = 3;
init_sprites.c:	env->sprites[1].curr_sprite = 1;
init_sprites.c:	env->sprites[1].oriented = 1;
init_sprites.c:	env->sprites[1].nb_death_sprites = 6;
init_sprites.c:	env->sprites[1].start[0].x = 44;
init_sprites.c:	env->sprites[1].start[0].y = 120;
init_sprites.c:	env->sprites[1].end[0].x = 87;
init_sprites.c:	env->sprites[1].end[0].y = 165;
init_sprites.c:	env->sprites[1].size[0].x = 44;
init_sprites.c:	env->sprites[1].size[0].y = 46;
init_sprites.c:	env->sprites[1].reversed[0] = 0;
init_sprites.c:	env->sprites[1].start[1].x = 374;
init_sprites.c:	env->sprites[1].start[1].y = 120;
init_sprites.c:	env->sprites[1].end[1].x = 405;
init_sprites.c:	env->sprites[1].end[1].y = 172;
init_sprites.c:	env->sprites[1].size[1].x = 32;
init_sprites.c:	env->sprites[1].size[1].y = 53;
init_sprites.c:	env->sprites[1].reversed[1] = 0;
init_sprites.c:	env->sprites[1].start[2].x = 299;
init_sprites.c:	env->sprites[1].start[2].y = 120;
init_sprites.c:	env->sprites[1].end[2].x = 329;
init_sprites.c:	env->sprites[1].end[2].y = 173;
init_sprites.c:	env->sprites[1].size[2].x = 31;
init_sprites.c:	env->sprites[1].size[2].y = 54;
init_sprites.c:	env->sprites[1].reversed[2] = 0;
init_sprites.c:	env->sprites[1].start[3].x = 220;
init_sprites.c:	env->sprites[1].start[3].y = 120;
init_sprites.c:	env->sprites[1].end[3].x = 254;
init_sprites.c:	env->sprites[1].end[3].y = 171;
init_sprites.c:	env->sprites[1].size[3].x = 35;
init_sprites.c:	env->sprites[1].size[3].y = 52;
init_sprites.c:	env->sprites[1].reversed[3] = 0;
init_sprites.c:	env->sprites[1].start[4].x = 132;
init_sprites.c:	env->sprites[1].start[4].y = 120;
init_sprites.c:	env->sprites[1].end[4].x = 175;
init_sprites.c:	env->sprites[1].end[4].y = 165;
init_sprites.c:	env->sprites[1].size[4].x = 44;
init_sprites.c:	env->sprites[1].size[4].y = 46;
init_sprites.c:	env->sprites[1].reversed[4] = 0;
init_sprites.c:	env->sprites[1].start[5].x = 220;
init_sprites.c:	env->sprites[1].start[5].y = 120;
init_sprites.c:	env->sprites[1].end[5].x = 254;
init_sprites.c:	env->sprites[1].end[5].y = 171;
init_sprites.c:	env->sprites[1].size[5].x = 35;
init_sprites.c:	env->sprites[1].size[5].y = 52;
init_sprites.c:	env->sprites[1].reversed[5] = 1;
init_sprites.c:	env->sprites[1].start[6].x = 299;
init_sprites.c:	env->sprites[1].start[6].y = 120;
init_sprites.c:	env->sprites[1].end[6].x = 329;
init_sprites.c:	env->sprites[1].end[6].y = 173;
init_sprites.c:	env->sprites[1].size[6].x = 31;
init_sprites.c:	env->sprites[1].size[6].y = 54;
init_sprites.c:	env->sprites[1].reversed[6] = 1;
init_sprites.c:	env->sprites[1].start[7].x = 374;
init_sprites.c:	env->sprites[1].start[7].y = 120;
init_sprites.c:	env->sprites[1].end[7].x = 405;
init_sprites.c:	env->sprites[1].end[7].y = 172;
init_sprites.c:	env->sprites[1].size[7].x = 32;
init_sprites.c:	env->sprites[1].size[7].y = 53;
init_sprites.c:	env->sprites[1].reversed[7] = 1;
init_sprites.c:	env->sprites[2].texture = 44;
init_sprites.c:	env->sprites[2].death_counterpart = 6;
init_sprites.c:	env->sprites[2].pursuit_sprite = 5;
init_sprites.c:	env->sprites[2].firing_sprite = 9;
init_sprites.c:	env->sprites[2].rest_sprite = 5;
init_sprites.c:	env->sprites[2].curr_sprite = 2;
init_sprites.c:	env->sprites[2].oriented = 1;
init_sprites.c:	env->sprites[2].nb_death_sprites = 8;
init_sprites.c:	env->sprites[2].start[0].x = 44;
init_sprites.c:	env->sprites[2].start[0].y = 33;
init_sprites.c:	env->sprites[2].end[0].x = 125;
init_sprites.c:	env->sprites[2].end[0].y = 140;
init_sprites.c:	env->sprites[2].size[0].x = 82;
init_sprites.c:	env->sprites[2].size[0].y = 108;
init_sprites.c:	env->sprites[2].reversed[0] = 0;
init_sprites.c:	env->sprites[2].start[1].x = 925;
init_sprites.c:	env->sprites[2].start[1].y = 33;
init_sprites.c:	env->sprites[2].end[1].x = 999;
init_sprites.c:	env->sprites[2].end[1].y = 141;
init_sprites.c:	env->sprites[2].size[1].x = 75;
init_sprites.c:	env->sprites[2].size[1].y = 109;
init_sprites.c:	env->sprites[2].reversed[1] = 0;
init_sprites.c:	env->sprites[2].start[2].x = 798;
init_sprites.c:	env->sprites[2].start[2].y = 33;
init_sprites.c:	env->sprites[2].end[2].x = 880;
init_sprites.c:	env->sprites[2].end[2].y = 141;
init_sprites.c:	env->sprites[2].size[2].x = 84;
init_sprites.c:	env->sprites[2].size[2].y = 109;
init_sprites.c:	env->sprites[2].reversed[2] = 0;
init_sprites.c:	env->sprites[2].start[3].x = 670;
init_sprites.c:	env->sprites[2].start[3].y = 33;
init_sprites.c:	env->sprites[2].end[3].x = 752;
init_sprites.c:	env->sprites[2].end[3].y = 142;
init_sprites.c:	env->sprites[2].size[3].x = 83;
init_sprites.c:	env->sprites[2].size[3].y = 110;
init_sprites.c:	env->sprites[2].reversed[3] = 0;
init_sprites.c:	env->sprites[2].start[4].x = 544;
init_sprites.c:	env->sprites[2].start[4].y = 33;
init_sprites.c:	env->sprites[2].end[4].x = 625;
init_sprites.c:	env->sprites[2].end[4].y = 142;
init_sprites.c:	env->sprites[2].size[4].x = 82;
init_sprites.c:	env->sprites[2].size[4].y = 110;
init_sprites.c:	env->sprites[2].reversed[4] = 0;
init_sprites.c:	env->sprites[2].start[5].x = 424;
init_sprites.c:	env->sprites[2].start[5].y = 33;
init_sprites.c:	env->sprites[2].end[5].x = 499;
init_sprites.c:	env->sprites[2].end[5].y = 142;
init_sprites.c:	env->sprites[2].size[5].x = 76;
init_sprites.c:	env->sprites[2].size[5].y = 110;
init_sprites.c:	env->sprites[2].reversed[5] = 0;
init_sprites.c:	env->sprites[2].start[6].x = 301;
init_sprites.c:	env->sprites[2].start[6].y = 33;
init_sprites.c:	env->sprites[2].end[6].x = 379;
init_sprites.c:	env->sprites[2].end[6].y = 139;
init_sprites.c:	env->sprites[2].size[6].x = 79;
init_sprites.c:	env->sprites[2].size[6].y = 107;
init_sprites.c:	env->sprites[2].reversed[6] = 0;
init_sprites.c:	env->sprites[2].start[7].x = 170;
init_sprites.c:	env->sprites[2].start[7].y = 33;
init_sprites.c:	env->sprites[2].end[7].x = 256;
init_sprites.c:	env->sprites[2].end[7].y = 139;
init_sprites.c:	env->sprites[2].size[7].x = 87;
init_sprites.c:	env->sprites[2].size[7].y = 107;
init_sprites.c:	env->sprites[2].reversed[7] = 0;
init_sprites.c:	env->sprites[3].texture = 34;
init_sprites.c:	env->sprites[3].death_counterpart = 4;
init_sprites.c:	env->sprites[3].pursuit_sprite = 8;
init_sprites.c:	env->sprites[3].firing_sprite = 3;
init_sprites.c:	env->sprites[3].rest_sprite = 1;
init_sprites.c:	env->sprites[3].curr_sprite = 3;
init_sprites.c:	env->sprites[3].oriented = 1;
init_sprites.c:	env->sprites[3].nb_death_sprites = 6;
init_sprites.c:	env->sprites[3].start[0].x = 44;
init_sprites.c:	env->sprites[3].start[0].y = 33;
init_sprites.c:	env->sprites[3].end[0].x = 87;
init_sprites.c:	env->sprites[3].end[0].y = 79;
init_sprites.c:	env->sprites[3].size[0].x = 44;
init_sprites.c:	env->sprites[3].size[0].y = 47;
init_sprites.c:	env->sprites[3].reversed[0] = 0;
init_sprites.c:	env->sprites[3].start[1].x = 132;
init_sprites.c:	env->sprites[3].start[1].y = 33;
init_sprites.c:	env->sprites[3].end[1].x = 163;
init_sprites.c:	env->sprites[3].end[1].y = 79;
init_sprites.c:	env->sprites[3].size[1].x = 32;
init_sprites.c:	env->sprites[3].size[1].y = 47;
init_sprites.c:	env->sprites[3].reversed[1] = 0;
init_sprites.c:	env->sprites[3].start[2].x = 208;
init_sprites.c:	env->sprites[3].start[2].y = 33;
init_sprites.c:	env->sprites[3].end[2].x = 238;
init_sprites.c:	env->sprites[3].end[2].y = 86;
init_sprites.c:	env->sprites[3].size[2].x = 31;
init_sprites.c:	env->sprites[3].size[2].y = 54;
init_sprites.c:	env->sprites[3].reversed[2] = 0;
init_sprites.c:	env->sprites[3].start[3].x = 283;
init_sprites.c:	env->sprites[3].start[3].y = 33;
init_sprites.c:	env->sprites[3].end[3].x = 317;
init_sprites.c:	env->sprites[3].end[3].y = 84;
init_sprites.c:	env->sprites[3].size[3].x = 35;
init_sprites.c:	env->sprites[3].size[3].y = 52;
init_sprites.c:	env->sprites[3].reversed[3] = 0;
init_sprites.c:	env->sprites[3].start[4].x = 362;
init_sprites.c:	env->sprites[3].start[4].y = 33;
init_sprites.c:	env->sprites[3].end[4].x = 405;
init_sprites.c:	env->sprites[3].end[4].y = 78;
init_sprites.c:	env->sprites[3].size[4].x = 44;
init_sprites.c:	env->sprites[3].size[4].y = 46;
init_sprites.c:	env->sprites[3].reversed[4] = 0;
init_sprites.c:	env->sprites[3].start[5].x = 283;
init_sprites.c:	env->sprites[3].start[5].y = 33;
init_sprites.c:	env->sprites[3].end[5].x = 317;
init_sprites.c:	env->sprites[3].end[5].y = 84;
init_sprites.c:	env->sprites[3].size[5].x = 35;
init_sprites.c:	env->sprites[3].size[5].y = 52;
init_sprites.c:	env->sprites[3].reversed[5] = 1;
init_sprites.c:	env->sprites[3].start[6].x = 208;
init_sprites.c:	env->sprites[3].start[6].y = 33;
init_sprites.c:	env->sprites[3].end[6].x = 238;
init_sprites.c:	env->sprites[3].end[6].y = 86;
init_sprites.c:	env->sprites[3].size[6].x = 31;
init_sprites.c:	env->sprites[3].size[6].y = 54;
init_sprites.c:	env->sprites[3].reversed[6] = 1;
init_sprites.c:	env->sprites[3].start[7].x = 132;
init_sprites.c:	env->sprites[3].start[7].y = 33;
init_sprites.c:	env->sprites[3].end[7].x = 163;
init_sprites.c:	env->sprites[3].end[7].y = 79;
init_sprites.c:	env->sprites[3].size[7].x = 32;
init_sprites.c:	env->sprites[3].size[7].y = 47;
init_sprites.c:	env->sprites[3].reversed[7] = 1;
init_sprites.c:	env->sprites[4].texture = 34;
init_sprites.c:	env->sprites[4].death_counterpart = 4;
init_sprites.c:	env->sprites[4].pursuit_sprite = 4;
init_sprites.c:	env->sprites[4].firing_sprite = 4;
init_sprites.c:	env->sprites[4].rest_sprite = 4;
init_sprites.c:	env->sprites[4].curr_sprite = 4;
init_sprites.c:	env->sprites[4].oriented = 0;
init_sprites.c:	env->sprites[4].nb_death_sprites = 6;
init_sprites.c:	env->sprites[4].start[0].x = 44;
init_sprites.c:	env->sprites[4].start[0].y = 448;
init_sprites.c:	env->sprites[4].end[0].x = 77;
init_sprites.c:	env->sprites[4].end[0].y = 498;
init_sprites.c:	env->sprites[4].size[0].x = 34;
init_sprites.c:	env->sprites[4].size[0].y = 51;
init_sprites.c:	env->sprites[4].reversed[0] = 0;
init_sprites.c:	env->sprites[4].start[1].x = 122;
init_sprites.c:	env->sprites[4].start[1].y = 448;
init_sprites.c:	env->sprites[4].end[1].x = 157;
init_sprites.c:	env->sprites[4].end[1].y = 500;
init_sprites.c:	env->sprites[4].size[1].x = 36;
init_sprites.c:	env->sprites[4].size[1].y = 53;
init_sprites.c:	env->sprites[4].reversed[1] = 0;
init_sprites.c:	env->sprites[4].start[2].x = 202;
init_sprites.c:	env->sprites[4].start[2].y = 448;
init_sprites.c:	env->sprites[4].end[2].x = 246;
init_sprites.c:	env->sprites[4].end[2].y = 495;
init_sprites.c:	env->sprites[4].size[2].x = 45;
init_sprites.c:	env->sprites[4].size[2].y = 48;
init_sprites.c:	env->sprites[4].reversed[2] = 0;
init_sprites.c:	env->sprites[4].start[3].x = 291;
init_sprites.c:	env->sprites[4].start[3].y = 448;
init_sprites.c:	env->sprites[4].end[3].x = 358;
init_sprites.c:	env->sprites[4].end[3].y = 507;
init_sprites.c:	env->sprites[4].size[3].x = 68;
init_sprites.c:	env->sprites[4].size[3].y = 60;
init_sprites.c:	env->sprites[4].reversed[3] = 0;
init_sprites.c:	env->sprites[4].start[4].x = 403;
init_sprites.c:	env->sprites[4].start[4].y = 448;
init_sprites.c:	env->sprites[4].end[4].x = 490;
init_sprites.c:	env->sprites[4].end[4].y = 519;
init_sprites.c:	env->sprites[4].size[4].x = 88;
init_sprites.c:	env->sprites[4].size[4].y = 72;
init_sprites.c:	env->sprites[4].reversed[4] = 0;
init_sprites.c:	env->sprites[4].start[5].x = 535;
init_sprites.c:	env->sprites[4].start[5].y = 448;
init_sprites.c:	env->sprites[4].end[5].x = 637;
init_sprites.c:	env->sprites[4].end[5].y = 537;
init_sprites.c:	env->sprites[4].size[5].x = 103;
init_sprites.c:	env->sprites[4].size[5].y = 90;
init_sprites.c:	env->sprites[4].reversed[5] = 0;
init_sprites.c:	env->sprites[5].texture = 44;
init_sprites.c:	env->sprites[5].death_counterpart = 6;
init_sprites.c:	env->sprites[5].pursuit_sprite = 2;
init_sprites.c:	env->sprites[5].firing_sprite = 9;
init_sprites.c:	env->sprites[5].rest_sprite = 2;
init_sprites.c:	env->sprites[5].curr_sprite = 5;
init_sprites.c:	env->sprites[5].oriented = 1;
init_sprites.c:	env->sprites[5].nb_death_sprites = 8;
init_sprites.c:	env->sprites[5].start[0].x = 44;
init_sprites.c:	env->sprites[5].start[0].y = 608;
init_sprites.c:	env->sprites[5].end[0].x = 129;
init_sprites.c:	env->sprites[5].end[0].y = 717;
init_sprites.c:	env->sprites[5].size[0].x = 86;
init_sprites.c:	env->sprites[5].size[0].y = 110;
init_sprites.c:	env->sprites[5].reversed[0] = 0;
init_sprites.c:	env->sprites[5].start[1].x = 996;
init_sprites.c:	env->sprites[5].start[1].y = 608;
init_sprites.c:	env->sprites[5].end[1].x = 1110;
init_sprites.c:	env->sprites[5].end[1].y = 717;
init_sprites.c:	env->sprites[5].size[1].x = 115;
init_sprites.c:	env->sprites[5].size[1].y = 110;
init_sprites.c:	env->sprites[5].reversed[1] = 0;
init_sprites.c:	env->sprites[5].start[2].x = 855;
init_sprites.c:	env->sprites[5].start[2].y = 608;
init_sprites.c:	env->sprites[5].end[2].x = 951;
init_sprites.c:	env->sprites[5].end[2].y = 717;
init_sprites.c:	env->sprites[5].size[2].x = 97;
init_sprites.c:	env->sprites[5].size[2].y = 110;
init_sprites.c:	env->sprites[5].reversed[2] = 0;
init_sprites.c:	env->sprites[5].start[3].x = 729;
init_sprites.c:	env->sprites[5].start[3].y = 608;
init_sprites.c:	env->sprites[5].end[3].x = 810;
init_sprites.c:	env->sprites[5].end[3].y = 717;
init_sprites.c:	env->sprites[5].size[3].x = 82;
init_sprites.c:	env->sprites[5].size[3].y = 110;
init_sprites.c:	env->sprites[5].reversed[3] = 0;
init_sprites.c:	env->sprites[5].start[4].x = 600;
init_sprites.c:	env->sprites[5].start[4].y = 608;
init_sprites.c:	env->sprites[5].end[4].x = 684;
init_sprites.c:	env->sprites[5].end[4].y = 717;
init_sprites.c:	env->sprites[5].size[4].x = 85;
init_sprites.c:	env->sprites[5].size[4].y = 110;
init_sprites.c:	env->sprites[5].reversed[4] = 0;
init_sprites.c:	env->sprites[5].start[5].x = 451;
init_sprites.c:	env->sprites[5].start[5].y = 608;
init_sprites.c:	env->sprites[5].end[5].x = 555;
init_sprites.c:	env->sprites[5].end[5].y = 716;
init_sprites.c:	env->sprites[5].size[5].x = 106;
init_sprites.c:	env->sprites[5].size[5].y = 109;
init_sprites.c:	env->sprites[5].reversed[5] = 0;
init_sprites.c:	env->sprites[5].start[6].x = 301;
init_sprites.c:	env->sprites[5].start[6].y = 608;
init_sprites.c:	env->sprites[5].end[6].x = 405;
init_sprites.c:	env->sprites[5].end[6].y = 717;
init_sprites.c:	env->sprites[5].size[6].x = 105;
init_sprites.c:	env->sprites[5].size[6].y = 110;
init_sprites.c:	env->sprites[5].reversed[6] = 0;
init_sprites.c:	env->sprites[5].start[7].x = 174;
init_sprites.c:	env->sprites[5].start[7].y = 608;
init_sprites.c:	env->sprites[5].end[7].x = 256;
init_sprites.c:	env->sprites[5].end[7].y = 717;
init_sprites.c:	env->sprites[5].size[7].x = 83;
init_sprites.c:	env->sprites[5].size[7].y = 110;
init_sprites.c:	env->sprites[5].reversed[7] = 0;
init_sprites.c:	env->sprites[6].texture = 44;
init_sprites.c:	env->sprites[6].death_counterpart = 6;
init_sprites.c:	env->sprites[6].pursuit_sprite = 6;
init_sprites.c:	env->sprites[6].firing_sprite = 6;
init_sprites.c:	env->sprites[6].rest_sprite = 6;
init_sprites.c:	env->sprites[6].curr_sprite = 6;
init_sprites.c:	env->sprites[6].oriented = 0;
init_sprites.c:	env->sprites[6].nb_death_sprites = 8;
init_sprites.c:	env->sprites[6].start[0].x = 44;
init_sprites.c:	env->sprites[6].start[0].y = 1038;
init_sprites.c:	env->sprites[6].end[0].x = 165;
init_sprites.c:	env->sprites[6].end[0].y = 1148;
init_sprites.c:	env->sprites[6].size[0].x = 122;
init_sprites.c:	env->sprites[6].size[0].y = 111;
init_sprites.c:	env->sprites[6].reversed[0] = 0;
init_sprites.c:	env->sprites[6].start[1].x = 210;
init_sprites.c:	env->sprites[6].start[1].y = 1038;
init_sprites.c:	env->sprites[6].end[1].x = 320;
init_sprites.c:	env->sprites[6].end[1].y = 1150;
init_sprites.c:	env->sprites[6].size[1].x = 111;
init_sprites.c:	env->sprites[6].size[1].y = 113;
init_sprites.c:	env->sprites[6].reversed[1] = 0;
init_sprites.c:	env->sprites[6].start[2].x = 365;
init_sprites.c:	env->sprites[6].start[2].y = 1038;
init_sprites.c:	env->sprites[6].end[2].x = 464;
init_sprites.c:	env->sprites[6].end[2].y = 1153;
init_sprites.c:	env->sprites[6].size[2].x = 100;
init_sprites.c:	env->sprites[6].size[2].y = 116;
init_sprites.c:	env->sprites[6].reversed[2] = 0;
init_sprites.c:	env->sprites[6].start[3].x = 509;
init_sprites.c:	env->sprites[6].start[3].y = 1038;
init_sprites.c:	env->sprites[6].end[3].x = 621;
init_sprites.c:	env->sprites[6].end[3].y = 1154;
init_sprites.c:	env->sprites[6].size[3].x = 113;
init_sprites.c:	env->sprites[6].size[3].y = 117;
init_sprites.c:	env->sprites[6].reversed[3] = 0;
init_sprites.c:	env->sprites[6].start[4].x = 666;
init_sprites.c:	env->sprites[6].start[4].y = 1038;
init_sprites.c:	env->sprites[6].end[4].x = 790;
init_sprites.c:	env->sprites[6].end[4].y = 1161;
init_sprites.c:	env->sprites[6].size[4].x = 125;
init_sprites.c:	env->sprites[6].size[4].y = 124;
init_sprites.c:	env->sprites[6].reversed[4] = 0;
init_sprites.c:	env->sprites[6].start[5].x = 836;
init_sprites.c:	env->sprites[6].start[5].y = 1038;
init_sprites.c:	env->sprites[6].end[5].x = 970;
init_sprites.c:	env->sprites[6].end[5].y = 1168;
init_sprites.c:	env->sprites[6].size[5].x = 136;
init_sprites.c:	env->sprites[6].size[5].y = 131;
init_sprites.c:	env->sprites[6].reversed[5] = 0;
init_sprites.c:	env->sprites[6].start[6].x = 1015;
init_sprites.c:	env->sprites[6].start[6].y = 1038;
init_sprites.c:	env->sprites[6].end[6].x = 1155;
init_sprites.c:	env->sprites[6].end[6].y = 1171;
init_sprites.c:	env->sprites[6].size[6].x = 141;
init_sprites.c:	env->sprites[6].size[6].y = 134;
init_sprites.c:	env->sprites[6].reversed[6] = 0;
init_sprites.c:	env->sprites[6].start[7].x = 1200;
init_sprites.c:	env->sprites[6].start[7].y = 1038;
init_sprites.c:	env->sprites[6].end[7].x = 1338;
init_sprites.c:	env->sprites[6].end[7].y = 1171;
init_sprites.c:	env->sprites[6].size[7].x = 139;
init_sprites.c:	env->sprites[6].size[7].y = 134;
init_sprites.c:	env->sprites[6].reversed[7] = 0;
init_sprites.c:	env->sprites[7].texture = 34;
init_sprites.c:	env->sprites[7].death_counterpart = 4;
init_sprites.c:	env->sprites[7].pursuit_sprite = 8;
init_sprites.c:	env->sprites[7].firing_sprite = 7;
init_sprites.c:	env->sprites[7].rest_sprite = 1;
init_sprites.c:	env->sprites[7].curr_sprite = 7;
init_sprites.c:	env->sprites[7].oriented = 1;
init_sprites.c:	env->sprites[7].nb_death_sprites = 6;
init_sprites.c:	env->sprites[7].start[0].x = 44;
init_sprites.c:	env->sprites[7].start[0].y = 207;
init_sprites.c:	env->sprites[7].end[0].x = 87;
init_sprites.c:	env->sprites[7].end[0].y = 250;
init_sprites.c:	env->sprites[7].size[0].x = 44;
init_sprites.c:	env->sprites[7].size[0].y = 44;
init_sprites.c:	env->sprites[7].reversed[0] = 0;
init_sprites.c:	env->sprites[7].start[1].x = 132;
init_sprites.c:	env->sprites[7].start[1].y = 207;
init_sprites.c:	env->sprites[7].end[1].x = 191;
init_sprites.c:	env->sprites[7].end[1].y = 242;
init_sprites.c:	env->sprites[7].size[1].x = 60;
init_sprites.c:	env->sprites[7].size[1].y = 36;
init_sprites.c:	env->sprites[7].reversed[1] = 0;
init_sprites.c:	env->sprites[7].start[2].x = 236;
init_sprites.c:	env->sprites[7].start[2].y = 207;
init_sprites.c:	env->sprites[7].end[2].x = 302;
init_sprites.c:	env->sprites[7].end[2].y = 239;
init_sprites.c:	env->sprites[7].size[2].x = 67;
init_sprites.c:	env->sprites[7].size[2].y = 33;
init_sprites.c:	env->sprites[7].reversed[2] = 0;
init_sprites.c:	env->sprites[7].start[3].x = 347;
init_sprites.c:	env->sprites[7].start[3].y = 207;
init_sprites.c:	env->sprites[7].end[3].x = 400;
init_sprites.c:	env->sprites[7].end[3].y = 238;
init_sprites.c:	env->sprites[7].size[3].x = 54;
init_sprites.c:	env->sprites[7].size[3].y = 32;
init_sprites.c:	env->sprites[7].reversed[3] = 0;
init_sprites.c:	env->sprites[7].start[4].x = 445;
init_sprites.c:	env->sprites[7].start[4].y = 207;
init_sprites.c:	env->sprites[7].end[4].x = 488;
init_sprites.c:	env->sprites[7].end[4].y = 232;
init_sprites.c:	env->sprites[7].size[4].x = 44;
init_sprites.c:	env->sprites[7].size[4].y = 26;
init_sprites.c:	env->sprites[7].reversed[4] = 0;
init_sprites.c:	env->sprites[7].start[5].x = 347;
init_sprites.c:	env->sprites[7].start[5].y = 207;
init_sprites.c:	env->sprites[7].end[5].x = 400;
init_sprites.c:	env->sprites[7].end[5].y = 238;
init_sprites.c:	env->sprites[7].size[5].x = 54;
init_sprites.c:	env->sprites[7].size[5].y = 32;
init_sprites.c:	env->sprites[7].reversed[5] = 1;
init_sprites.c:	env->sprites[7].start[6].x = 236;
init_sprites.c:	env->sprites[7].start[6].y = 207;
init_sprites.c:	env->sprites[7].end[6].x = 302;
init_sprites.c:	env->sprites[7].end[6].y = 239;
init_sprites.c:	env->sprites[7].size[6].x = 67;
init_sprites.c:	env->sprites[7].size[6].y = 33;
init_sprites.c:	env->sprites[7].reversed[6] = 1;
init_sprites.c:	env->sprites[7].start[7].x = 132;
init_sprites.c:	env->sprites[7].start[7].y = 207;
init_sprites.c:	env->sprites[7].end[7].x = 191;
init_sprites.c:	env->sprites[7].end[7].y = 242;
init_sprites.c:	env->sprites[7].size[7].x = 60;
init_sprites.c:	env->sprites[7].size[7].y = 36;
init_sprites.c:	env->sprites[7].reversed[7] = 1;
init_sprites.c:	env->sprites[8].texture = 34;
init_sprites.c:	env->sprites[8].death_counterpart = 4;
init_sprites.c:	env->sprites[8].pursuit_sprite = 7;
init_sprites.c:	env->sprites[8].firing_sprite = 8;
init_sprites.c:	env->sprites[8].rest_sprite = 3;
init_sprites.c:	env->sprites[8].curr_sprite = 8;
init_sprites.c:	env->sprites[8].oriented = 1;
init_sprites.c:	env->sprites[8].nb_death_sprites = 6;
init_sprites.c:	env->sprites[8].start[0].x = 44;
init_sprites.c:	env->sprites[8].start[0].y = 284;
init_sprites.c:	env->sprites[8].end[0].x = 87;
init_sprites.c:	env->sprites[8].end[0].y = 327;
init_sprites.c:	env->sprites[8].size[0].x = 44;
init_sprites.c:	env->sprites[8].size[0].y = 44;
init_sprites.c:	env->sprites[8].reversed[0] = 0;
init_sprites.c:	env->sprites[8].start[1].x = 132;
init_sprites.c:	env->sprites[8].start[1].y = 284;
init_sprites.c:	env->sprites[8].end[1].x = 184;
init_sprites.c:	env->sprites[8].end[1].y = 319;
init_sprites.c:	env->sprites[8].size[1].x = 53;
init_sprites.c:	env->sprites[8].size[1].y = 36;
init_sprites.c:	env->sprites[8].reversed[1] = 0;
init_sprites.c:	env->sprites[8].start[2].x = 229;
init_sprites.c:	env->sprites[8].start[2].y = 284;
init_sprites.c:	env->sprites[8].end[2].x = 295;
init_sprites.c:	env->sprites[8].end[2].y = 316;
init_sprites.c:	env->sprites[8].size[2].x = 67;
init_sprites.c:	env->sprites[8].size[2].y = 33;
init_sprites.c:	env->sprites[8].reversed[2] = 0;
init_sprites.c:	env->sprites[8].start[3].x = 340;
init_sprites.c:	env->sprites[8].start[3].y = 284;
init_sprites.c:	env->sprites[8].end[3].x = 387;
init_sprites.c:	env->sprites[8].end[3].y = 315;
init_sprites.c:	env->sprites[8].size[3].x = 48;
init_sprites.c:	env->sprites[8].size[3].y = 32;
init_sprites.c:	env->sprites[8].reversed[3] = 0;
init_sprites.c:	env->sprites[8].start[4].x = 433;
init_sprites.c:	env->sprites[8].start[4].y = 284;
init_sprites.c:	env->sprites[8].end[4].x = 475;
init_sprites.c:	env->sprites[8].end[4].y = 309;
init_sprites.c:	env->sprites[8].size[4].x = 44;
init_sprites.c:	env->sprites[8].size[4].y = 26;
init_sprites.c:	env->sprites[8].reversed[4] = 0;
init_sprites.c:	env->sprites[8].start[5].x = 340;
init_sprites.c:	env->sprites[8].start[5].y = 284;
init_sprites.c:	env->sprites[8].end[5].x = 387;
init_sprites.c:	env->sprites[8].end[5].y = 315;
init_sprites.c:	env->sprites[8].size[5].x = 48;
init_sprites.c:	env->sprites[8].size[5].y = 32;
init_sprites.c:	env->sprites[8].reversed[5] = 1;
init_sprites.c:	env->sprites[8].start[6].x = 229;
init_sprites.c:	env->sprites[8].start[6].y = 284;
init_sprites.c:	env->sprites[8].end[6].x = 295;
init_sprites.c:	env->sprites[8].end[6].y = 316;
init_sprites.c:	env->sprites[8].size[6].x = 67;
init_sprites.c:	env->sprites[8].size[6].y = 33;
init_sprites.c:	env->sprites[8].reversed[6] = 1;
init_sprites.c:	env->sprites[8].start[7].x = 132;
init_sprites.c:	env->sprites[8].start[7].y = 284;
init_sprites.c:	env->sprites[8].end[7].x = 184;
init_sprites.c:	env->sprites[8].end[7].y = 319;
init_sprites.c:	env->sprites[8].size[7].x = 53;
init_sprites.c:	env->sprites[8].size[7].y = 36;
init_sprites.c:	env->sprites[8].reversed[7] = 1;
init_sprites.c:	env->sprites[9].texture = 44;
init_sprites.c:	env->sprites[9].death_counterpart = 6;
init_sprites.c:	env->sprites[9].pursuit_sprite = 2;
init_sprites.c:	env->sprites[9].firing_sprite = 10;
init_sprites.c:	env->sprites[9].rest_sprite = 2;
init_sprites.c:	env->sprites[9].curr_sprite = 9;
init_sprites.c:	env->sprites[9].oriented = 1;
init_sprites.c:	env->sprites[9].nb_death_sprites = 8;
init_sprites.c:	env->sprites[9].start[0].x = 44;
init_sprites.c:	env->sprites[9].start[0].y = 608;
init_sprites.c:	env->sprites[9].end[0].x = 129;
init_sprites.c:	env->sprites[9].end[0].y = 717;
init_sprites.c:	env->sprites[9].size[0].x = 86;
init_sprites.c:	env->sprites[9].size[0].y = 110;
init_sprites.c:	env->sprites[9].reversed[0] = 0;
init_sprites.c:	env->sprites[9].start[1].x = 174;
init_sprites.c:	env->sprites[9].start[1].y = 608;
init_sprites.c:	env->sprites[9].end[1].x = 256;
init_sprites.c:	env->sprites[9].end[1].y = 717;
init_sprites.c:	env->sprites[9].size[1].x = 83;
init_sprites.c:	env->sprites[9].size[1].y = 110;
init_sprites.c:	env->sprites[9].reversed[1] = 0;
init_sprites.c:	env->sprites[9].start[2].x = 301;
init_sprites.c:	env->sprites[9].start[2].y = 608;
init_sprites.c:	env->sprites[9].end[2].x = 405;
init_sprites.c:	env->sprites[9].end[2].y = 717;
init_sprites.c:	env->sprites[9].size[2].x = 105;
init_sprites.c:	env->sprites[9].size[2].y = 110;
init_sprites.c:	env->sprites[9].reversed[2] = 0;
init_sprites.c:	env->sprites[9].start[3].x = 450;
init_sprites.c:	env->sprites[9].start[3].y = 608;
init_sprites.c:	env->sprites[9].end[3].x = 555;
init_sprites.c:	env->sprites[9].end[3].y = 716;
init_sprites.c:	env->sprites[9].size[3].x = 106;
init_sprites.c:	env->sprites[9].size[3].y = 109;
init_sprites.c:	env->sprites[9].reversed[3] = 0;
init_sprites.c:	env->sprites[9].start[4].x = 600;
init_sprites.c:	env->sprites[9].start[4].y = 608;
init_sprites.c:	env->sprites[9].end[4].x = 684;
init_sprites.c:	env->sprites[9].end[4].y = 717;
init_sprites.c:	env->sprites[9].size[4].x = 85;
init_sprites.c:	env->sprites[9].size[4].y = 110;
init_sprites.c:	env->sprites[9].reversed[4] = 0;
init_sprites.c:	env->sprites[9].start[5].x = 729;
init_sprites.c:	env->sprites[9].start[5].y = 608;
init_sprites.c:	env->sprites[9].end[5].x = 810;
init_sprites.c:	env->sprites[9].end[5].y = 717;
init_sprites.c:	env->sprites[9].size[5].x = 82;
init_sprites.c:	env->sprites[9].size[5].y = 110;
init_sprites.c:	env->sprites[9].reversed[5] = 0;
init_sprites.c:	env->sprites[9].start[6].x = 855;
init_sprites.c:	env->sprites[9].start[6].y = 608;
init_sprites.c:	env->sprites[9].end[6].x = 951;
init_sprites.c:	env->sprites[9].end[6].y = 717;
init_sprites.c:	env->sprites[9].size[6].x = 97;
init_sprites.c:	env->sprites[9].size[6].y = 110;
init_sprites.c:	env->sprites[9].reversed[6] = 0;
init_sprites.c:	env->sprites[9].start[7].x = 996;
init_sprites.c:	env->sprites[9].start[7].y = 608;
init_sprites.c:	env->sprites[9].end[7].x = 1110;
init_sprites.c:	env->sprites[9].end[7].y = 717;
init_sprites.c:	env->sprites[9].size[7].x = 115;
init_sprites.c:	env->sprites[9].size[7].y = 110;
init_sprites.c:	env->sprites[9].reversed[7] = 0;
init_sprites.c:	env->sprites[10].texture = 44;
init_sprites.c:	env->sprites[10].death_counterpart = 6;
init_sprites.c:	env->sprites[10].pursuit_sprite = 5;
init_sprites.c:	env->sprites[10].firing_sprite = 9;
init_sprites.c:	env->sprites[10].rest_sprite = 5;
init_sprites.c:	env->sprites[10].curr_sprite = 10;
init_sprites.c:	env->sprites[10].oriented = 1;
init_sprites.c:	env->sprites[10].nb_death_sprites = 8;
init_sprites.c:	env->sprites[10].start[0].x = 44;
init_sprites.c:	env->sprites[10].start[0].y = 751;
init_sprites.c:	env->sprites[10].end[0].x = 142;
init_sprites.c:	env->sprites[10].end[0].y = 860;
init_sprites.c:	env->sprites[10].size[0].x = 99;
init_sprites.c:	env->sprites[10].size[0].y = 110;
init_sprites.c:	env->sprites[10].reversed[0] = 0;
init_sprites.c:	env->sprites[10].start[1].x = 187;
init_sprites.c:	env->sprites[10].start[1].y = 751;
init_sprites.c:	env->sprites[10].end[1].x = 280;
init_sprites.c:	env->sprites[10].end[1].y = 860;
init_sprites.c:	env->sprites[10].size[1].x = 94;
init_sprites.c:	env->sprites[10].size[1].y = 110;
init_sprites.c:	env->sprites[10].reversed[1] = 0;
init_sprites.c:	env->sprites[10].start[2].x = 325;
init_sprites.c:	env->sprites[10].start[2].y = 751;
init_sprites.c:	env->sprites[10].end[2].x = 445;
init_sprites.c:	env->sprites[10].end[2].y = 860;
init_sprites.c:	env->sprites[10].size[2].x = 121;
init_sprites.c:	env->sprites[10].size[2].y = 110;
init_sprites.c:	env->sprites[10].reversed[2] = 0;
init_sprites.c:	env->sprites[10].start[3].x = 490;
init_sprites.c:	env->sprites[10].start[3].y = 751;
init_sprites.c:	env->sprites[10].end[3].x = 608;
init_sprites.c:	env->sprites[10].end[3].y = 859;
init_sprites.c:	env->sprites[10].size[3].x = 119;
init_sprites.c:	env->sprites[10].size[3].y = 109;
init_sprites.c:	env->sprites[10].reversed[3] = 0;
init_sprites.c:	env->sprites[10].start[4].x = 653;
init_sprites.c:	env->sprites[10].start[4].y = 751;
init_sprites.c:	env->sprites[10].end[4].x = 741;
init_sprites.c:	env->sprites[10].end[4].y = 860;
init_sprites.c:	env->sprites[10].size[4].x = 89;
init_sprites.c:	env->sprites[10].size[4].y = 110;
init_sprites.c:	env->sprites[10].reversed[4] = 0;
init_sprites.c:	env->sprites[10].start[5].x = 786;
init_sprites.c:	env->sprites[10].start[5].y = 751;
init_sprites.c:	env->sprites[10].end[5].x = 878;
init_sprites.c:	env->sprites[10].end[5].y = 860;
init_sprites.c:	env->sprites[10].size[5].x = 93;
init_sprites.c:	env->sprites[10].size[5].y = 110;
init_sprites.c:	env->sprites[10].reversed[5] = 0;
init_sprites.c:	env->sprites[10].start[6].x = 923;
init_sprites.c:	env->sprites[10].start[6].y = 751;
init_sprites.c:	env->sprites[10].end[6].x = 1036;
init_sprites.c:	env->sprites[10].end[6].y = 860;
init_sprites.c:	env->sprites[10].size[6].x = 114;
init_sprites.c:	env->sprites[10].size[6].y = 110;
init_sprites.c:	env->sprites[10].reversed[6] = 0;
init_sprites.c:	env->sprites[10].start[7].x = 1081;
init_sprites.c:	env->sprites[10].start[7].y = 751;
init_sprites.c:	env->sprites[10].end[7].x = 1210;
init_sprites.c:	env->sprites[10].end[7].y = 860;
init_sprites.c:	env->sprites[10].size[7].x = 130;
init_sprites.c:	env->sprites[10].size[7].y = 110;
init_sprites.c:	env->sprites[10].reversed[7] = 0;
init_sprites.c:	env->sprites[11].texture = 45;
init_sprites.c:	env->sprites[11].death_counterpart = 11;
init_sprites.c:	env->sprites[11].pursuit_sprite = 11;
init_sprites.c:	env->sprites[11].firing_sprite = 11;
init_sprites.c:	env->sprites[11].rest_sprite = 11;
init_sprites.c:	env->sprites[11].curr_sprite = 11;
init_sprites.c:	env->sprites[11].oriented = 1;
init_sprites.c:	env->sprites[11].nb_death_sprites = 8;
init_sprites.c:	env->sprites[11].start[0].x = 1;
init_sprites.c:	env->sprites[11].start[0].y = 817;
init_sprites.c:	env->sprites[11].end[0].x = 15;
init_sprites.c:	env->sprites[11].end[0].y = 830;
init_sprites.c:	env->sprites[11].size[0].x = 15;
init_sprites.c:	env->sprites[11].size[0].y = 14;
init_sprites.c:	env->sprites[11].reversed[0] = 0;
init_sprites.c:	env->sprites[11].start[1].x = 17;
init_sprites.c:	env->sprites[11].start[1].y = 817;
init_sprites.c:	env->sprites[11].end[1].x = 31;
init_sprites.c:	env->sprites[11].end[1].y = 830;
init_sprites.c:	env->sprites[11].size[1].x = 15;
init_sprites.c:	env->sprites[11].size[1].y = 14;
init_sprites.c:	env->sprites[11].reversed[1] = 0;
init_sprites.c:	env->sprites[11].start[2].x = 33;
init_sprites.c:	env->sprites[11].start[2].y = 817;
init_sprites.c:	env->sprites[11].end[2].x = 58;
init_sprites.c:	env->sprites[11].end[2].y = 830;
init_sprites.c:	env->sprites[11].size[2].x = 26;
init_sprites.c:	env->sprites[11].size[2].y = 14;
init_sprites.c:	env->sprites[11].reversed[2] = 0;
init_sprites.c:	env->sprites[11].start[3].x = 60;
init_sprites.c:	env->sprites[11].start[3].y = 817;
init_sprites.c:	env->sprites[11].end[3].x = 108;
init_sprites.c:	env->sprites[11].end[3].y = 830;
init_sprites.c:	env->sprites[11].size[3].x = 49;
init_sprites.c:	env->sprites[11].size[3].y = 14;
init_sprites.c:	env->sprites[11].reversed[3] = 0;
init_sprites.c:	env->sprites[11].start[4].x = 110;
init_sprites.c:	env->sprites[11].start[4].y = 817;
init_sprites.c:	env->sprites[11].end[4].x = 141;
init_sprites.c:	env->sprites[11].end[4].y = 830;
init_sprites.c:	env->sprites[11].size[4].x = 32;
init_sprites.c:	env->sprites[11].size[4].y = 14;
init_sprites.c:	env->sprites[11].reversed[4] = 0;
init_sprites.c:	env->sprites[11].start[5].x = 110;
init_sprites.c:	env->sprites[11].start[5].y = 817;
init_sprites.c:	env->sprites[11].end[5].x = 141;
init_sprites.c:	env->sprites[11].end[5].y = 830;
init_sprites.c:	env->sprites[11].size[5].x = 32;
init_sprites.c:	env->sprites[11].size[5].y = 14;
init_sprites.c:	env->sprites[11].reversed[5] = 1;
init_sprites.c:	env->sprites[11].start[6].x = 60;
init_sprites.c:	env->sprites[11].start[6].y = 817;
init_sprites.c:	env->sprites[11].end[6].x = 108;
init_sprites.c:	env->sprites[11].end[6].y = 830;
init_sprites.c:	env->sprites[11].size[6].x = 49;
init_sprites.c:	env->sprites[11].size[6].y = 14;
init_sprites.c:	env->sprites[11].reversed[6] = 1;
init_sprites.c:	env->sprites[11].start[7].x = 33;
init_sprites.c:	env->sprites[11].start[7].y = 817;
init_sprites.c:	env->sprites[11].end[7].x = 58;
init_sprites.c:	env->sprites[11].end[7].y = 830;
init_sprites.c:	env->sprites[11].size[7].x = 26;
init_sprites.c:	env->sprites[11].size[7].y = 14;
init_sprites.c:	env->sprites[11].reversed[7] = 1;
init_sprites.c:	env->sprites[12].texture = 46;
init_sprites.c:	env->sprites[12].death_counterpart = 12;
init_sprites.c:	env->sprites[12].pursuit_sprite = 12;
init_sprites.c:	env->sprites[12].rest_sprite = 12;
init_sprites.c:	env->sprites[12].curr_sprite = 12;
init_sprites.c:	env->sprites[12].oriented = 0;
init_sprites.c:	env->sprites[12].nb_death_sprites = 9;
init_sprites.c:	env->sprites[12].start[0].x = 0;
init_sprites.c:	env->sprites[12].start[0].y = 0;
init_sprites.c:	env->sprites[12].end[0].x = 128;
init_sprites.c:	env->sprites[12].end[0].y = 256;
init_sprites.c:	env->sprites[12].size[0].x = 128;
init_sprites.c:	env->sprites[12].size[0].y = 256;
init_sprites.c:	env->sprites[12].reversed[0] = 0;
init_ttf.c:	//env->sdl.font = TTF_OpenFont("fonts/heartwrecked.ttf", 65);
init_ttf.c:	env->sdl.fonts.amazdoom70 = TTF_OpenFont("fonts/amazdoom/AmazDoomLeft.ttf", 70);
init_ttf.c:	env->sdl.fonts.amazdoom50 = TTF_OpenFont("fonts/amazdoom/AmazDoomLeft.ttf", 50);
init_ttf.c:	env->sdl.fonts.amazdoom20 = TTF_OpenFont("fonts/amazdoom/AmazDoomLeft.ttf", 20);
init_ttf.c:	env->sdl.fonts.alice30 = TTF_OpenFont("fonts/alice/Alice-Regular.ttf", 30);
init_ttf.c:	env->sdl.fonts.alice70 = TTF_OpenFont("fonts/alice/Alice-Regular.ttf", 70);
init_ttf.c:	env->sdl.fonts.bebasneue = TTF_OpenFont("fonts/bebas_neue/BebasNeue-Regular.ttf", 20);
init_ttf.c:	env->sdl.fonts.montserrat20 = TTF_OpenFont("fonts/montserrat/Montserrat-Regular.ttf", 20);
init_ttf.c:	env->sdl.fonts.playfair_display20 = TTF_OpenFont("fonts/playfair-display/PlayfairDisplay-Regular.ttf", 20);
init_weapons.c:	env->weapons[0].possessed = 1;
init_weapons.c:    env->weapons[0].weapon_switch = 0;
init_weapons.c:    env->weapons[0].first_sprite = 6;
init_weapons.c:    env->weapons[0].nb_sprites = 15;
init_weapons.c:    env->weapons[0].ammo = 20;
init_weapons.c:    env->weapons[0].no_ammo = 0;
init_weapons.c:    env->weapons[0].damage = 125;
init_weapons.c:    env->weapons[0].max_ammo = 20;
init_weapons.c:    env->weapons[0].splash = 1;
init_weapons.c:    env->weapons[0].range = 25;
init_weapons.c:	env->weapons[1].possessed = 1;
init_weapons.c:    env->weapons[1].first_sprite = 21;
init_weapons.c:    env->weapons[1].nb_sprites = 7;
init_weapons.c:    env->weapons[1].ammo = 40;
init_weapons.c:    env->weapons[1].damage = 25;
init_weapons.c:    env->weapons[1].max_ammo = 40;
init_weapons.c:    env->weapons[1].no_ammo = 0;
init_weapons.c:    env->weapons[1].range = 50;
init_weapons.c:    env->weapons[1].splash = 0;
inputs.c:	env->inputs.forward = 0;
inputs.c:	env->inputs.backward = 0;
inputs.c:	env->inputs.s = 0;
inputs.c:	env->inputs.left = 0;
inputs.c:	env->inputs.right = 0;
inputs.c:	env->inputs.plus = 0;
inputs.c:	env->inputs.minus = 0;
inputs.c:	env->inputs.shift = 0;
inputs.c:	env->inputs.ctrl = 0;
inputs.c:	env->inputs.space = 0;
inputs.c:	env->inputs.ctrl = 0;
inputs.c:	env->inputs.option = 0;
inputs.c:	env->inputs.left_click = 0;
inputs.c:	env->inputs.right_click = 0;
inputs.c:	env->inputs.enter = 0;
inputs.c:	env->inputs.up = 0;
inputs.c:	env->inputs.down = 0;
inputs.c:	env->inputs.tab = 0;
inputs.c:	if (env->button[nb].image == 30 || env->button[nb].image == 31)
inputs.c:		xmax = env->button[nb].x + 40;
inputs.c:		ymax = env->button[nb].y + 40;
inputs.c:		xmax = env->button[nb].x + 150;
inputs.c:		ymax = env->button[nb].y + 150;
inputs.c:	if ((env->sdl.mx >= env->button[nb].x
inputs.c:		&& env->sdl.mx <= xmax)
inputs.c:		&& (env->sdl.my >=  env->button[nb].y
inputs.c:		&& env->sdl.my <= ymax))
inputs.c:	if (env->sdl.event.key.keysym.sym == env->keys.forward
inputs.c:			|| env->sdl.event.key.keysym.sym == env->keys.forward2)
inputs.c:		env->inputs.forward = mode;
inputs.c:	if (env->sdl.event.key.keysym.sym == env->keys.s
inputs.c:			|| env->sdl.event.key.keysym.sym == env->keys.backward2)
inputs.c:		env->inputs.backward = mode;
inputs.c:	if (env->sdl.event.key.keysym.sym == env->keys.left
inputs.c:			|| env->sdl.event.key.keysym.sym == env->keys.left2)
inputs.c:		env->inputs.left = mode;
inputs.c:	if (env->sdl.event.key.keysym.sym == env->keys.right
inputs.c:			|| env->sdl.event.key.keysym.sym == env->keys.right2)
inputs.c:		env->inputs.right = mode;
inputs.c:	if (env->sdl.event.key.keysym.sym == env->keys.plus)
inputs.c:		env->inputs.plus = mode;
inputs.c:	if (env->sdl.event.key.keysym.sym == env->keys.minus)
inputs.c:		env->inputs.minus = mode;
inputs.c:	if (env->sdl.event.key.keysym.sym == env->keys.shift)
inputs.c:		env->inputs.shift = mode;
inputs.c:	if (env->sdl.event.key.keysym.sym == env->keys.space)
inputs.c:		env->inputs.space = mode;
inputs.c:	if (env->sdl.event.key.keysym.sym == env->keys.ctrl)
inputs.c:		env->inputs.ctrl = mode;
inputs.c:	if (env->sdl.event.key.keysym.sym == env->keys.up)
inputs.c:		env->inputs.up = mode;
inputs.c:	if (env->sdl.event.key.keysym.sym == env->keys.down)
inputs.c:		env->inputs.down = mode;
inputs.c:	if (env->sdl.event.key.keysym.sym == env->keys.option)
inputs.c:		env->inputs.option = mode;	
inputs.c:	if (env->sdl.event.button.button == SDL_BUTTON_LEFT)
inputs.c:		env->inputs.left_click = mode;
inputs.c:	if (env->sdl.event.button.button == SDL_BUTTON_RIGHT)
inputs.c:		env->inputs.right_click = mode;
inputs.c:	if (env->sdl.event.key.keysym.sym == env->keys.enter)
inputs.c:		env->inputs.enter = mode;
inputs.c:	if (env->sdl.event.key.keysym.sym == env->keys.s)
inputs.c:		env->inputs.s = mode;
inputs.c:	if (env->sdl.event.key.keysym.sym == env->keys.backspace)
inputs.c:		env->inputs.backspace = mode;
inputs.c:	if (env->sdl.event.key.keysym.sym == env->keys.del)
inputs.c:		env->inputs.del = mode;
inputs.c:	if (env->sdl.event.key.keysym.sym == env->keys.comma)
inputs.c:		env->inputs.comma = mode;
inputs.c:	if (env->sdl.event.key.keysym.sym == env->keys.period)
inputs.c:		env->inputs.period = mode;
inputs.c:	if (env->sdl.event.key.keysym.sym == env->keys.minus1)
inputs.c:		env->inputs.minus1 = mode;
inputs.c:	if (env->sdl.event.key.keysym.sym == env->keys.equals)
inputs.c:		env->inputs.equals = mode;
inputs.c:	if (env->sdl.event.key.keysym.sym == env->keys.p)
inputs.c:		env->inputs.p = mode;
inputs.c:	if (env->sdl.event.type == SDL_KEYDOWN)
inputs.c:	if (env->sdl.event.type == SDL_KEYUP)
inputs.c:	if (env->sdl.event.type == SDL_MOUSEBUTTONDOWN)
inputs.c:	if (env->sdl.event.type == SDL_MOUSEBUTTONUP)
interaction.c:	if (env->player.sector == -1)
interaction.c:	sector = env->sectors[env->player.sector];
interaction.c:	if ((sector.status == 1 || sector.status == 2 || env->elevator.on) && !env->elevator.off)
interaction.c:	else if (sector.status != 1 && env->elevator.off)
interaction.c:		env->elevator.off = 0;
interaction.c:	else if (env->sectors[env->player.sector].status == 3)
interactions_utils.c:			if (sector->floor != env->sectors[sector->neighbors[i]].floor)
interactions_utils.c:	sector = env->sectors[env->player.sector];
interactions_utils.c:			if (sector.floor != env->sectors[sector.neighbors[i]].floor)
interactions_utils.c:				sector.levels[j] = env->sectors[sector.neighbors[i]].floor;
interactions_utils.c:	sector.levels[j] = env->sectors[sector.neighbors[i]].floor;
interactions_utils.c:	env->sectors[env->player.sector] = sector;
is_in_sector.c:	if (sector < 0 || sector >= env->nb_sectors)
is_in_sector.c:	if (pos.z < get_floor_at_pos(env->sectors[sector], new_v2(pos.x, pos.y), env)
is_in_sector.c:			|| pos.z > get_ceiling_at_pos(env->sectors[sector], new_v2(pos.x, pos.y), env))
is_in_sector.c:	while (i < env->sectors[sector].nb_vertices)
is_in_sector.c:		end_pos = (env->sectors[sector].x_max + 1 - SECTOR_X1) * (SECTOR_Y2 - SECTOR_Y1) - (pos.y - SECTOR_Y1) * (SECTOR_X2 - SECTOR_X1);
is_in_sector.c:	if (sector < 0 || sector >= env->nb_sectors)
is_in_sector.c:	while (i < env->sectors[sector].nb_vertices)
is_in_sector.c:		end_pos = (env->sectors[sector].x_max + 1 - SECTOR_X1) * (SECTOR_Y2 - SECTOR_Y1) - (pos.y - SECTOR_Y1) * (SECTOR_X2 - SECTOR_X1);
is_new_vertex_valid.c:	tmp = env->editor.current_vertices;
is_new_vertex_valid.c:					new_v2(round((env->sdl.mx - env->editor.center.x) / env->editor.scale),
is_new_vertex_valid.c:						round((env->sdl.my - env->editor.center.y) / env->editor.scale))))
is_new_vertex_valid.c:		v1 = env->vertices[sector.vertices[i]];
is_new_vertex_valid.c:		v2 = env->vertices[sector.vertices[i + 1]];
is_new_vertex_valid.c:					new_v2(round((env->sdl.mx - env->editor.center.x) / env->editor.scale),
is_new_vertex_valid.c:						round((env->sdl.my - env->editor.center.y) / env->editor.scale)),
is_new_vertex_valid.c:	tmp = env->editor.current_vertices;
is_new_vertex_valid.c:	tmp = env->editor.current_vertices;
is_new_vertex_valid.c:	while (i < env->nb_sectors)
is_new_vertex_valid.c:		if (check_sector_intersections(env, env->sectors[i], *last, index))
is_new_vertex_valid.c:	while (i < env->sectors[sector].nb_vertices)
is_new_vertex_valid.c:		if (env->sectors[sector].vertices[i] == env->editor.selected_vertex)
is_new_vertex_valid.c:	ret = env->sectors[sector].vertices[i];
is_new_vertex_valid.c:		res = env->vertices[sector.vertices[sector.nb_vertices - 1]];
is_new_vertex_valid.c:		res = env->vertices[sector.vertices[i + new_index]];
is_new_vertex_valid.c:		while (j < env->nb_sectors)
is_new_vertex_valid.c:			last = find_second_vertex(env, env->sectors[list_sectors[i]], -1, index);
is_new_vertex_valid.c:			if (check_sector_intersections(env, env->sectors[j], last, index) == -1)
is_new_vertex_valid.c:			last = find_second_vertex(env, env->sectors[list_sectors[i]], 1, index);
is_new_vertex_valid.c:			if (check_sector_intersections(env, env->sectors[j], last, index) == -1)
is_new_vertex_valid.c:	if (!env->editor.current_vertices)
is_new_vertex_valid.c:	if (index != env->editor.start_vertex
keys.c:	if (!env->time.tick)
keys.c:		env->time.tick = SDL_GetTicks();
keys.c:	if (env->inputs.forward || env->inputs.backward || env->inputs.left
keys.c:			|| env->inputs.right)
keys.c:		Mix_PlayChannel(-1, env->sound.footstep, 0);
keys.c:	if ((((env->inputs.forward || env->inputs.backward || env->inputs.left
keys.c:			|| env->inputs.right || env->inputs.space || env->jump.on_going == 1
keys.c:			|| env->crouch.on_going || env->inputs.ctrl)
keys.c:			&& !env->editor.in_game && env->player.health > 0)
keys.c:			||  ((((env->selected_enemy == -1 && env->editor.tab)
keys.c:				|| (env->selected_enemy != -1 && !env->editor.tab))
keys.c:				|| (env->selected_enemy == -1 && !env->editor.tab))
keys.c:			&& (env->editor.in_game && !env->inputs.ctrl))
keys.c:			|| (env->player.state.climb || env->player.state.drop)))
keys.c:	if (env->inputs.plus && !env->inputs.shift
keys.c:			&& env->options.minimap_scale * 1.2 < 100)
keys.c:		env->options.minimap_scale *= 1.2;
keys.c:	if (env->inputs.minus && !env->inputs.shift
keys.c:			&& env->options.minimap_scale / 1.2 > 5)
keys.c:		env->options.minimap_scale /= 1.2;
keys.c:	if (env->editor.in_game && env->inputs.right_click)
keys.c:		env->editor.selected_wall = -1;
keys.c:		env->editor.selected_sector = -1;
keys.c:		env->selected_wall1 = -1;
keys.c:		env->selected_wall2 = -1;
keys.c:		env->selected_ceiling = -1;
keys.c:		env->selected_floor = -1;
keys.c:		env->selected_enemy = -1;
keys.c:	if (env->editor.tab && env->editor.in_game
keys.c:			&& env->editor.selected_wall != -1)
keys.c:		if (time - env->time.tick > 200)
keys.c:			env->time.tick = time;
keys.c:			if (env->inputs.down
keys.c:					&& env->sectors[env->editor.selected_sector].textures[env->editor.selected_wall] > -1)
keys.c:				env->sectors[env->editor.selected_sector].textures[env->editor.selected_wall]--;
keys.c:			else if (env->inputs.up
keys.c:					&& env->sectors[env->editor.selected_sector].textures[env->editor.selected_wall] < MAX_TEXTURE - 1)
keys.c:				env->sectors[env->editor.selected_sector].textures[env->editor.selected_wall]++;
keys.c:		if (env->inputs.comma)
keys.c:			if (env->inputs.shift && !env->inputs.ctrl)
keys.c:				env->sectors[env->editor.selected_sector].align[env->editor.selected_wall].y--;
keys.c:				env->sectors[env->editor.selected_sector].align[env->editor.selected_wall].x--;
keys.c:			else if (env->inputs.ctrl)
keys.c:				env->sectors[env->editor.selected_sector].align[env->editor.selected_wall].y--;
keys.c:				env->sectors[env->editor.selected_sector].align[env->editor.selected_wall].x--;
keys.c:		if (env->inputs.period)
keys.c:			if (env->inputs.shift && !env->inputs.ctrl)
keys.c:				env->sectors[env->editor.selected_sector].align[env->editor.selected_wall].y++;
keys.c:				env->sectors[env->editor.selected_sector].align[env->editor.selected_wall].x++;
keys.c:			else if (env->inputs.ctrl)
keys.c:				env->sectors[env->editor.selected_sector].align[env->editor.selected_wall].y++;
keys.c:				env->sectors[env->editor.selected_sector].align[env->editor.selected_wall].x++;
keys.c:		if (env->inputs.equals)
keys.c:			if (env->inputs.shift && !env->inputs.ctrl)
keys.c:				env->sectors[env->editor.selected_sector].scale[env->editor.selected_wall].y--;
keys.c:				env->sectors[env->editor.selected_sector].scale[env->editor.selected_wall].x--;
keys.c:			else if (env->inputs.ctrl)
keys.c:				env->sectors[env->editor.selected_sector].scale[env->editor.selected_wall].y--;
keys.c:				env->sectors[env->editor.selected_sector].scale[env->editor.selected_wall].x--;
keys.c:		if (env->inputs.minus1)
keys.c:			if (env->inputs.shift && !env->inputs.ctrl)
keys.c:				env->sectors[env->editor.selected_sector].scale[env->editor.selected_wall].y++;
keys.c:				env->sectors[env->editor.selected_sector].scale[env->editor.selected_wall].x++;
keys.c:			else if (env->inputs.ctrl)
keys.c:				env->sectors[env->editor.selected_sector].scale[env->editor.selected_wall].y++;
keys.c:				env->sectors[env->editor.selected_sector].scale[env->editor.selected_wall].x++;
keys.c:	if (env->editor.in_game && env->selected_ceiling != -1)
keys.c:		if (time - env->time.tick > 200)
keys.c:			env->time.tick = time;
keys.c:			if (env->inputs.down && env->editor.tab
keys.c:					&& env->sectors[env->selected_ceiling].ceiling_texture > -1)
keys.c:				env->sectors[env->selected_ceiling].ceiling_texture--;
keys.c:			else if (env->inputs.up && env->editor.tab
keys.c:					&& env->sectors[env->selected_ceiling].ceiling_texture < MAX_TEXTURE - 1)
keys.c:				env->sectors[env->selected_ceiling].ceiling_texture++;
keys.c:			if (env->sectors[env->selected_ceiling].ceiling_texture == -1)
keys.c:				env->sectors[env->selected_ceiling].skybox = 1;
keys.c:				env->sectors[env->selected_ceiling].ceiling_texture = 38;
keys.c:			else if (env->sectors[env->selected_ceiling].ceiling_texture != 38)
keys.c:				env->sectors[env->selected_ceiling].skybox = 0;
keys.c:		if (env->inputs.plus
keys.c:				&& env->sectors[env->selected_ceiling].ceiling > env->sectors[env->selected_ceiling].floor + 1)
keys.c:			env->sectors[env->selected_ceiling].ceiling += 0.05;
keys.c:		if (env->inputs.minus
keys.c:				&& env->sectors[env->selected_ceiling].ceiling)
keys.c:			env->sectors[env->selected_ceiling].ceiling -= 0.05;
keys.c:		update_sector_slope(env, &env->sectors[env->selected_ceiling]);
keys.c:		if (env->inputs.comma)
keys.c:			if (env->inputs.shift && !env->inputs.ctrl)
keys.c:				env->sectors[env->selected_ceiling].ceiling_align.y--;
keys.c:				env->sectors[env->selected_ceiling].ceiling_align.x--;
keys.c:			else if (env->inputs.ctrl)
keys.c:				env->sectors[env->selected_ceiling].ceiling_align.y--;
keys.c:				env->sectors[env->selected_ceiling].ceiling_align.x--;
keys.c:		if (env->inputs.period)
keys.c:			if (env->inputs.shift && !env->inputs.ctrl)
keys.c:				env->sectors[env->selected_ceiling].ceiling_align.y++;
keys.c:				env->sectors[env->selected_ceiling].ceiling_align.x++;
keys.c:			else if (env->inputs.ctrl)
keys.c:				env->sectors[env->selected_ceiling].ceiling_align.y++;
keys.c:				env->sectors[env->selected_ceiling].ceiling_align.x++;
keys.c:		if (env->inputs.equals)
keys.c:			if (env->inputs.shift && !env->inputs.ctrl)
keys.c:				env->sectors[env->selected_ceiling].ceiling_scale.y--;
keys.c:				env->sectors[env->selected_ceiling].ceiling_scale.x--;
keys.c:			else if (env->inputs.ctrl)
keys.c:				env->sectors[env->selected_ceiling].ceiling_scale.y--;
keys.c:				env->sectors[env->selected_ceiling].ceiling_scale.x--;
keys.c:		if (env->inputs.minus1)
keys.c:			if (env->inputs.shift && !env->inputs.ctrl)
keys.c:				env->sectors[env->selected_ceiling].ceiling_scale.y++;
keys.c:				env->sectors[env->selected_ceiling].ceiling_scale.x++;
keys.c:			else if (env->inputs.ctrl)
keys.c:				env->sectors[env->selected_ceiling].ceiling_scale.y++;
keys.c:				env->sectors[env->selected_ceiling].ceiling_scale.x++;
keys.c:	if (env->editor.in_game && env->selected_floor != -1)
keys.c:		if (time - env->time.tick > 200 && env->editor.tab)
keys.c:			env->time.tick = time;
keys.c:			if (env->inputs.down
keys.c:					&& env->sectors[env->selected_floor].floor_texture > 0)
keys.c:				env->sectors[env->selected_floor].floor_texture--;
keys.c:			if (env->inputs.up
keys.c:					&& env->sectors[env->selected_floor].floor_texture < MAX_TEXTURE - 1)
keys.c:				env->sectors[env->selected_floor].floor_texture++;
keys.c:		if (env->inputs.plus
keys.c:				&& env->sectors[env->selected_floor].floor < env->sectors[env->selected_floor].ceiling - 1)
keys.c:			env->sectors[env->selected_floor].floor += 0.05;
keys.c:		else if (env->inputs.minus)
keys.c:			env->sectors[env->selected_floor].floor -= 0.05;
keys.c:		update_sector_slope(env, &env->sectors[env->selected_floor]);
keys.c:		if (env->inputs.comma)
keys.c:			if (env->inputs.shift && !env->inputs.ctrl)
keys.c:				env->sectors[env->selected_floor].floor_align.y--;
keys.c:				env->sectors[env->selected_floor].floor_align.x--;
keys.c:			else if (env->inputs.ctrl)
keys.c:				env->sectors[env->selected_floor].floor_align.y--;
keys.c:				env->sectors[env->selected_floor].floor_align.x--;
keys.c:		if (env->inputs.period)
keys.c:			if (env->inputs.shift && !env->inputs.ctrl)
keys.c:				env->sectors[env->selected_floor].floor_align.y++;
keys.c:				env->sectors[env->selected_floor].floor_align.x++;
keys.c:			else if (env->inputs.ctrl)
keys.c:				env->sectors[env->selected_floor].floor_align.y++;
keys.c:				env->sectors[env->selected_floor].floor_align.x++;
keys.c:		if (env->inputs.equals)
keys.c:			if (env->inputs.shift && !env->inputs.ctrl)
keys.c:				env->sectors[env->selected_floor].floor_scale.y--;
keys.c:				env->sectors[env->selected_floor].floor_scale.x--;
keys.c:			else if (env->inputs.ctrl)
keys.c:				env->sectors[env->selected_floor].floor_scale.y--;
keys.c:				env->sectors[env->selected_floor].floor_scale.x--;
keys.c:		if (env->inputs.minus1)
keys.c:			if (env->inputs.shift && !env->inputs.ctrl)
keys.c:				env->sectors[env->selected_floor].floor_scale.y++;
keys.c:				env->sectors[env->selected_floor].floor_scale.x++;
keys.c:			else if (env->inputs.ctrl)
keys.c:				env->sectors[env->selected_floor].floor_scale.y++;
keys.c:				env->sectors[env->selected_floor].floor_scale.x++;
keys.c:	if (env->inputs.down && !env->inputs.shift && !env->editor.tab
keys.c:			&& env->editor.in_game && env->selected_ceiling != -1)
keys.c:		env->sectors[env->selected_ceiling].ceiling_slope -= 0.01;
keys.c:		update_sector_slope(env, &env->sectors[env->selected_ceiling]);
keys.c:	if (env->inputs.up && !env->inputs.shift && !env->editor.tab
keys.c:			&& env->editor.in_game && env->selected_ceiling != -1)
keys.c:		env->sectors[env->selected_ceiling].ceiling_slope += 0.01;
keys.c:		update_sector_slope(env, &env->sectors[env->selected_ceiling]);
keys.c:	if (env->selected_ceiling != -1 && env->sectors[env->selected_ceiling].ceiling_slope <= 0.02
keys.c:			&& env->sectors[env->selected_ceiling].ceiling_slope >= -0.02 && (!env->inputs.up && !env->inputs.down))
keys.c:		env->sectors[env->selected_ceiling].ceiling_slope = 0;
keys.c:	if (env->inputs.down && !env->inputs.shift && !env->editor.tab
keys.c:			&& env->editor.in_game && env->selected_floor != -1)
keys.c:		env->sectors[env->selected_floor].floor_slope -= 0.01;
keys.c:		update_sector_slope(env, &env->sectors[env->selected_floor]);
keys.c:	if (env->inputs.up && !env->inputs.shift && !env->editor.tab
keys.c:			&& env->editor.in_game && env->selected_floor != -1)
keys.c:		env->sectors[env->selected_floor].floor_slope += 0.01;
keys.c:		update_sector_slope(env, &env->sectors[env->selected_floor]);
keys.c:	if (env->selected_floor != -1 && env->sectors[env->selected_floor].floor_slope <= 0.02
keys.c:			&& env->sectors[env->selected_floor].floor_slope >= -0.02 && (!env->inputs.up && !env->inputs.down))
keys.c:		env->sectors[env->selected_floor].floor_slope = 0;
keys.c:	if (env->selected_floor != -1 && env->editor.in_game && env->inputs.ctrl)
keys.c:		if (!env->time.tick3)
keys.c:			env->time.tick3 = SDL_GetTicks();
keys.c:		if (env->inputs.left && time - env->time.tick3 > 250)
keys.c:			env->sectors[env->selected_floor] = rotate_vertices(env, 1, env->selected_floor);
keys.c:			env->time.tick3 = time;
keys.c:		else if (env->inputs.right && time - env->time.tick3 > 250)
keys.c:			env->sectors[env->selected_floor] = rotate_vertices(env, -1, env->selected_floor);
keys.c:			env->time.tick3 = time;
keys.c:		env->sectors[env->selected_floor].normal = get_sector_normal(env->sectors[env->selected_floor], env);
keys.c:		update_sector_slope(env, &env->sectors[env->selected_floor]);
keys.c:		while (i < env->nb_sectors)
keys.c:			create_portals(env, env->sectors[i]);
keys.c:	if (env->selected_ceiling != -1 && env->editor.in_game && env->inputs.ctrl)
keys.c:		if (!env->time.tick3)
keys.c:			env->time.tick3 = SDL_GetTicks();
keys.c:		if (env->inputs.left && time - env->time.tick3 > 250)
keys.c:			env->sectors[env->selected_ceiling] = rotate_vertices(env, 1, env->selected_ceiling);
keys.c:			env->time.tick3 = time;
keys.c:		else if (env->inputs.right && time - env->time.tick3 > 250)
keys.c:			env->sectors[env->selected_ceiling] = rotate_vertices(env, -1, env->selected_ceiling);
keys.c:			env->time.tick3 = time;
keys.c:		env->sectors[env->selected_ceiling].normal = get_sector_normal(env->sectors[env->selected_ceiling], env);
keys.c:		update_sector_slope(env, &env->sectors[env->selected_ceiling]);
keys.c:		while (i < env->nb_sectors)
keys.c:			create_portals(env, env->sectors[i]);
keys.c:	if (env->editor.tab && env->selected_enemy != -1 && env->editor.in_game)
keys.c:		if (!env->time.tick2)
keys.c:			env->time.tick2 = SDL_GetTicks();
keys.c:		if (env->inputs.backward && env->selected_stat < 3 && time - env->time.tick2 > 250)
keys.c:			env->time.tick2 = time;
keys.c:			env->selected_stat++;
keys.c:		else if (env->inputs.forward && env->selected_stat > 0 && time - env->time.tick2 > 250)
keys.c:			env->time.tick2 = time;
keys.c:			env->selected_stat--;
keys.c:		if (env->selected_enemy != -1)
keys.c:	if (env->inputs.right_click && !env->option)
keys.c:		//ft_printf("player pos %f, %f\n", env->player.pos.x, env->player.pos.y);
keys.c:		if (env->weapons[env->player.curr_weapon].ammo < env->weapons[env->player.curr_weapon].max_ammo)
keys.c:			env->weapons[env->player.curr_weapon].ammo++;
keyup.c:	env->screen_w[2] = 2560;
keyup.c:	env->screen_h[2] = 1440;
keyup.c:	env->screen_w[1] = 1920;
keyup.c:	env->screen_h[1] = 1080;
keyup.c:	env->screen_w[0] = 1600;
keyup.c:	env->screen_h[0] = 900;
keyup.c:	if (!(env->res[2] = ft_strdup("2560 x 1440")))
keyup.c:	if (!(env->res[1] = ft_strdup("1920 x 1080")))
keyup.c:	if (!(env->res[0] = ft_strdup("1600 x 900")))
keyup.c:	env->w = env->screen_w[env->i];
keyup.c:	env->h = env->screen_h[env->i];
keyup.c:	env->h_w = env->w / 2;
keyup.c:	env->h_h = env->h / 2;
keyup.c:	if (env->sdl.event.key.keysym.sym == SDLK_c)
keyup.c:		env->options.contouring = env->options.contouring ? 0 : 1;
keyup.c:	if (env->sdl.event.key.keysym.sym == SDLK_r)
keyup.c:	if (env->sdl.event.key.keysym.sym == SDLK_l)
keyup.c:		env->options.lighting = env->options.lighting ? 0 : 1;
keyup.c:	if (env->sdl.event.key.keysym.sym == SDLK_m)
keyup.c:		env->options.show_minimap = env->options.show_minimap ? 0 : 1;
keyup.c:	if (env->sdl.event.key.keysym.sym == SDLK_f)
keyup.c:		env->options.show_fps = env->options.show_fps ? 0 : 1;
keyup.c:	if (env->sdl.event.key.keysym.sym == SDLK_x)
keyup.c:		env->options.wall_lover = env->options.wall_lover ? 0 : 1;
keyup.c:	if (env->sdl.event.key.keysym.sym == SDLK_j)
keyup.c:		env->options.color_clipping = env->options.color_clipping ? 0 : 1;
keyup.c:	if (env->sdl.event.key.keysym.sym == SDLK_g)
keyup.c:		env->options.wall_color = env->options.wall_color ? 0 : 1;
keyup.c:	if (env->sdl.event.key.keysym.sym == SDLK_t)
keyup.c:		env->options.test = env->options.test ? 0 : 1;
keyup.c:	if (env->sdl.event.key.keysym.sym == SDLK_i)
keyup.c:		env->options.clipping = env->options.clipping ? 0 : 1;
keyup.c:	if (env->sdl.event.key.keysym.sym == SDLK_n)
keyup.c:		env->drawing = env->drawing ? 0 : 1;
keyup.c:	if (env->sdl.event.key.keysym.sym == SDLK_p)
keyup.c:		env->options.p = env->options.p ? 0 : 1;
keyup.c:	if (env->sdl.event.key.keysym.sym == SDLK_o)
keyup.c:		env->option = env->option ? 0 : 1;
keyup.c:		if (env->option)
keyup.c:		else if (env->player.health > 0)
keyup.c:	if (env->sdl.event.key.keysym.sym == SDLK_TAB)
keyup.c:		env->options.zbuffer = env->options.zbuffer ? 0 : 1;
keyup.c:	if (env->confirmation_box.state)
keyup.c:		confirmation_box_keyup_ig(&env->confirmation_box, env);
keyup.c:	add_button(env, 30, env->h_w - 40, env->h_h - 200, 2);
keyup.c:	add_button(env, 31, env->h_w + 160, env->h_h - 200, 3);
keyup.c:	print_text(new_point(env->h_h - 200, env->h_w - 250), new_printable_text("Resolution :", env->sdl.fonts.alice30, 0x960018FF, 30), env);
keyup.c:	print_text(new_point(env->h_h - 200 , env->h_w + 5), new_printable_text(env->res[env->i], env->sdl.fonts.alice30, 0x960018FF, 30), env);
keyup.c:	sound = ft_sitoa(env->sound.g_music);
keyup.c:	add_button(env, 30, env->h_w - 40, env->h_h - 100, 4);
keyup.c:	add_button(env, 31, env->h_w + 160, env->h_h - 100, 5);
keyup.c:	print_text(new_point(env->h_h - 100 , env->h_w - 250), new_printable_text("Sound :", env->sdl.fonts.alice30, 0x960018FF, 30), env);
keyup.c:	print_text(new_point(env->h_h - 100 , env->h_w + 65), new_printable_text(sound, env->sdl.fonts.alice30, 0x960018FF, 30), env);
keyup.c:	add_button(env, 0, env->h_w + 350, env->h_h + 350, 1);
keyup.c:	print_text(new_point(env->h / 4 - 100, env->h_w - 250), new_printable_text("PARAMETERS", env->sdl.fonts.alice70, 0x960018FF, 70), env);
keyup.c:	print_text(new_point(env->h_h + 350 , env->h_w + 350), new_printable_text("APPLIQUER", env->sdl.fonts.alice30, 0x960018FF, 30), env);
keyup.c:	print_text(new_point(env->h_h, env->h_w - 250), new_printable_text("Select menu :", env->sdl.fonts.alice30, 0x960018FF, 30), env);
keyup.c:	print_text(new_point(env->h_h, env->h_w + 65), new_printable_text("GO", env->sdl.fonts.alice30, 0x960018FF, 30), env);
keyup.c:	add_button(env, 0, env->h_w + 65, env->h_h, 7);
keyup.c:	if (env->sdl.event.button.button == SDL_BUTTON_LEFT && env->option)
keyup.c:		if (env->inputs.left_click
keyup.c:				&& env->i > 0)
keyup.c:			env->i--;
keyup.c:		else if (env->inputs.left_click
keyup.c:				&& env->i < 2)
keyup.c:			env->i++;
keyup.c:		else if (env->inputs.left_click
keyup.c:				&& env->sound.g_music > 5)
keyup.c:			env->sound.g_music -= 5;
keyup.c:		else if (env->inputs.left_click
keyup.c:				&& env->sound.g_music < 100)
keyup.c:			env->sound.g_music += 5;
keyup.c:		else if (env->inputs.left_click
keyup.c:			env->aplicate_changes = 1;
keyup.c:		env->inputs.left_click = 0;
keyup.c:	if (env->aplicate_changes)
keyup.c:		set_camera(&env->player.camera, env);
keyup.c:		env->inputs.left_click = 0;
keyup.c:		env->aplicate_changes = 0;
map_init_enemies.c:			env->nb_enemies = ft_atoi(line);
map_init_enemies.c:			if (env->nb_enemies < 0)
map_init_enemies.c:			if (env->nb_enemies
map_init_enemies.c:					&& !(env->enemies = (t_enemies*)malloc(sizeof(t_enemies)
map_init_enemies.c:							* (env->nb_enemies))))
map_init_objects.c:			env->nb_objects = ft_atoi(line);
map_init_objects.c:			if (env->nb_objects < 0)
map_init_objects.c:			if (env->nb_objects
map_init_objects.c:					&& !(env->objects = (t_object*)malloc(sizeof(t_object)
map_init_objects.c:							* (env->nb_objects))))
map_parse_enemies.c:	env->enemies[parser->enemies_count].health = ft_atoi(*line);
map_parse_enemies.c:	if (env->enemies[parser->enemies_count].health <= 0)
map_parse_enemies.c:	env->enemies[parser->enemies_count].speed = ft_atoi(*line);
map_parse_enemies.c:	if (env->enemies[parser->enemies_count].speed < 0 || env->enemies[parser->enemies_count].speed > 100)
map_parse_enemies.c:	env->enemies[parser->enemies_count].damage = ft_atoi(*line);
map_parse_enemies.c:	if (env->enemies[parser->enemies_count].damage <= 0)
map_parse_enemies.c:	env->enemies[parser->enemies_count].sprite = ft_atoi(*line);
map_parse_enemies.c:	if (env->enemies[parser->enemies_count].sprite < 0
map_parse_enemies.c:			|| env->enemies[parser->enemies_count].sprite >= MAX_SPRITES)
map_parse_enemies.c:	env->enemies[parser->enemies_count].scale = ft_atof(*line);
map_parse_enemies.c:	env->enemies[parser->enemies_count].pos.y = ft_atof(*line);
map_parse_enemies.c:	env->enemies[parser->enemies_count].pos.x = ft_atof(*line);
map_parse_enemies.c:	env->enemies[parser->enemies_count].pos.z = ft_atof(*line);
map_parse_enemies.c:	env->enemies[parser->enemies_count].angle = ft_atof(*line);
map_parse_enemies.c:	env->enemies[parser->enemies_count].sector = get_sector_no_z(env,
map_parse_enemies.c:			new_v3(env->enemies[parser->enemies_count].pos.x,
map_parse_enemies.c:				env->enemies[parser->enemies_count].pos.y,
map_parse_enemies.c:				env->enemies[parser->enemies_count].pos.z));
map_parse_enemies.c:	env->enemies[parser->enemies_count].brightness =
map_parse_enemies.c:		env->sectors[env->enemies[parser->enemies_count].sector].brightness;
map_parse_enemies.c:	env->enemies[parser->enemies_count].light_color =
map_parse_enemies.c:		env->sectors[env->enemies[parser->enemies_count].sector].light_color;
map_parse_enemies.c:	env->enemies[parser->enemies_count].num = parser->enemies_count;
map_parse_enemies.c:	while (parser->enemies_count < env->nb_enemies
map_parse_enemies.c:					env->nb_enemies - parser->enemies_count);
map_parse_objects.c:	env->objects[parser->objects_count].sprite = ft_atoi(*line);
map_parse_objects.c:	if (env->objects[parser->objects_count].sprite < 0
map_parse_objects.c:			|| env->objects[parser->objects_count].sprite >= MAX_SPRITES)
map_parse_objects.c:	env->objects[parser->objects_count].scale = ft_atof(*line);
map_parse_objects.c:	env->objects[parser->objects_count].pos.y = ft_atof(*line);
map_parse_objects.c:	env->objects[parser->objects_count].pos.x = ft_atof(*line);
map_parse_objects.c:	env->objects[parser->objects_count].pos.z = ft_atof(*line);
map_parse_objects.c:	env->objects[parser->objects_count].angle = ft_atof(*line);
map_parse_objects.c:	env->objects[parser->objects_count].sector = get_sector_global(env,
map_parse_objects.c:			new_v3(env->objects[parser->objects_count].pos.x,
map_parse_objects.c:				env->objects[parser->objects_count].pos.y,
map_parse_objects.c:				env->objects[parser->objects_count].pos.z));
map_parse_objects.c:	env->objects[parser->objects_count].brightness =
map_parse_objects.c:		env->sectors[env->objects[parser->objects_count].sector].brightness;
map_parse_objects.c:	env->objects[parser->objects_count].light_color =
map_parse_objects.c:		env->sectors[env->objects[parser->objects_count].sector].light_color;
map_parse_objects.c:	env->objects[parser->objects_count].num = parser->objects_count;
map_parse_objects.c:	while (parser->objects_count < env->nb_objects
map_parse_objects.c:					env->nb_objects - parser->objects_count);
map_parse_player.c:			env->player.pos.y = ft_atof(line);
map_parse_player.c:			env->player.pos.x = ft_atof(line);
map_parse_player.c:			env->player.camera.angle = (ft_atof(line) + 0.00001) * CONVERT_RADIANS;
map_parse_player.c:			env->player.camera.angle_cos = cos(env->player.camera.angle);
map_parse_player.c:			env->player.camera.angle_sin = sin(env->player.camera.angle);
map_parse_player.c:			env->player.camera.perp_cos = cos(env->player.camera.angle - M_PI / 2);
map_parse_player.c:			env->player.camera.perp_sin = sin(env->player.camera.angle - M_PI / 2);
map_parse_player.c:			env->editor.new_player = 1;
map_parse_player.c:			if ((env->player.sector = get_sector_no_z(env,
map_parse_player.c:							env->player.pos)) == -1)
map_parse_player.c:			env->player.highest_sect = env->player.sector;
map_parse_player.c:			env->player.lowest_sect = env->player.sector;
map_parse_player.c:			env->player.camera.pos = env->player.pos;
map_parse_player.c:			env->player.camera.pos.z = env->player.pos.z + 8;
map_parse_sectors.c:	env->sectors[parser->sectors_count].floor = ft_atof(*line);
map_parse_sectors.c:	env->sectors[parser->sectors_count].floor_min = env->sectors[parser->
map_parse_sectors.c:	env->sectors[parser->sectors_count].floor_max = env->sectors[parser->
map_parse_sectors.c:		env->sectors[parser->sectors_count].floor_slope = ft_atof(*line);// * CONVERT_RADIANS;
map_parse_sectors.c:/*	if (env->sectors[parser->sectors_count].floor_slope > 45
map_parse_sectors.c:			|| env->sectors[parser->sectors_count].floor_slope < -45)
map_parse_sectors.c:	//	env->sectors[parser->sectors_count].floor_slope = env->
map_parse_sectors.c:	env->sectors[parser->sectors_count].floor_texture = ft_atoi(*line);
map_parse_sectors.c:	if (env->sectors[parser->sectors_count].floor_texture < 0
map_parse_sectors.c:			|| env->sectors[parser->sectors_count].floor_texture >= MAX_TEXTURE)
map_parse_sectors.c:	env->sectors[parser->sectors_count].floor_scale.x = env->textures[env->sectors[parser->sectors_count].floor_texture].surface->w / 10;
map_parse_sectors.c:	env->sectors[parser->sectors_count].floor_scale.y = env->textures[env->sectors[parser->sectors_count].floor_texture].surface->h / 10;
map_parse_sectors.c:	env->sectors[parser->sectors_count].floor_align = new_v2(0, 0);
map_parse_sectors.c:	env->sectors[parser->sectors_count].ceiling = ft_atof(*line);
map_parse_sectors.c:	env->sectors[parser->sectors_count].ceiling_min = env->sectors[parser->
map_parse_sectors.c:	env->sectors[parser->sectors_count].ceiling_max = env->sectors[parser->
map_parse_sectors.c:	env->sectors[parser->sectors_count].ceiling_slope = ft_atof(*line) * CONVERT_RADIANS;
map_parse_sectors.c:	if (env->sectors[parser->sectors_count].ceiling_slope > 45
map_parse_sectors.c:			|| env->sectors[parser->sectors_count].ceiling_slope < -45)
map_parse_sectors.c:	env->sectors[parser->sectors_count].ceiling_slope = tan(env->
map_parse_sectors.c:	env->sectors[parser->sectors_count].ceiling_texture = ft_atoi(*line);
map_parse_sectors.c:	if (env->sectors[parser->sectors_count].ceiling_texture < -1 || env->
map_parse_sectors.c:	env->sectors[parser->sectors_count].skybox = 0;
map_parse_sectors.c:	if (env->sectors[parser->sectors_count].ceiling_texture == -1)
map_parse_sectors.c:		env->sectors[parser->sectors_count].skybox = 1;
map_parse_sectors.c:		env->sectors[parser->sectors_count].ceiling_texture = 38;
map_parse_sectors.c:	env->sectors[parser->sectors_count].ceiling_scale.x = env->textures[env->sectors[parser->sectors_count].ceiling_texture].surface->w / 10;
map_parse_sectors.c:	env->sectors[parser->sectors_count].ceiling_scale.y = env->textures[env->sectors[parser->sectors_count].ceiling_texture].surface->h / 10;
map_parse_sectors.c:	env->sectors[parser->sectors_count].ceiling_align = new_v2(0, 0);
map_parse_sectors.c:	env->sectors[parser->sectors_count].nb_vertices = parser->
map_parse_sectors.c:	if (!(env->sectors[parser->sectors_count].vertices = (short*)
map_parse_sectors.c:	if (!(env->sectors[parser->sectors_count].neighbors = (short*)
map_parse_sectors.c:	if (!(env->sectors[parser->sectors_count].textures = (short*)
map_parse_sectors.c:	if (!(env->sectors[parser->sectors_count].sprites = (t_wall_sprites*)
map_parse_sectors.c:	if (!(env->sectors[parser->sectors_count].align = (t_v2*)
map_parse_sectors.c:	if (!(env->sectors[parser->sectors_count].scale = (t_v2*)
map_parse_sectors.c:	if (!(env->sectors[parser->sectors_count].ceilings = (double*)
map_parse_sectors.c:	if (!(env->sectors[parser->sectors_count].floors = (double*)
map_parse_sectors.c:	if (!(env->sectors[parser->sectors_count].clipped_ceilings1 = (double*)
map_parse_sectors.c:	if (!(env->sectors[parser->sectors_count].clipped_floors1 = (double*)
map_parse_sectors.c:	if (!(env->sectors[parser->sectors_count].clipped_ceilings2 = (double*)
map_parse_sectors.c:	if (!(env->sectors[parser->sectors_count].clipped_floors2 = (double*)
map_parse_sectors.c:	if (!(env->sectors[parser->sectors_count].wall_width = (double*)
map_parse_sectors.c:	if (!(env->sectors[parser->sectors_count].selected = (short*)
map_parse_sectors.c:	if (!(env->sectors[parser->sectors_count].nb_sprites = (short*)
map_parse_sectors.c:	if (!(env->sectors[parser->sectors_count].xmin = (int*)
map_parse_sectors.c:				malloc(sizeof(int) * (env->h))))
map_parse_sectors.c:	if (!(env->sectors[parser->sectors_count].xmax = (int*)
map_parse_sectors.c:				malloc(sizeof(int) * (env->h))))
map_parse_sectors.c:		env->sectors[parser->sectors_count].vertices[i] = ft_atoi(*line);
map_parse_sectors.c:		if (env->sectors[parser->sectors_count].vertices[i] < 0 || env->
map_parse_sectors.c:				sectors[parser->sectors_count].vertices[i] >= env->nb_vertices)
map_parse_sectors.c:					env->sectors[parser->sectors_count].vertices[i],
map_parse_sectors.c:	env->sectors[parser->sectors_count].vertices[parser->sector_vertices_count]
map_parse_sectors.c:		= env->sectors[parser->sectors_count].vertices[0];
map_parse_sectors.c:	if (check_vertices_uniqueness(env->sectors[parser->sectors_count]))
map_parse_sectors.c:	if (check_sector_duplicate(env, env->sectors[parser->sectors_count],
map_parse_sectors.c:		env->sectors[parser->sectors_count].neighbors[i] = ft_atoi(*line);
map_parse_sectors.c:		if (env->sectors[parser->sectors_count].neighbors[i] < -1 || env->
map_parse_sectors.c:				sectors[parser->sectors_count].neighbors[i] >= env->nb_sectors)
map_parse_sectors.c:					env->sectors[parser->sectors_count].neighbors[i],
map_parse_sectors.c:		if (env->sectors[parser->sectors_count].neighbors[i] == parser->sectors_count)
map_parse_sectors.c:		env->sectors[parser->sectors_count].textures[i] = ft_atoi(*line);
map_parse_sectors.c:		if (env->sectors[parser->sectors_count].textures[i] < -1 || env->sectors[parser->sectors_count].textures[i] >= MAX_TEXTURE)
map_parse_sectors.c:					env->sectors[parser->sectors_count].textures[i],
map_parse_sectors.c:		env->sectors[parser->sectors_count].align[i] = new_v2(0, 0);
map_parse_sectors.c:		if (env->sectors[parser->sectors_count].textures[i] == -1)
map_parse_sectors.c:			env->sectors[parser->sectors_count].scale[i] = new_v2(
map_parse_sectors.c:					env->textures[38].surface->w,
map_parse_sectors.c:					env->textures[38].surface->h / 10);
map_parse_sectors.c:			env->sectors[parser->sectors_count].scale[i] = new_v2(
map_parse_sectors.c:					env->textures[env->sectors[parser->sectors_count].textures[i]].surface->w,
map_parse_sectors.c:					env->textures[env->sectors[parser->sectors_count].textures[i]].surface->h);
map_parse_sectors.c:		env->sectors[parser->sectors_count].align[i].x = ft_atof(*line);
map_parse_sectors.c:		env->sectors[parser->sectors_count].align[i].y = ft_atof(*line);
map_parse_sectors.c:		env->sectors[parser->sectors_count].scale[i].x = ft_atof(*line);
map_parse_sectors.c:		if (env->sectors[parser->sectors_count].scale[i].x <= 0)
map_parse_sectors.c:		env->sectors[parser->sectors_count].scale[i].y = ft_atof(*line);
map_parse_sectors.c:		if (env->sectors[parser->sectors_count].scale[i].y <= 0)
map_parse_sectors.c:		env->sectors[parser->sectors_count].textures[i] = ft_atoi(*line);
map_parse_sectors.c:		if (env->sectors[parser->sectors_count].textures[i] < -1 || env->sectors[parser->sectors_count].textures[i] >= MAX_TEXTURE)
map_parse_sectors.c:					env->sectors[parser->sectors_count].textures[i],
map_parse_sectors.c:		env->sectors[parser->sectors_count].align[i] = new_v2(0, 0);
map_parse_sectors.c:		if (env->sectors[parser->sectors_count].textures[i] == -1)
map_parse_sectors.c:			env->sectors[parser->sectors_count].scale[i] = new_v2(
map_parse_sectors.c:					env->textures[38].surface->w,
map_parse_sectors.c:					env->textures[38].surface->h / 10);
map_parse_sectors.c:			env->sectors[parser->sectors_count].scale[i] = new_v2(
map_parse_sectors.c:					env->textures[env->sectors[parser->sectors_count].textures[i]].surface->w,
map_parse_sectors.c:					env->textures[env->sectors[parser->sectors_count].textures[i]].surface->h);
map_parse_sectors.c:		if ((env->sectors[parser->sectors_count].nb_sprites[i] = count_wall_sprites(*line, parser)) == -1)
map_parse_sectors.c:		if (!(env->sectors[parser->sectors_count].sprites[i].sprite = (short*)malloc(sizeof(short) * env->sectors[parser->sectors_count].nb_sprites[i])))
map_parse_sectors.c:		if (!(env->sectors[parser->sectors_count].sprites[i].pos = (t_v2*)malloc(sizeof(t_v2) * env->sectors[parser->sectors_count].nb_sprites[i])))
map_parse_sectors.c:		if (!(env->sectors[parser->sectors_count].sprites[i].scale = (t_v2*)malloc(sizeof(t_v2) * env->sectors[parser->sectors_count].nb_sprites[i])))
map_parse_sectors.c:		while (j < env->sectors[parser->sectors_count].nb_sprites[i])
map_parse_sectors.c:			env->sectors[parser->sectors_count].sprites[i].sprite[j] = ft_atoi(*line);
map_parse_sectors.c:			if (env->sectors[parser->sectors_count].sprites[i].sprite[j] < -1
map_parse_sectors.c:					|| env->sectors[parser->sectors_count].sprites[i].sprite[j] > MAX_SPRITES)
map_parse_sectors.c:			env->sectors[parser->sectors_count].sprites[i].pos[j].x = ft_atof(*line);
map_parse_sectors.c:			env->sectors[parser->sectors_count].sprites[i].pos[j].y = ft_atof(*line);
map_parse_sectors.c:			env->sectors[parser->sectors_count].sprites[i].scale[j].x = ft_atof(*line);
map_parse_sectors.c:			if (env->sectors[parser->sectors_count].sprites[i].scale[j].x <= 0)
map_parse_sectors.c:			env->sectors[parser->sectors_count].sprites[i].scale[j].y = ft_atof(*line);
map_parse_sectors.c:			if (env->sectors[parser->sectors_count].sprites[i].scale[j].y <= 0)
map_parse_sectors.c:		/*env->sectors[parser->sectors_count].nb_sprites[i] = 1;
map_parse_sectors.c:		if (!(env->sectors[parser->sectors_count].sprites[i].sprite = (short*)malloc(sizeof(short) * env->sectors[parser->sectors_count].nb_sprites[i])))
map_parse_sectors.c:		if (!(env->sectors[parser->sectors_count].sprites[i].pos = (t_v2*)malloc(sizeof(t_v2) * env->sectors[parser->sectors_count].nb_sprites[i])))
map_parse_sectors.c:		if (!(env->sectors[parser->sectors_count].sprites[i].scale = (t_v2*)malloc(sizeof(t_v2) * env->sectors[parser->sectors_count].nb_sprites[i])))
map_parse_sectors.c:		while (j < env->sectors[parser->sectors_count].nb_sprites[i])
map_parse_sectors.c:			env->sectors[parser->sectors_count].sprites[i].sprite[j] = ft_atoi(*line);
map_parse_sectors.c:			if (env->sectors[parser->sectors_count].sprites[i].sprite[j] < -1
map_parse_sectors.c:					|| env->sectors[parser->sectors_count].sprites[i].sprite[j] > MAX_SPRITES)
map_parse_sectors.c:			env->sectors[parser->sectors_count].sprites[i].pos[j].x = ft_atof(*line);
map_parse_sectors.c:			env->sectors[parser->sectors_count].sprites[i].pos[j].y = ft_atof(*line);
map_parse_sectors.c:			env->sectors[parser->sectors_count].sprites[i].scale[j].x = ft_atof(*line);
map_parse_sectors.c:			if (env->sectors[parser->sectors_count].sprites[i].scale[j].x <= 0)
map_parse_sectors.c:			env->sectors[parser->sectors_count].sprites[i].scale[j].y = ft_atof(*line);
map_parse_sectors.c:			if (env->sectors[parser->sectors_count].sprites[i].scale[j].y <= 0)
map_parse_sectors.c:	env->sectors[parser->sectors_count].brightness = ft_atoi(*line);
map_parse_sectors.c:	env->sectors[parser->sectors_count].light_color = 0xFFFFFFFF;
map_parse_sectors.c:	if (env->sectors[parser->sectors_count].brightness < -255 ||
map_parse_sectors.c:			env->sectors[parser->sectors_count].brightness > 255)
map_parse_sectors.c:	env->sectors[parser->sectors_count].brightness = ft_atoi(*line);
map_parse_sectors.c:	env->sectors[parser->sectors_count].light_color = 0xFFFFFFFF;
map_parse_sectors.c:	if (env->sectors[parser->sectors_count].brightness < -255 ||
map_parse_sectors.c:			env->sectors[parser->sectors_count].brightness > 255)
map_parse_sectors.c:	env->sectors[parser->sectors_count].status = ft_atoi(*line);
map_parse_sectors.c:	if (env->sectors[parser->sectors_count].status > 3 ||
map_parse_sectors.c:			env->sectors[parser->sectors_count].status < 0)
map_parse_sectors.c:	env->sectors[parser->sectors_count].tp.x = ft_atoi(*line);
map_parse_sectors.c:	env->sectors[parser->sectors_count].tp.y = ft_atoi(*line);
map_parse_sectors.c:	env->sectors[parser->sectors_count].sprite_time = 0;
map_parse_sectors.c:	env->sectors[parser->sectors_count].num = parser->sectors_count;
map_parse_sectors.c:	if (env->sectors[parser->sectors_count].ceiling
map_parse_sectors.c:			<= env->sectors[parser->sectors_count].floor)
map_parse_sectors.c:	while (parser->sectors_count < env->nb_sectors
map_parse_sectors.c:					env->nb_sectors - parser->sectors_count);
map_parse_sectors_utils.c:		if (sector_eq(sector, env->sectors[i]))
map_parse_vertices.c:		if (vertex.x == env->vertices[i].x && vertex.y == env->vertices[i].y)
map_parse_vertices.c:	env->vertices[parser->vertices_count].num = parser->vertices_count;
map_parse_vertices.c:	env->vertices[parser->vertices_count].y = ft_atof(line);
map_parse_vertices.c:	env->vertices[parser->vertices_count].x = ft_atof(line);
map_parse_vertices.c:	if (check_vertex_duplicate(env, env->vertices[parser->vertices_count],
map_parse_vertices.c:	while (parser->vertices_count < env->nb_vertices
map_parse_vertices.c:					env->nb_vertices - parser->vertices_count);
map_parser.c:			env->nb_vertices = ft_atoi(line);
map_parser.c:			if (env->nb_vertices < 3)
map_parser.c:			if (!(env->vertices = (t_vertex *)malloc(sizeof(t_vertex)
map_parser.c:							* (env->nb_vertices))))
map_parser.c:			env->nb_sectors = atoi(line);
map_parser.c:			env->screen_sectors_size = ft_min(env->nb_sectors, env->w);
map_parser.c:			if (env->nb_sectors < 1)
map_parser.c:			if (!(env->sectors = (t_sector *)malloc(sizeof(t_sector)
map_parser.c:							* env->nb_sectors)))
map_parser.c:			while (i < env->nb_sectors)
map_parser.c:				ft_bzero(&env->sectors[i], sizeof(t_sector));
map_parser.c:				env->sectors[i].x_max = -2147483648;
map_parser.c:	while (i < env->nb_sectors)
map_parser.c:		while (j < env->sectors[i].nb_vertices)
map_parser.c:			if (env->sectors[i].x_max
map_parser.c:					< env->vertices[env->sectors[i].vertices[j]].x)
map_parser.c:				env->sectors[i].x_max =
map_parser.c:					env->vertices[env->sectors[i].vertices[j]].x;
map_parser.c:	env->player.eyesight = 6;
map_parser.c:	env->player.size_2d = 0.75;
map_parser.c:	env->player.sector = -1;
map_parser.c:	env->player.camera.angle_z_cos = cos(0);
map_parser.c:	env->player.camera.angle_z_sin = sin(0);
map_parser.c:	env->player.speed = 0.5;
map_parser.c:	env->player.pos.z = 0;
map_parser.c:	env->player.health = 100;
map_parser.c:	env->player.killed = 0;
map_parser.c:	env->player.touched = 0;
map_parser.c:	env->player.nb_shots = 0;
map_parser.c:	env->player.accuracy = 0;
map_parser.c:	env->player.size_2d = 0.75;
map_parser.c:	env->player.velocity = 0;
map_parser.c:	env->player.acceleration = 0;
map_parser.c:	env->player.drop_flag = 0;
map_parser.c:	env->gravity.velocity = 0;
map_parser.c:	env->gravity.acceleration = 0;
map_parser.c:	env->player.state.drop = 0;
map_parser.c:	env->player.state.fall = 0;
map_parser.c:	env->player.state.climb = 0;
map_parser.c:	env->player.state.jump = 0;
map_parser.c:	env->player.state.crouch = 0;
map_parser.c:	env->player.state.walk = 0;
map_parser.c:	env->nb_sectors = 0;
map_parser.c:	env->nb_vertices = 0;
map_parser.c:	if (env->player.sector == -1)
menu_tools.c:	while (xx < env->textures[i].surface->w && xx < env->w)
menu_tools.c:		while (yy < env->textures[i].surface->h && yy < env->h)
menu_tools.c:			if (env->textures[i].str[xx + env->textures[i].surface->w * yy] != 0xFFC10099)
menu_tools.c:				env->sdl.texture_pixels[(x + (y * env->w)) + xx + env->w * yy] = env->textures[i].str[xx + env->textures[i].surface->w * yy];
menu_tools.c:	env->button[ref_but].x = x;
menu_tools.c:	env->button[ref_but].y = y;
menu_tools.c:	env->button[ref_but].image = text;
menu_tools.c:	env->button[ref_but].id = ref_but;
minimap.c:	pixels = env->sdl.texture_pixels;
minimap.c:	if (x >= env->w - 300 && x < env->w && y >= 0 && y <= 300)
minimap.c:		if (color == 0xFFFF0000 || (pixels[x + env->w * y] != 0xFF00FF00
minimap.c:			&& pixels[x + env->w * y] != 0xFFFFFFF))
minimap.c:			if (x >= 0 && x < env->w && y >= 0 && y <= env->h)
minimap.c:				pixels[x + env->w * y] = color;
minimap.c:	start = new_point(env->w - 150, 150);
minimap.c:	x = env->w - 152;
minimap.c:	while (x < env->w - 147)
minimap.c:			(env->player.camera.near_left_pos.x - env->player.pos.x) * env->options.minimap_scale + start.x,
minimap.c:			(env->player.camera.near_left_pos.y - env->player.pos.y) * env->options.minimap_scale + 150,
minimap.c:			(env->player.camera.angle_cos * env->player.camera.far_z - env->player.camera.angle_sin * env->player.camera.far_left) * env->options.minimap_scale + start.x,
minimap.c:			(env->player.camera.angle_sin * env->player.camera.far_z + env->player.camera.angle_cos * env->player.camera.far_left) * env->options.minimap_scale + 150,
minimap.c:			(env->player.camera.near_right_pos.x - env->player.pos.x) * env->options.minimap_scale + start.x,
minimap.c:			(env->player.camera.near_right_pos.y - env->player.pos.y) * env->options.minimap_scale + 150,
minimap.c:	if (!env->options.test)
minimap.c:			(env->player.camera.angle_cos * env->player.camera.far_z - env->player.camera.angle_sin * env->player.camera.far_right) * env->options.minimap_scale + start.x,
minimap.c:			(env->player.camera.angle_sin * env->player.camera.far_z + env->player.camera.angle_cos * env->player.camera.far_right) * env->options.minimap_scale + 150,
minimap.c:	p0.x = env->player.camera.angle_cos * env->player.camera.near_z * env->options.minimap_scale + start.x;
minimap.c:	p0.y = env->player.camera.angle_sin * env->player.camera.near_z * env->options.minimap_scale + 150;
minimap.c:	p1.x = p0.x + env->player.camera.perp_cos * env->w * env->options.minimap_scale;
minimap.c:	p1.y = p0.y + env->player.camera.perp_sin * env->w * env->options.minimap_scale;
minimap.c:	p0.x = p0.x - env->player.camera.perp_cos * env->w * env->options.minimap_scale;
minimap.c:	p0.y = p0.y - env->player.camera.perp_sin * env->w * env->options.minimap_scale;
minimap.c:	if (env->options.test)
minimap.c:	p1.x = env->player.camera.angle_cos * env->player.camera.near_z * env->options.minimap_scale + p0.x;
minimap.c:	p1.y = env->player.camera.angle_sin * env->player.camera.near_z * env->options.minimap_scale + p0.y;
minimap.c:	max = env->w;
minimap.c:	if (sector.num == env->player.sector)
minimap.c:	start = new_point(env->w - 150, 150);
minimap.c:		pos.x += start.x + (env->vertices[sector.vertices[i]].x - env->player.pos.x) * env->options.minimap_scale;
minimap.c:		pos.y += start.y + (env->vertices[sector.vertices[i]].y - env->player.pos.y) * env->options.minimap_scale;
minimap.c:	if (pos.x > env->w - 297 && pos.x < env->w && pos.y <= 295 && pos.y >= 0)
minimap.c:					env->sdl.fonts.bebasneue,
minimap.c:	pixels = env->sdl.texture_pixels;
minimap.c:	while (++i < env->nb_objects)
minimap.c:		object = env->objects[i];
minimap.c:		pos.x = env->w - 150 + (object.pos.x - env->player.pos.x) * env->options.minimap_scale;
minimap.c:			pos.y = 150 + (object.pos.y - env->player.pos.y) * env->options.minimap_scale;
minimap.c:				if (x > env->w - 300 && x < env->w && y >= 0 && y < 300)
minimap.c:					pixels[x + y * env->w] = 0xFFFF0000;
minimap.c:	start.x = env->w - 150;
minimap.c:	while (s < env->nb_sectors)
minimap.c:		sect = env->sectors[s];
minimap.c:		if (env->player.head_z > sect.floor_min
minimap.c:				&& env->player.head_z < sect.ceiling_max)
minimap.c:			if (s == env->player.sector)
minimap.c:				line.p0.x = start.x + (env->vertices[sect.vertices[v]].x - env->player.pos.x) * env->options.minimap_scale;
minimap.c:				line.p0.y = start.y + (env->vertices[sect.vertices[v]].y - env->player.pos.y) * env->options.minimap_scale;
minimap.c:				line.p1.x = start.x + (env->vertices[sect.vertices[v + 1]].x - env->player.pos.x) * env->options.minimap_scale;
minimap.c:				line.p1.y = start.y + (env->vertices[sect.vertices[v + 1]].y - env->player.pos.y) * env->options.minimap_scale;
minimap.c:	while (i < env->nb_enemies)
minimap.c:		enemy_start.x = env->w - 150 + (env->enemies[i].pos.x - env->player.pos.x) * env->options.minimap_scale;
minimap.c:		enemy_start.y = 150 + (env->enemies[i].pos.y - env->player.pos.y) * env->options.minimap_scale;
minimap.c:		enemy_end.x = enemy_start.x + 500*cos(env->enemies[i].angle * CONVERT_RADIANS);
minimap.c:		enemy_end.y = enemy_start.y + 500*sin(env->enemies[i].angle * CONVERT_RADIANS);
minimap.c:		enemy_end.x = enemy_start.x + 500*cos(env->enemies[i].angle * CONVERT_RADIANS - 24.5);
minimap.c:		enemy_end.y = enemy_start.y + 500*sin(env->enemies[i].angle * CONVERT_RADIANS - 24.5);
minimap.c:		enemy_end.x = enemy_start.x + 500*cos(env->enemies[i].angle * CONVERT_RADIANS + 24.5);
minimap.c:		enemy_end.y = enemy_start.y + 500*sin(env->enemies[i].angle * CONVERT_RADIANS + 24.5);
misc_utils.c:    while (i < env->nb_sectors)
misc_utils.c:            env->sector_list[i] = 1;
misc_utils.c:            env->sector_list[i] = 0;
movement.c:	pos.x = env->player.pos.x;
movement.c:	pos.y = env->player.pos.y;
movement.c:	slope = get_floor_at_pos(env->sectors[env->player.highest_sect], pos, env);
movement.c:	if ((env->player.pos.z > slope || env->player.state.fall || env->player.state.jump)
movement.c:	&& !env->player.state.climb && !env->player.state.drop)
movement.c:	if ((env->inputs.space || env->player.state.jump)
movement.c:			&& !env->player.state.climb && !env->player.state.drop)
movement.c:	if (!env->player.state.jump && !env->player.state.fall
movement.c:			&& !env->player.state.climb && !env->player.state.drop)
movement.c:	if (((env->inputs.ctrl&& env->player.eyesight > 3)
movement.c:	|| env->player.state.crouch) && !env->editor.in_game)
movement.c:	env->player.camera.pos.z = env->player.head_z;
movement.c:		move = check_collision(env, new_v2(env->player.camera.angle_cos * env->player.speed, env->player.camera.angle_sin * env->player.speed), motion, 0);
movement.c:		move = check_collision(env, new_v2(env->player.camera.angle_cos * -env->player.speed, env->player.camera.angle_sin * -env->player.speed), motion, 0);
movement.c:		move = check_collision(env, new_v2(env->player.camera.angle_sin * env->player.speed, env->player.camera.angle_cos * -env->player.speed), motion, 0);
movement.c:		move = check_collision(env, new_v2(env->player.camera.angle_sin * -env->player.speed, env->player.camera.angle_cos * env->player.speed), motion, 0);
movement.c:		env->player.stuck = 1;
movement.c:	pos.x = env->player.pos.x;
movement.c:	pos.y = env->player.pos.y;
movement.c:	if (env->player.sector >= 0)
movement.c:		env->player.old_pos.x = pos.x;
movement.c:		env->player.old_pos.y = pos.y;
movement.c:	prev_sector = env->player.sector;
movement.c:	env->time.end = env->time.milli_s / 10;
movement.c:	if (env->time.end - env->time.start >= 1)
movement.c:		env->time.start = env->time.end;
movement.c:		motion = new_movement(env->player.sector, env->player.size_2d, env->player.eyesight, env->player.pos);
movement.c:		if (env->inputs.forward && !env->inputs.backward)
movement.c:			move = check_collision(env, new_v2(env->player.camera.angle_cos * env->player.speed, env->player.camera.angle_sin * env->player.speed), motion, 0);
movement.c:			env->player.pos.x += move.x;
movement.c:			env->player.pos.y += move.y;
movement.c:		else if (env->inputs.backward && !env->inputs.forward)
movement.c:			move = check_collision(env, new_v2(env->player.camera.angle_cos * -env->player.speed, env->player.camera.angle_sin * -env->player.speed), motion, 0);
movement.c:			env->player.pos.x += move.x;
movement.c:			env->player.pos.y += move.y;
movement.c:		if (env->inputs.left && !env->inputs.right)
movement.c:			move = check_collision(env, new_v2(env->player.camera.angle_sin * env->player.speed, env->player.camera.angle_cos * -env->player.speed), motion, 0);
movement.c:			env->player.pos.x += move.x;
movement.c:			env->player.pos.y += move.y;
movement.c:		else if (env->inputs.right && !env->inputs.left)
movement.c:			move = check_collision(env, new_v2(env->player.camera.angle_sin * -env->player.speed, env->player.camera.angle_cos * env->player.speed), motion, 0);
movement.c:			env->player.pos.x += move.x;
movement.c:			env->player.pos.y += move.y;
movement.c:		if (env->player.stuck || get_sector_no_z_origin(env, env->player.pos, env->player.sector) == -1)
movement.c:			env->player.stuck = 0;
movement.c:			env->player.pos.x = env->player.old_pos.x;
movement.c:			env->player.pos.y = env->player.old_pos.y;
movement.c:			env->player.sector = get_sector_no_z_origin(env, env->player.pos, prev_sector);
movement.c:		if (!movement && (env->player.state.climb || env->player.state.drop))
movement.c:			env->player.sector = get_sector_no_z_origin(env, env->player.pos, env->player.sector);
movement.c:			/*if (env->player.sector == -1)
movement.c:				//env->player.pos.x = old_pos.x;
movement.c:				//env->player.pos.y = old_pos.y;
movement.c:				//env->player.sector = old_sector;
movement.c:			if (find_highest_sector(env, motion) != env->player.highest_sect
movement.c:					&& get_floor_at_pos(env->sectors[find_highest_sector(env, motion)], pos, env) < get_floor_at_pos(env->sectors[env->player.highest_sect], pos, env))
movement.c:				env->player.drop_flag = 1;
movement.c:			env->player.highest_sect = find_highest_sector(env, motion);
movement.c:			env->player.lowest_sect = find_lowest_sector(env, motion);
movement.c:			env->player.camera.pos = env->player.pos;
movement.c:			env->player.camera.pos.z = env->player.head_z;
movement.c:			if (((get_floor_at_pos(env->sectors[env->player.highest_sect], pos, env) > env->player.pos.z
movement.c:				&& get_floor_at_pos(env->sectors[env->player.highest_sect], pos, env) - env->player.pos.z <= 2)
movement.c:				|| (env->player.state.climb))
movement.c:				&& !env->player.state.drop && !env->player.state.jump && !env->elevator.on)
movement.c:			else if ((((get_floor_at_pos(env->sectors[env->player.highest_sect], pos, env) < env->player.pos.z
movement.c:					&& env->player.pos.z - get_floor_at_pos(env->sectors[env->player.highest_sect], pos, env) <= 2)
movement.c:					|| env->player.state.drop)
movement.c:					&& !env->player.state.jump && !env->player.state.fall && !env->player.state.climb)
movement.c:					&& env->player.drop_flag)
movement.c:			env->player.head_z = env->player.pos.z + env->player.eyesight;
movement.c:			update_camera_position(&env->player.camera);
movement_collision.c:    //FUTURE_Z = motion.eyesight + env->sectors[sector_dest].floor
movement_collision.c:    //+ (env->sectors[sector_dest].normal.x * (FUTURE_X - FUTURE_V0X) - env->sectors[sector_dest].normal.y * (FUTURE_Y - FUTURE_V0Y)) * env->sectors[sector_dest].floor_slope;
movement_collision.c:    if (curr_z > env->sectors[sector_dest].ceiling
movement_collision.c:    + (env->sectors[sector_dest].normal.x * (FUTURE_X - FUTURE_V0X)
movement_collision.c:    - env->sectors[sector_dest].normal.y * (FUTURE_Y - FUTURE_V0Y))
movement_collision.c:    * env->sectors[sector_dest].ceiling_slope - 1)
movement_collision.c:    FUTURE_Z = env->sectors[sector_dest].floor
movement_collision.c:    + (env->sectors[sector_dest].normal.x * (FUTURE_X - FUTURE_V0X)
movement_collision.c:    - env->sectors[sector_dest].normal.y * (FUTURE_Y - FUTURE_V0Y))
movement_collision.c:    * env->sectors[sector_dest].floor_slope;
movement_collision.c:	if (env->player.state.jump && FUTURE_Z > motion.pos.z)
movement_collision.c:    env->sector_list[wall.sector_dest] = 1;
movement_collision.c:    while (i < env->sectors[wall.sector_dest].nb_vertices)
movement_collision.c:    while (i < env->sectors[wall.sector_dest].nb_vertices)
movement_collision.c:            env->sector_list[RNEIGHBOR] == 0)
movement_collision.c:    //env->player.highest_sect = motion.sector;
movement_collision.c:    if (env->options.test)
movement_collision.c:    while (i < env->sectors[motion.sector].nb_vertices)
movement_collision.c:    while (i < env->sectors[motion.sector].nb_vertices)
movement_utils.c:    height = motion.eyesight + env->sectors[sector_dest].floor + (env->sectors[sector_dest].normal.x
movement_utils.c:        * (motion.pos.x - FUTURE_V0X) - env->sectors[sector_dest].normal.y * (motion.pos.y - FUTURE_V0Y)) * env->sectors[sector_dest].floor_slope;
movement_utils.c:    env->sector_list[wall.sector_dest] = 1;
movement_utils.c:    while (i < env->sectors[wall.sector_dest].nb_vertices)
movement_utils.c:            env->sector_list[RNEIGHBOR] == 0)
movement_utils.c:    while (i < env->sectors[motion.sector].nb_vertices)
movement_utils.c:    while (i < env->nb_sectors)
movement_utils.c:        if (env->sector_list[i])
movement_utils.c:    while (i < env->nb_sectors)
movement_utils.c:        if (env->sector_list[i])
objects_selection.c:	if (env->inputs.left_click
objects_selection.c:			&& env->sdl.mx > 80
objects_selection.c:			&& env->sdl.mx < 120
objects_selection.c:			&& env->sdl.my > 180
objects_selection.c:			&& env->sdl.my < 220
objects_selection.c:			&& env->editor.start_vertex == -1
objects_selection.c:			&& env->editor.dragged_player == -1
objects_selection.c:			&& env->editor.dragged_vertex == -1
objects_selection.c:			&& env->editor.dragged_object == -1
objects_selection.c:			&& env->editor.dragged_enemy == -1
objects_selection.c:			&& !env->teleport.create)
objects_selection.c:		env->editor.dragged_object = env->nb_objects;
objects_selection.c:	if (!env->inputs.left_click && env->editor.dragged_object != -1)
objects_selection.c:		if (env->sdl.mx > 200)
objects_selection.c:			if (env->editor.dragged_object == env->nb_objects)
objects_selection.c:				env->nb_objects++;
objects_selection.c:				env->objects[env->editor.dragged_object].pos.x =	(env->sdl.mx - env->editor.center.x) / env->editor.scale;
objects_selection.c:				env->objects[env->editor.dragged_object].pos.y =	(env->sdl.my - env->editor.center.y) / env->editor.scale;
objects_selection.c:			delete_object(env, env->editor.dragged_object);
objects_selection.c:		env->editor.dragged_object = -1;
objects_utils.c:    while (i < env->nb_objects)
objects_utils.c:        if (env->objects[i].exists && distance_two_points(env->objects[i].pos.x, env->objects[i].pos.y, PLAYER_XPOS, PLAYER_YPOS) < 1.75
objects_utils.c:            /* && (ft_abs(env->player.pos.z - env->objects[i].pos.z) <= 2 || ft_abs(env->player.head_z - env->objects[i].pos.z) <= 2) */)
objects_utils.c:            if (env->objects[i].sprite == 0 && env->weapons[env->player.curr_weapon].ammo < env->weapons[env->player.curr_weapon].max_ammo)
objects_utils.c:                env->weapons[env->player.curr_weapon].ammo += 10;
objects_utils.c:                    env->objects[i].exists = 0;
objects_utils.c:                if (env->weapons[env->player.curr_weapon].ammo >= env->weapons[env->player.curr_weapon].max_ammo)
objects_utils.c:                    env->weapons[env->player.curr_weapon].ammo = env->weapons[env->player.curr_weapon].max_ammo;
physics.c:	new_time = env->time.milli_s;
physics.c:	env->time.milli_s = SDL_GetTicks();
physics.c:	env->player.speed = ((env->time.milli_s - new_time) / 1000.0) * 15;
physics.c:	env->player.rotation_speed = ((env->time.milli_s - new_time) / 1000.0) * 0.2;
physics.c:	env->time.tenth_s = env->time.milli_s / 100.0;
physics.c:	pos.x = env->player.pos.x;
physics.c:	pos.y = env->player.pos.y;
physics.c:	slope = get_floor_at_pos(env->sectors[env->player.highest_sect], pos, env);
physics.c:	if (!env->player.state.climb)
physics.c:		env->player.state.climb = 1;
physics.c:		env->time.last_climb = SDL_GetTicks() / 100.0;
physics.c:		env->player.velocity = 0.4;
physics.c:	if (env->player.state.climb)
physics.c:		env->time.d_time = time - env->time.last_climb;
physics.c:		env->player.pos.z += env->time.d_time * env->player.velocity;	
physics.c:	if (env->player.pos.z > slope)
physics.c:		env->player.pos.z = slope;
physics.c:		env->player.state.climb = 0;
physics.c:		env->player.velocity = 0;
physics.c:		env->time.d_time = 0;
physics.c:	pos.x = env->player.pos.x;
physics.c:	pos.y = env->player.pos.y;
physics.c:	slope = get_floor_at_pos(env->sectors[env->player.highest_sect], pos, env);
physics.c:	if (!env->player.state.drop)
physics.c:		env->player.state.drop = 1;
physics.c:		env->time.last_drop = SDL_GetTicks() / 100.0;
physics.c:		env->player.velocity = 0.4;
physics.c:	if (env->player.state.drop)
physics.c:		env->time.d_time = time - env->time.last_drop;
physics.c:		env->player.pos.z -= env->time.d_time * env->player.velocity;	
physics.c:	if (env->player.pos.z < slope)
physics.c:		env->player.pos.z = slope;
physics.c:		env->player.state.drop = 0;
physics.c:		env->player.velocity = 0;
physics.c:		env->time.d_time = 0;
physics.c:		env->player.drop_flag = 0;
physics.c:	if (!env->player.state.fall && !env->player.state.jump)
physics.c:		env->gravity.velocity = 25.0;
physics.c:		env->player.state.jump = 1;
physics.c:		env->player.start_pos = env->player.pos.z;
physics.c:		env->player.pos.z += 0.00001;
physics.c:	if (!env->player.state.crouch)
physics.c:		env->player.state.crouch = 1;
physics.c:		env->time.last_crouch = time;
physics.c:	if (env->player.state.crouch && env->inputs.ctrl)
physics.c:		env->time.d_time = time - env->time.last_crouch;
physics.c:		env->player.eyesight -= env->time.d_time * 0.3;	
physics.c:	if (env->player.state.crouch && !env->inputs.ctrl)
physics.c:		env->time.d_time = time - env->time.last_crouch;
physics.c:		env->player.eyesight += env->time.d_time * 0.3;	
physics.c:	if ((env->player.eyesight <= 3 && env->inputs.ctrl)
physics.c:	|| (env->player.eyesight >= 6 && !env->inputs.ctrl))
physics.c:		if (env->inputs.ctrl)
physics.c:			env->player.eyesight = 3;
physics.c:			env->player.state.crouch = 0;	
physics.c:			env->player.eyesight = 6;
physics.c:		env->time.d_time = 0;
player_selection.c:	if (env->inputs.left_click
player_selection.c:			&& env->sdl.mx > 80
player_selection.c:			&& env->sdl.mx < 120
player_selection.c:			&& env->sdl.my > 80
player_selection.c:			&& env->sdl.my < 120
player_selection.c:			&& env->editor.start_vertex == -1
player_selection.c:			&& env->editor.dragged_player == -1
player_selection.c:			&& env->editor.dragged_vertex == -1
player_selection.c:			&& env->editor.dragged_object == -1
player_selection.c:			&& !env->teleport.create)
player_selection.c:		env->editor.dragged_player = 1;
player_selection.c:	if (!env->inputs.left_click && env->editor.dragged_player == 1)
player_selection.c:		env->editor.dragged_player = -1;
player_selection.c:		if (env->sdl.mx > 200 && check_player_z(env))
player_selection.c:			env->editor.new_player = 1;
player_selection.c:			env->editor.new_player = 0;
precompute_neighbors.c:	neighbor = env->sectors[sector->neighbors[i]];
precompute_neighbors.c:	/*camera->v[sector->num][i].neighbor_f1 = env->h_h + (neighbor.v[nv1].clipped_vf1
precompute_neighbors.c:	camera->v[sector->num][i].neighbor_f2 = env->h_h + (neighbor.v[nv2].clipped_vf2
precompute_neighbors.c:	camera->v[sector->num][i].neighbor_c1 = env->h_h + (neighbor.v[nv1].clipped_vc1
precompute_neighbors.c:	camera->v[sector->num][i].neighbor_c2 = env->h_h + (neighbor.v[nv2].clipped_vc2
precompute_neighbors.c:	camera->v[sector->num][i].neighbor_f1 = env->h_h + (neighbor.floors[nv1]
precompute_neighbors.c:	camera->v[sector->num][i].neighbor_f2 = env->h_h + (neighbor.floors[nv2]
precompute_neighbors.c:	camera->v[sector->num][i].neighbor_c1 = env->h_h + (neighbor.ceilings[nv1]
precompute_neighbors.c:	camera->v[sector->num][i].neighbor_c2 = env->h_h + (neighbor.ceilings[nv2]
precompute_skybox.c:	env->skybox[i].clipped_xrange = env->skybox[i].clipped_x2
precompute_skybox.c:		- env->skybox[i].clipped_x1;
precompute_skybox.c:	env->skybox[i].xrange = env->skybox[i + 1].x
precompute_skybox.c:		- env->skybox[i].x;
precompute_skybox.c:	env->skybox[i].floor_range = env->skybox[i].f2 - env->skybox[i].f1;
precompute_skybox.c:	env->skybox[i].ceiling_range = env->skybox[i].c2 - env->skybox[i].c1;
precompute_skybox.c:	if (env->skybox[i + 1].vz)
precompute_skybox.c:		env->skybox[i].texture_scale.x = env->textures[40 + i].
precompute_skybox.c:			surface->w / env->skybox[i + 1].vz;
precompute_skybox.c:		env->skybox[i].texture_scale.x = env->textures[40 + i].
precompute_skybox.c:			surface->w / env->skybox[i].clipped_vz2;
precompute_skybox.c:	env->skybox[i].texture_scale.y = env->textures[40 + i].surface->h;
precompute_skybox.c:	env->skybox[i].x0z1 = pos1.x * env->skybox[i + 1].vz;
precompute_skybox.c:	env->skybox[i].x1z0 = pos2.x * env->skybox[i].vz;
precompute_skybox.c:	env->skybox[i].xzrange = env->skybox[i].x1z0 - env->skybox[i].x0z1;
precompute_skybox.c:	env->skybox[i].y0z1 = pos1.y * env->skybox[i + 1].vz;
precompute_skybox.c:	env->skybox[i].y1z0 = pos2.y * env->skybox[i].vz;
precompute_skybox.c:	env->skybox[i].yzrange = env->skybox[i].y1z0 - env->skybox[i].y0z1;
precompute_skybox.c:	env->skybox[i].zrange = env->skybox[i].vz - env->skybox[i + 1].vz;
precompute_skybox.c:	env->skybox[i].zcomb = env->skybox[i].vz * env->skybox[i + 1].vz;
precompute_skybox.c:	env->skybox[i].scale1 = env->player.camera.scale / -env->skybox[i].clipped_vz1;
precompute_skybox.c:	env->skybox[i].scale2 = env->player.camera.scale / -env->skybox[i].clipped_vz2;
precompute_skybox.c:	env->skybox[i].angle_z1 = env->skybox[i].clipped_vz1
precompute_skybox.c:		* env->player.camera.angle_z;
precompute_skybox.c:	env->skybox[i].angle_z2 = env->skybox[i].clipped_vz2
precompute_skybox.c:		* env->player.camera.angle_z;
precompute_skybox.c:	env->skybox[i].f1 = env->h_h + (-5 + env->skybox[i].angle_z1)
precompute_skybox.c:		* env->skybox[i].scale1;
precompute_skybox.c:	env->skybox[i].f2 = env->h_h + (-5 + env->skybox[i].angle_z2)
precompute_skybox.c:		* env->skybox[i].scale2;
precompute_skybox.c:	env->skybox[i].c1 = env->h_h + (5 + env->skybox[i].angle_z1)
precompute_skybox.c:		* env->skybox[i].scale1;
precompute_skybox.c:	env->skybox[i].c2 = env->h_h + (5 + env->skybox[i].angle_z2)
precompute_skybox.c:		* env->skybox[i].scale2;
precompute_skybox.c:	env->skybox[i].clipped_x1 = env->h_w + env->skybox[i].clipped_vx1
precompute_skybox.c:		* env->skybox[i].scale1;
precompute_skybox.c:	env->skybox[i].clipped_x2 = env->h_w + env->skybox[i].clipped_vx2
precompute_skybox.c:		* env->skybox[i].scale2;
precompute_skybox.c:	env->skybox[i].clipped_x1 = ceil(env->skybox[i].clipped_x1);
precompute_skybox.c:	env->skybox[i].x = env->h_w + env->skybox[i].vx * env->player.camera.scale
precompute_skybox.c:		/ -env->skybox[i].vz;
precompute_skybox.c:			new_v2(env->skybox[i].vx, env->skybox[i].vz),
precompute_skybox.c:			new_v2(env->skybox[i + 1].vx, env->skybox[i + 1].vz),
precompute_skybox.c:			new_v2(env->player.camera.near_left, env->player.camera.near_z),
precompute_skybox.c:			new_v2(env->player.camera.near_right, env->player.camera.near_z));
precompute_skybox.c:	if (env->skybox[i].vz < env->player.camera.near_z)
precompute_skybox.c:		env->skybox[i].clipped_vx1 = inter.x;
precompute_skybox.c:		env->skybox[i].clipped_vz1 = inter.y;
precompute_skybox.c:		env->skybox[i].clipped_vx1 = env->skybox[i].vx;
precompute_skybox.c:		env->skybox[i].clipped_vz1 = env->skybox[i].vz;
precompute_skybox.c:	if (env->skybox[i + 1].vz < env->player.camera.near_z)
precompute_skybox.c:		env->skybox[i].clipped_vx2 = inter.x;
precompute_skybox.c:		env->skybox[i].clipped_vz2 = inter.y;
precompute_skybox.c:		env->skybox[i].clipped_vx2 = env->skybox[i + 1].vx;
precompute_skybox.c:		env->skybox[i].clipped_vz2 = env->skybox[i + 1].vz;
precompute_skybox.c:	if ((env->skybox[i].vz < env->player.camera.near_z
precompute_skybox.c:				&& env->skybox[i + 1].vz < env->player.camera.near_z)
precompute_skybox.c:			|| (env->skybox[i].vz > env->player.camera.far_z
precompute_skybox.c:				&& env->skybox[i + 1].vz > env->player.camera.far_z)
precompute_skybox.c:			|| (env->skybox[i].vx < env->player.camera.far_left
precompute_skybox.c:				&& env->skybox[i + 1].vx < env->player.camera.far_left)
precompute_skybox.c:			|| (env->skybox[i].vx > env->player.camera.far_right
precompute_skybox.c:				&& env->skybox[i + 1].vx > env->player.camera.far_right))
precompute_skybox.c:		env->skybox[i].draw = 0;
precompute_skybox.c:		env->skybox[i].draw = 1;
precompute_skybox.c:	env->skybox[i].vx = (pos.x - 5) * env->player.camera.angle_sin
precompute_skybox.c:		- (pos.y - 5) * env->player.camera.angle_cos;
precompute_skybox.c:	env->skybox[i].vz = (pos.x - 5) * env->player.camera.angle_cos
precompute_skybox.c:		+ (pos.y - 5) * env->player.camera.angle_sin;
precompute_skybox.c:	env->skybox_computed++;
precompute_skybox.c:	env->skybox[4] = env->skybox[0];
precompute_skybox.c:	env->skybox[4] = env->skybox[0];
precompute_skybox.c:	env->skybox[4] = env->skybox[0];
precompute_skybox.c:		if (env->skybox[i].draw)
precompute_skybox.c:	env->skybox[4] = env->skybox[0];
print_debug.c:	h = env->h;
print_debug.c:	player_sector = ft_sitoa(env->player.sector);
print_debug.c:	print_text(new_point(h - 150, 5), new_printable_text("Player sector = ", env->sdl.fonts.alice30, 0xFFFFFFFF, 30), env);
print_debug.c:	print_text(new_point(h - 150, 215), new_printable_text(player_sector, env->sdl.fonts.alice30, 0xFFFFFFFF, 30), env);
print_debug.c:	print_text(new_point(0, 1300), new_printable_text("Test", env->sdl.fonts.alice30, 0xFFFFFFFF, 20), env);
print_debug.c:	print_text(new_point(h - 200, 5), new_printable_text("Clipping :", env->sdl.fonts.alice30, 0xFFFFFFFF, 30), env);
print_debug.c:	if (env->options.clipping)
print_debug.c:		print_text(new_point(h - 200, 145), new_printable_text("ON", env->sdl.fonts.alice30, 0x00FF00FF, 30), env);
print_debug.c:		print_text(new_point(h - 200, 145), new_printable_text("OFF", env->sdl.fonts.alice30, 0xFF0000FF, 30), env);
print_results.c:	accuracy = ft_sitoa(env->player.accuracy);
print_results.c:	print_text(new_point(200, 320), new_printable_text("Score :", env->sdl.fonts.amazdoom50, 0xFFFFFFFF, 50), env);
print_results.c:	print_text(new_point(280, 220), new_printable_text("Enemies Killed: ", env->sdl.fonts.alice30, 0xFFFFFFFF, 30), env);
print_results.c:	print_text(new_point(280, 450), new_printable_text(ft_sitoa(env->player.killed), env->sdl.fonts.alice30, 0xFFFFFFFF, 30), env);
print_results.c:	print_text(new_point(360, 220), new_printable_text("Accuracy: ", env->sdl.fonts.alice30, 0xFFFFFFFF, 30), env);
print_results.c:	print_text(new_point(360, 450), new_printable_text(ft_sitoa(env->player.accuracy), env->sdl.fonts.alice30, 0xFFFFFFFF, 30), env);
print_results.c:	print_text(new_point(360, 450 + length * 17), new_printable_text("%", env->sdl.fonts.alice30, 0xFFFFFFFF, 30), env);
project_wall.c:	camera->v[sector->num][i].f1 = env->h_h + (camera->v[sector->num][i].clipped_vf1 - camera->pos.z
project_wall.c:	camera->v[sector->num][i].f2 = env->h_h + (camera->v[sector->num][i].clipped_vf2 - camera->pos.z
project_wall.c:	camera->v[sector->num][i].c1 = env->h_h + (camera->v[sector->num][i].clipped_vc1 - camera->pos.z
project_wall.c:	camera->v[sector->num][i].c2 = env->h_h + (camera->v[sector->num][i].clipped_vc2 - camera->pos.z
project_wall.c:	camera->v[sector->num][i].clipped_x1 = env->h_w + camera->v[sector->num][i].clipped_vx1
project_wall.c:	camera->v[sector->num][i].clipped_x2 = env->h_w + camera->v[sector->num][i].clipped_vx2
project_wall.c:	camera->v[sector->num][i].no_slope_f1 = env->h_h + (sector->floor - camera->pos.z
project_wall.c:	camera->v[sector->num][i].no_slope_f2 = env->h_h + (sector->floor - camera->pos.z
project_wall.c:	camera->v[sector->num][i].no_slope_c1 = env->h_h + (sector->ceiling - camera->pos.z
project_wall.c:	camera->v[sector->num][i].no_slope_c2 = env->h_h + (sector->ceiling - camera->pos.z
project_wall.c:	camera->v[sector->num][i].x = env->h_w + camera->v[sector->num][i].vx
project_wall.c:	camera->v[sector->num][i].floor_horizon = env->h_h + (sector->floor_slope
project_wall.c:	camera->v[sector->num][i].ceiling_horizon = env->h_h + (sector->ceiling_slope
render.c:	vx = env->vertices[sector->vertices[i]].x - camera->pos.x;
render.c:	vz = env->vertices[sector->vertices[i]].y - camera->pos.y;
render.c:	if (env->selected_wall1 == sector->vertices[i]
render.c:			&& env->selected_wall2 == sector->vertices[i + 1])
render.c:	camera->v[sector->num][i].x0z1 = env->vertices[sector->vertices[i]].x
render.c:	camera->v[sector->num][i].x1z0 = env->vertices[sector->vertices[i + 1]].x
render.c:	camera->v[sector->num][i].y0z1 = env->vertices[sector->vertices[i]].y
render.c:	camera->v[sector->num][i].y1z0 = env->vertices[sector->vertices[i + 1]].y
render.c:			env->visible_sectors++;
render.c:			get_rendered_neighbors(camera, env->sectors[sector.neighbors[i]], env);
render.c:		sector = env->sectors[camera->screen_sectors[i]];
render.c:			env->visible_sectors++;
render.c:	camera->feet_y[sector->num] = env->h_h + (get_floor_at_pos(*sector,
render.c:	camera->head_y[sector->num] = env->h_h + (get_ceiling_at_pos(*sector,
render.c:				&& !env->skybox_computed)
render.c:	if (sector->skybox && !env->skybox_computed)
render.c:		precompute_sector(camera, &env->sectors[i], env);
render.c:		pt[i].start = env->visible_sectors / (double)THREADS * i;
render.c:		pt[i].end = env->visible_sectors / (double)THREADS * (i + 1);
render.c:	env->visible_sectors = 0;
render.c:		render.yend = env->h - 1;
render.c:		if (env->options.p)
render_sector.c:				env->ymin[x], env->ymax[x]);
render_sector.c:				env->ymin[x], env->ymax[x]);
render_sector.c:		if (render.current_ceiling > env->ymin[x]
render_sector.c:				|| render.current_floor < env->ymax[x])
render_sector.c:		if (render.current_ceiling > env->ymin[x])
render_sector.c:		if (render.current_floor < env->ymax[x])
render_sector.c:					render.neighbor_max_ceiling, env->ymin[x], env->ymax[x]);
render_sector.c:					render.neighbor_max_floor, env->ymin[x], env->ymax[x]);
render_sector.c:			env->ymin[x] = ft_clamp(ft_max(render.neighbor_current_ceiling,
render_sector.c:						render.current_ceiling), env->ymin[x], env->ymax[x]);
render_sector.c:			env->ymax[x] = ft_clamp(ft_min(render.neighbor_current_floor,
render_sector.c:						render.current_floor), env->ymin[x], env->ymax[x]);
render_sector.c:	sector = env->sectors[render.sector];
render_sector.c:			render.texture_w = env->textures[38].surface->w;
render_sector.c:			render.texture_h = env->textures[38].surface->h;
render_sector.c:			render.texture_w = env->textures[render.texture].surface->w;
render_sector.c:			render.texture_h = env->textures[render.texture].surface->h;
render_sector2.c:				env->sectors[sector.neighbors[render.i]].xmin[y] = ft_max(render.current_ceiling, render.xstart);
render_sector2.c:				env->sectors[sector.neighbors[render.i]].xmin[y] = ft_max(render.current_floor, render.xstart);
render_sector2.c:				env->sectors[sector.neighbors[render.i]].xmax[y] = ft_min(render.current_ceiling, render.xend);
render_sector2.c:				env->sectors[sector.neighbors[render.i]].xmax[y] = ft_min(render.current_floor, render.xend);
render_sector2.c:		if (!env->options.test)
render_sector2.c:		if (!env->options.test)
render_sector2.c:							env->sectors[sector.neighbors[render.i]].xmax[y] = render.wall_xstart;
render_sector2.c:							env->sectors[sector.neighbors[render.i]].xmin[y] = render.wall_xend;
render_sector2.c:							env->sectors[sector.neighbors[render.i]].xmax[y] = render.wall_xstart;
render_sector2.c:							env->sectors[sector.neighbors[render.i]].xmin[y] = render.wall_xend;
render_sector2.c:			//if (!env->options.test)
render_sector2.c:	sector = env->sectors[render.sector];
render_sector2.c:		  render.yend = env->h - 1;*/
render_sector2.c:		if (env->options.contouring)
render_sector2.c:			if (env->options.show_fps)
render_sector2.c:	reset_x_restrictions(&env->sectors[render.sector], env);
render_utils.c:	while (i < env->nb_sectors)
render_utils.c:		max = env->sectors[i].nb_vertices;
render_utils.c:			env->sectors[i].clipped_floors1[j] = env->sectors[i].floors[j];
render_utils.c:			env->sectors[i].clipped_ceilings1[j] = env->sectors[i].ceilings[j];
render_utils.c:			env->sectors[i].clipped_floors2[j] = env->sectors[i].floors[j];
render_utils.c:			env->sectors[i].clipped_ceilings2[j] = env->sectors[i].ceilings[j];
render_utils.c:	while (++i < env->h)
render_utils.c:		sector->xmax[i] = env->w - 1;
render_utils.c:	max = env->screen_sectors_size;
render_utils.c:	ymin = ft_max(env->h_h + camera->y1 * env->player.camera.scale, 0);
render_utils.c:	ymax = ft_min(env->h_h + camera->y2 * env->player.camera.scale,
render_utils.c:			env->h - 1);
render_utils.c:	env->skybox_computed = 0;
render_utils.c:	while (i < env->w)
render_utils.c:		env->ymin[i] = ymin;
render_utils.c:		env->ymax[i] = ymax;
render_utils.c:	while (i < env->h)
render_utils.c:		env->xmin[i] = 0;
render_utils.c:		env->xmax[i] = env->w - 1;
render_utils.c:	if (env->options.p)
render_utils.c:	while (++i < env->nb_sectors)
render_utils.c:		reset_x_restrictions(&env->sectors[i], env);
restrict_portals.c:				env->sectors[sector.neighbors[render->i]].xmax[render->y] = render->ceiling_xstart;
restrict_portals.c:				env->sectors[sector.neighbors[render->i]].xmax[render->y] = render->neighbor_current_ceiling;
restrict_portals.c:				//env->sectors[sector.neighbors[render->i]].xmin[render->y] = render->ceiling_xend;
restrict_portals.c:				//env->sectors[sector.neighbors[render->i]].xmax[render->y] = render->neighbor_current_ceiling;
restrict_portals.c:				env->sectors[sector.neighbors[render->i]].xmin[render->y] = render->ceiling_xend;
restrict_portals.c:				env->sectors[sector.neighbors[render->i]].xmin[render->y] = render->neighbor_current_ceiling;
restrict_portals.c:				env->sectors[sector.neighbors[render->i]].xmin[render->y] = render->floor_xend;
restrict_portals.c:				env->sectors[sector.neighbors[render->i]].xmin[render->y] = render->neighbor_current_floor;
restrict_portals.c:				env->sectors[sector.neighbors[render->i]].xmin[render->y] = render->floor_xend;
restrict_portals.c:				env->sectors[sector.neighbors[render->i]].xmax[render->y] = render->floor_xstart;
restrict_portals.c:				env->sectors[sector.neighbors[render->i]].xmax[render->y] = render->neighbor_current_floor;
restrict_portals.c:			env->sectors[sector.neighbors[render->i]].xmax[render->y] = ft_min(render->floor_xstart, render->wall_xstart);
restrict_portals.c:			env->sectors[sector.neighbors[render->i]].xmax[render->y] = render->floor_xstart;
restrict_portals.c:			env->sectors[sector.neighbors[render->i]].xmax[render->y] = render->neighbor_current_floor;
restrict_portals.c:			env->sectors[sector.neighbors[render->i]].xmax[render->y] = render->xstart;
restrict_portals.c:			env->sectors[sector.neighbors[render->i]].xmin[render->y] = ft_max(render->current_floor, render->neighbor_current_floor);
restrict_portals.c:			env->sectors[sector.neighbors[render->i]].xmin[render->y] = render->current_floor;
restrict_portals.c:			env->sectors[sector.neighbors[render->i]].xmin[render->y] = render->xstart;
restrict_portals.c:			env->sectors[sector.neighbors[render->i]].xmin[render->y] = render->xstart;
restrict_portals.c:			env->sectors[sector.neighbors[render->i]].xmin[render->y] = ft_max(render->current_floor, render->neighbor_current_floor);
restrict_portals.c:			env->sectors[sector.neighbors[render->i]].xmax[render->y] = ft_min(render->current_floor, render->neighbor_current_floor);
restrict_portals.c:			env->sectors[sector.neighbors[render->i]].xmin[render->y] = ft_max(render->current_floor, render->neighbor_current_floor);
restrict_portals.c:			env->sectors[sector.neighbors[render->i]].xmax[render->y] = ft_min(render->current_floor, render->neighbor_current_floor);
restrict_portals.c:	env->sectors[sector.neighbors[render->i]].xmin[render->y] = ft_min(render->current_floor, render->neighbor_current_floor);*/
screen_utils.c:	if (SDL_UpdateTexture(env->sdl.texture, NULL, env->sdl.texture_pixels, env->w * sizeof(Uint32)))
screen_utils.c:	SDL_RenderCopy(env->sdl.renderer, env->sdl.texture, NULL, NULL);
screen_utils.c:	SDL_RenderPresent(env->sdl.renderer);
screen_utils.c:	max = env->w * env->h;
screen_utils.c:		if (env->zbuffer[i] > max_z)
screen_utils.c:			max_z = env->zbuffer[i];
screen_utils.c:		if (env->zbuffer[i] < min_z)
screen_utils.c:			min_z = env->zbuffer[i];
screen_utils.c:	while (y < env->h)
screen_utils.c:		while (x < env->w)
screen_utils.c:			if ((y <= 300 && x < env->w - 300) || y > 300 || env->editor.in_game || !env->options.show_minimap)
screen_utils.c:				alpha = 1 - env->zbuffer[x + env->w * y] / max_z;
screen_utils.c:				if (env->zbuffer[x + env->w * y] >= 0 && alpha >= 0 && alpha <= 1)
screen_utils.c:					env->sdl.texture_pixels[x + env->w * y] = (int)(alpha * 0xFF) << 24
screen_utils.c:				else if (env->zbuffer[x + env->w * y] == 100000000)
screen_utils.c:					env->sdl.texture_pixels[x + env->w * y] = 0xFFAA0000;
screen_utils.c:					env->sdl.texture_pixels[x + env->w * y] = 0;
screen_utils.c:	if (SDL_UpdateTexture(env->sdl.texture, NULL, env->sdl.texture_pixels, env->w * sizeof(Uint32)))
screen_utils.c:	SDL_RenderCopy(env->sdl.renderer, env->sdl.texture, NULL, NULL);
screen_utils.c:	SDL_RenderPresent(env->sdl.renderer);
screen_utils.c:	texture_pixels = env->sdl.texture_pixels;
screen_utils.c:					&&*/ /*if (pos.y + x >= 0 && pos.y + x < env->w && pos.x + y >= 0 && pos.x + y < env->h)
screen_utils.c:			texture_pixels[pos.y + x + env->w * (pos.x + y)] =
screen_utils.c:			if (pos.y + x >= 0 && pos.y + x < env->w && pos.x + y >= 0 && pos.x + y < env->h)
screen_utils.c:				texture_pixels[pos.y + x + env->w * (pos.x + y)] = blend_alpha(texture_pixels[pos.y + x + env->w * (pos.x + y)], pixel, (Uint8)(((pixel & fmt->Amask) >> fmt->Ashift) << fmt->Aloss));
screen_utils.c:	pixels = env->sdl.texture_pixels;
screen_utils.c:	max = env->h;
screen_utils.c:		pixels[i * env->w + env->h_w] = 0xFFFFFFFF;
screen_utils.c:	max = env->w;
screen_utils.c:		pixels[env->h_h * env->w + i] = 0xFFFFFFFF;
screen_utils.c:	pixels = env->sdl.texture_pixels;
screen_utils.c:	x = env->h_w;
screen_utils.c:	y = env->h_h - 10;
screen_utils.c:	max = env->h_h - 2;
screen_utils.c:		pixels[x + y * env->w] = 0xFFFFFFFF;
screen_utils.c:	y = env->h_h + 10;
screen_utils.c:	max = env->h_h + 2;
screen_utils.c:		pixels[x + y * env->w] = 0xFFFFFFFF;
screen_utils.c:	y = env->h_h;
screen_utils.c:	x = env->h_w - 10;
screen_utils.c:	max = env->h_w - 2;
screen_utils.c:		pixels[x + y * env->w] = 0xFFFFFFFF;
screen_utils.c:	x = env->h_w + 10;
screen_utils.c:	max = env->h_w + 2;
screen_utils.c:		pixels[x + y * env->w] = 0xFFFFFFFF;
selected_information.c:	if (env->selected_stat == 0 && time - env->time.tick2 > 300)
selected_information.c:		env->time.tick2 = time;
selected_information.c:		if (env->inputs.left && env->enemies[env->selected_enemy].health > 5)
selected_information.c:			env->enemies[env->selected_enemy].health -= 5;
selected_information.c:		if (env->inputs.right && env->enemies[env->selected_enemy].health < 100)
selected_information.c:			env->enemies[env->selected_enemy].health += 5;
selected_information.c:	else if (env->selected_stat == 1 && time - env->time.tick2 > 300)
selected_information.c:		env->time.tick2 = time;
selected_information.c:		if (env->inputs.left && env->enemies[env->selected_enemy].speed > 0)
selected_information.c:			env->enemies[env->selected_enemy].speed -= 5;
selected_information.c:		if (env->inputs.right && env->enemies[env->selected_enemy].speed < 100)
selected_information.c:			env->enemies[env->selected_enemy].speed += 5;
selected_information.c:	else if (env->selected_stat == 2 && time - env->time.tick2 > 300)
selected_information.c:		env->time.tick2 = time;
selected_information.c:		if (env->inputs.left && env->enemies[env->selected_enemy].damage > 5)
selected_information.c:			env->enemies[env->selected_enemy].damage -= 5;
selected_information.c:		if (env->inputs.right && env->enemies[env->selected_enemy].damage < 100)
selected_information.c:			env->enemies[env->selected_enemy].damage += 5;
selected_information.c:	else if (env->selected_stat == 3 && time - env->time.tick2 > 300)
selected_information.c:		env->time.tick2 = time;
selected_information.c:		if (env->inputs.left && env->enemies[env->selected_enemy].sprite == 2)
selected_information.c:			env->enemies[env->selected_enemy].sprite--;
selected_information.c:			env->enemies[env->selected_enemy].pos.z = get_floor_at_pos(env->sectors[env->enemies[env->selected_enemy].sector], new_v2(env->enemies[env->selected_enemy].pos.x, env->enemies[env->selected_enemy].pos.y), env) + 5;
selected_information.c:		if (env->inputs.right && env->enemies[env->selected_enemy].sprite == 1)
selected_information.c:			env->enemies[env->selected_enemy].sprite++;
selected_information.c:			env->enemies[env->selected_enemy].pos.z = get_floor_at_pos(env->sectors[env->enemies[env->selected_enemy].sector], new_v2(env->enemies[env->selected_enemy].pos.x, env->enemies[env->selected_enemy].pos.y), env);
selected_information.c:	if ((env->inputs.left || env->inputs.right) && env->selected_stat == 0 && time - env->time.tick2 > 250)
selected_information.c:		env->time.tick2 = time;
selected_information.c:		if (env->inputs.left)
selected_information.c:			env->sectors[env->editor.selected_sector].floor -= 2;
selected_information.c:		if (env->inputs.right)
selected_information.c:			env->sectors[env->editor.selected_sector].floor += 2;
selected_information.c:	if ((env->inputs.left || env->inputs.right) && env->selected_stat == 1 && time - env->time.tick2 > 250)
selected_information.c:		env->time.tick2 = time;
selected_information.c:		if (env->inputs.left)
selected_information.c:			env->sectors[env->editor.selected_sector].ceiling -= 2;
selected_information.c:		if (env->inputs.right)
selected_information.c:			env->sectors[env->editor.selected_sector].ceiling += 2;
selected_information.c:	if ((env->inputs.left || env->inputs.right) && env->selected_stat == 2 && time - env->time.tick2 > 250)
selected_information.c:		env->time.tick2 = time;
selected_information.c:		if (env->inputs.left)
selected_information.c:			env->sectors[env->editor.selected_sector].brightness -= 2;
selected_information.c:		if (env->inputs.right)
selected_information.c:			env->sectors[env->editor.selected_sector].brightness += 2;
selected_information.c:	update_sector_slope(env, &env->sectors[env->editor.selected_sector]);
skybox_draw_functions.c:	texture = env->textures[render.texture];
skybox_draw_functions.c:	pixels = env->sdl.texture_pixels;
skybox_draw_functions.c:	zbuffer = env->zbuffer;
skybox_draw_functions.c:	x = render.alpha * env->skybox[render.i].texture_scale.x * render.z;
skybox_draw_functions.c:		coord = vline.x + env->w * i;
skybox_draw_functions.c:		if (env->editor.select && vline.x == env->h_w && i == env->h_h)
skybox_draw_functions.c:				env->selected_wall1 = -1;
skybox_draw_functions.c:				env->selected_wall2 = -1;
skybox_draw_functions.c:				env->selected_ceiling = render.sector;
skybox_draw_functions.c:				env->selected_floor = -1;
skybox_draw_functions.c:				env->selected_object = -1;
skybox_draw_functions.c:				env->selected_enemy = -1;
skybox_draw_functions.c:				env->editor.selected_wall = -1;
skybox_draw_functions.c:				if (env->editor.in_game)
skybox_draw_functions.c:					env->editor.selected_sector = render.sector;
skybox_draw_functions.c:					env->editor.selected_wall = render.i;
skybox_draw_functions.c:				env->selected_wall1 = env->sectors[render.sector].vertices[wall_data.i];
skybox_draw_functions.c:				env->selected_wall2 = env->sectors[render.sector].vertices[wall_data.i + 1];
skybox_draw_functions.c:				env->selected_floor = -1;
skybox_draw_functions.c:				env->selected_ceiling = -1;
skybox_draw_functions.c:				env->selected_object = -1;
skybox_draw_functions.c:				env->selected_enemy = -1;
skybox_draw_functions.c:		y = yalpha * env->skybox[render.i].texture_scale.y;
skybox_draw_functions.c:		if (env->editor.in_game && render.selected && !env->editor.select)
skybox_draw_functions.c:	if (env->options.zbuffer || env->options.contouring)
skybox_draw_functions.c:			start_coord = vline.x + env->w * vline.start;
skybox_draw_functions.c:			end_coord = vline.x + env->w * vline.end;
skybox_draw_functions.c:	pixels = env->sdl.texture_pixels;
skybox_draw_functions.c:	zbuffer = env->zbuffer;
skybox_draw_functions.c:	texture_w = env->textures[39].surface->w;
skybox_draw_functions.c:	texture_h = env->textures[39].surface->h;
skybox_draw_functions.c:	texture_pixels = env->textures[39].str;
skybox_draw_functions.c:		coord = vline.x + env->w * i;
skybox_draw_functions.c:		if (env->editor.select && vline.x == env->h_w && i == env->h_h)
skybox_draw_functions.c:				env->selected_wall1 = -1;
skybox_draw_functions.c:				env->selected_wall2 = -1;
skybox_draw_functions.c:				env->selected_ceiling = render.sector;
skybox_draw_functions.c:				env->selected_floor = -1;
skybox_draw_functions.c:				env->selected_object = -1;
skybox_draw_functions.c:				env->selected_enemy = -1;
skybox_draw_functions.c:				env->editor.selected_wall = -1;
skybox_draw_functions.c:				if (env->editor.in_game)
skybox_draw_functions.c:					env->editor.selected_sector = render.sector;
skybox_draw_functions.c:					env->editor.selected_wall = render.i;
skybox_draw_functions.c:				env->selected_wall1 = env->sectors[render.sector].vertices[wall_data.i];
skybox_draw_functions.c:				env->selected_wall2 = env->sectors[render.sector].vertices[wall_data.i + 1];
skybox_draw_functions.c:				env->selected_floor = -1;
skybox_draw_functions.c:				env->selected_ceiling = -1;
skybox_draw_functions.c:				env->selected_object = -1;
skybox_draw_functions.c:				env->selected_enemy = -1;
skybox_draw_functions.c:		y *= env->textures[39].surface->h / 10;
skybox_draw_functions.c:		x *= env->textures[39].surface->w / 10;
skybox_draw_functions.c:			if (env->editor.in_game && render.selected && !env->editor.select)
skybox_draw_functions.c:	if (env->options.zbuffer || env->options.contouring)
skybox_draw_functions.c:		if (vline.start >= 0 && vline.start < env->h - 1)
skybox_draw_functions.c:			pixels[vline.x + env->w * vline.start] = 0xFFFF0000;
skybox_draw_functions.c:				&& vline.end >= 0 && vline.end < env->h)
skybox_draw_functions.c:			pixels[vline.x + env->w * vline.end] = 0xFFFF0000;
skybox_draw_functions.c:	pixels = env->sdl.texture_pixels;
skybox_draw_functions.c:	zbuffer = env->zbuffer;
skybox_draw_functions.c:	texture_w = env->textures[38].surface->w;
skybox_draw_functions.c:	texture_h = env->textures[38].surface->h;
skybox_draw_functions.c:	texture_pixels = env->textures[38].str;
skybox_draw_functions.c:		coord = vline.x + env->w * i;
skybox_draw_functions.c:		if (env->editor.select && vline.x == env->h_w && i == env->h_h)
skybox_draw_functions.c:				env->selected_wall1 = -1;
skybox_draw_functions.c:				env->selected_wall2 = -1;
skybox_draw_functions.c:				env->selected_ceiling = render.sector;
skybox_draw_functions.c:				env->selected_floor = -1;
skybox_draw_functions.c:				env->selected_object = -1;
skybox_draw_functions.c:				env->selected_enemy = -1;
skybox_draw_functions.c:				env->editor.selected_wall = -1;
skybox_draw_functions.c:				if (env->editor.in_game)
skybox_draw_functions.c:					env->editor.selected_sector = render.sector;
skybox_draw_functions.c:					env->editor.selected_wall = render.i;
skybox_draw_functions.c:				env->selected_wall1 = env->sectors[render.sector].vertices[wall_data.i];
skybox_draw_functions.c:				env->selected_wall2 = env->sectors[render.sector].vertices[wall_data.i + 1];
skybox_draw_functions.c:				env->selected_floor = -1;
skybox_draw_functions.c:				env->selected_ceiling = -1;
skybox_draw_functions.c:				env->selected_object = -1;
skybox_draw_functions.c:				env->selected_enemy = -1;
skybox_draw_functions.c:		y *= env->textures[38].surface->h / 10;
skybox_draw_functions.c:		x *= env->textures[38].surface->w / 10;
skybox_draw_functions.c:			if (env->editor.in_game && render.selected && !env->editor.select)
skybox_draw_functions.c:	if (env->options.zbuffer || env->options.contouring)
skybox_draw_functions.c:				&& vline.start >= 0 && vline.start < env->h)
skybox_draw_functions.c:			pixels[vline.x + env->w * vline.start] = 0xFFFF0000;
skybox_draw_functions.c:		if (vline.end < env->h - 1 && vline.end >= 0)
skybox_draw_functions.c:			pixels[vline.x + env->w * vline.end] = 0xFFFF0000;
sprite_maths_enemies.c:		get_translated_enemy_pos(camera, &env->enemies[i]);
sprite_maths_enemies.c:		get_rotated_enemy_pos(camera, &env->enemies[i]);
sprite_maths_enemies.c:	erender->screen_pos.y = env->h_h
sprite_maths_enemies.c:	erender->screen_pos.x = env->h_w
sprites_maths.c:		get_translated_object_pos(camera, &env->objects[i]);
sprites_maths.c:		get_rotated_object_pos(camera, &env->objects[i]);
sprites_maths.c:	orender->screen_pos.y = env->h_h
sprites_maths.c:	orender->screen_pos.x = env->h_w
teleporter.c:	env->teleport.create = 1;
teleporter.c:	futur_pos.x = env->teleport.tmp_pos.x;
teleporter.c:	futur_pos.y = env->teleport.tmp_pos.y;
teleporter.c:	env->teleport.sector = 0;
teleporter.c:	if ((env->teleport.sector = get_sector_no_z(env, futur_pos)) != -1)
teleporter.c:		futur_pos.z = env->sectors[env->teleport.sector].floor;
teleporter.c:		env->sectors[env->editor.selected_sector].tp.x = futur_pos.x;
teleporter.c:		env->sectors[env->editor.selected_sector].tp.y = futur_pos.y;
teleporter.c:		env->sectors[env->editor.selected_sector].tp.z = futur_pos.z;
teleporter.c:		env->sectors[env->editor.selected_sector].status = 0;
teleporter.c:	env->teleport.create = 0;
teleporter.c:	env->player.pos.x = env->sectors[env->player.sector].tp.x;
teleporter.c:	env->player.pos.y = env->sectors[env->player.sector].tp.y;
teleporter.c:	env->player.pos.z = env->sectors[env->player.sector].tp.z;
teleporter.c:	env->player.sector = env->teleport.sector;
teleporter.c:	update_camera_position(&env->player.camera);
update_player_z.c:	env->player.state.walk = 1;
update_player_z.c:	sector = env->sectors[env->player.highest_sect];
update_player_z.c:	v0 = env->vertices[sector.vertices[0]];
update_player_z.c:	env->player.pos.z =
update_player_z.c:		(sector.normal.x * (env->player.pos.x - v0.x)
update_player_z.c:		 - sector.normal.y * (env->player.pos.y - v0.y)) * sector.floor_slope;
update_player_z.c:	env->player.head_z = env->player.pos.z + env->player.eyesight;
update_player_z.c:	env->player.camera.pos.z = env->player.head_z;
update_player_z.c:	sector = env->sectors[env->enemies[i].sector];
update_player_z.c:	v0 = env->vertices[sector.vertices[0]];
update_player_z.c:	env->enemies[i].pos.z =
update_player_z.c:		(sector.normal.x * (env->enemies[i].pos.x - v0.x)
update_player_z.c:		 - sector.normal.y * (env->enemies[i].pos.y - v0.y)) * sector.floor_slope;
update_player_z.c:	sector = env->sectors[env->player.highest_sect];
update_player_z.c:	v0 = env->vertices[sector.vertices[0]];
update_player_z.c:		(sector.normal.x * (env->player.pos.x - v0.x)
update_player_z.c:		 - sector.normal.y * (env->player.pos.y - v0.y)) * sector.floor_slope;
update_player_z.c:	env->gravity.floor = player_feet;
update_sprites_state.c:	while (i < env->nb_sectors)
update_sprites_state.c:		sector = env->sectors[i];
update_sprites_state.c:			diff = env->time.milli_s - sector.sprite_time;
update_sprites_state.c:					env->sectors[i].sprite_time = env->time.milli_s;
update_sprites_state.c:					env->sectors[i].sprites[j].sprite[k] = env->sprites[env->sectors[i].sprites[j].sprite[k]].rest_sprite;
valid_map.c:	while (i < env->nb_sectors)
valid_map.c:	vertex = env->vertices[0];
valid_map.c:		vertex = env->vertices[sector.vertices[i]];
valid_map.c:	env->player.sector = get_sector_no_z(env, env->player.pos);
valid_map.c:	if (!env->nb_sectors)
valid_map.c:	if (!env->editor.new_player)
valid_map.c:	if (env->player.sector == -1)
valid_map.c:	while (i < env->nb_sectors)
valid_map.c:		if (check_sector(env->sectors[i], env))
valid_map.c:	while (i < env->nb_vertices)
vertices_selection.c:	while (i < env->nb_sectors)
vertices_selection.c:		while (j < env->sectors[i].nb_vertices)
vertices_selection.c:			if (env->editor.dragged_vertex == env->sectors[i].vertices[j])
vertices_selection.c:				env->editor.reverted = get_clockwise_order_sector(env, i) ? 0 : 1;
vertices_selection.c:				revert_sector(&env->sectors[i], env);
vertices_selection.c:	if (!env->inputs.left_click && env->editor.dragged_vertex != -1)
vertices_selection.c:		if ((click_vertex = get_existing_not_dragged_vertex(env)) != -1 || (!(is_new_dragged_vertex_valid(env, env->editor.selected_vertex)) && (click_vertex != env->vertices[env->editor.selected_vertex].num)))
vertices_selection.c:			env->vertices[env->editor.selected_vertex].x = env->editor.start_pos.x;
vertices_selection.c:			env->vertices[env->editor.selected_vertex].y = env->editor.start_pos.y;
vertices_selection.c:			env->vertices[env->editor.selected_vertex].x = round((env->sdl.mx - env->editor.center.x) / env->editor.scale);
vertices_selection.c:			env->vertices[env->editor.selected_vertex].y = round((env->sdl.my - env->editor.center.y) / env->editor.scale);
vertices_selection.c:			while (i < env->nb_sectors)
vertices_selection.c:				create_portals(env, env->sectors[i]);
vertices_selection.c:		env->editor.dragged_vertex = -1;
vertices_utils.c:	while (i < env->nb_sectors)
vertices_utils.c:		while (j < env->sectors[i].nb_vertices)
vertices_utils.c:			if (env->sectors[i].vertices[j] == index)
vertices_utils.c:	while (i < env->nb_sectors)
vertices_utils.c:			while (j < env->sectors[i].nb_vertices)
vertices_utils.c:				if (env->sectors[i].vertices[j] == vertex)
vertices_utils.c:	while (i < env->nb_sectors)
vertices_utils.c:		while (j < env->sectors[i].nb_vertices)
vertices_utils.c:			if (env->sectors[i].vertices[j] == vertex)
vertices_utils.c:	tmp = env->editor.current_vertices;
view.c:	env->player.camera.angle += env->sdl.mouse_x * env->player.rotation_speed;
view.c:	env->player.camera.angle *= CONVERT_DEGREES;
view.c:	while (env->player.camera.angle > 360)
view.c:		env->player.camera.angle -= 360;
view.c:	while (env->player.camera.angle < 0)
view.c:		env->player.camera.angle += 360;
view.c:	env->player.camera.angle *= CONVERT_RADIANS;
view.c:	env->player.camera.angle_cos = cos(env->player.camera.angle);
view.c:	env->player.camera.angle_sin = sin(env->player.camera.angle);
view.c:	env->player.camera.perp_cos = cos(env->player.camera.angle - M_PI / 2);
view.c:	env->player.camera.perp_sin = sin(env->player.camera.angle - M_PI / 2);
view.c:	update_camera_position(&env->player.camera);
view.c:	env->player.camera.angle_z = ft_fclamp(env->player.camera.angle_z + env->sdl.mouse_y * 0.005, -5, 5);
view.c:	env->player.camera.angle_z_cos = cos(env->player.camera.angle_z);
view.c:	env->player.camera.angle_z_sin = sin(env->player.camera.angle_z);
view.c:	env->player.camera.horizon = env->h_h - env->player.camera.angle_z * env->player.camera.scale;
weapons.c:	if (env->enemies[i].exists && env->enemies[i].seen)
weapons.c:		if ((env->enemies[i].left - env->enemies[i].left) * (env->h / 2 - env->enemies[i].bottom) - (env->w / 2 - env->enemies[i].left) * (env->enemies[i].top - env->enemies[i].bottom) < 0)
weapons.c:		if ((env->enemies[i].right - env->enemies[i].left) * (env->h / 2 - env->enemies[i].top) - (env->w / 2 - env->enemies[i].left) * (env->enemies[i].top - env->enemies[i].top) < 0)
weapons.c:		if ((env->enemies[i].right - env->enemies[i].right) * (env->h / 2 - env->enemies[i].top) - (env->w / 2 - env->enemies[i].right) * (env->enemies[i].bottom - env->enemies[i].top) < 0)
weapons.c:		if ((env->enemies[i].left - env->enemies[i].right) * (env->h / 2 - env->enemies[i].bottom) - (env->w / 2 - env->enemies[i].right) * (env->enemies[i].bottom - env->enemies[i].bottom) < 0)
weapons.c:		if (env->enemies[i].rotated_pos.z > env->weapons[env->player.curr_weapon].range || env->enemies[i].rotated_pos.z < 0)
weapons.c:	while (i < env->nb_enemies)
weapons.c:			if (env->options.test)
weapons.c:				ft_printf("I hit enemy nb %d | enemy_life before = %d |", i, env->enemies[i].health);
weapons.c:			env->enemies[i].health -= damage_done(*env, i);
weapons.c:			if (env->enemies[i].health <= 0)
weapons.c:				env->player.killed++;
weapons.c:			if (env->options.test)
weapons.c:				ft_printf(" and after = %d\n", env->enemies[i].health);
weapons.c:			env->enemies[i].hit = 1;
weapons.c:		env->player.touched += 1;
weapons.c:	env->player.nb_shots += 1;
weapons.c:	pixels = env->sdl.texture_pixels;
weapons.c:	texture_pixels = env->textures[sprite].str;
weapons.c:	texture_w = env->textures[sprite].surface->w;
weapons.c:	texture_h = env->textures[sprite].surface->h;
weapons.c:	window_w = (int)(env->w - texture_w) / 1.5;
weapons.c:	window_h = (env->h - texture_h) + env->weapons[0].weapon_switch;
weapons.c:		while (x < texture_w  && (window_h + y) < env->h)
weapons.c:			//ft_printf("Player sector = %d\n", env->player.sector);
weapons.c:				pixels[(window_w + x) + env->w * (window_h + y)] = 
weapons.c:							env->sectors[env->player.sector].light_color,
weapons.c:							env->sectors[env->player.sector].brightness);
weapons.c:				//pixels[(window_w + x) + env->w * (window_h + y)] = 
weapons.c:	if (env->shot.start == 0)
weapons.c:		env->shot.on_going = 1;
weapons.c:		env->shot.start = SDL_GetTicks();
weapons.c:		if (env->weapons[nb].ammo <= 0)
weapons.c:			env->weapons[nb].no_ammo = 1;
weapons.c:			Mix_PlayChannel(2, env->weapons[nb].empty, 0);
weapons.c:			env->weapons[nb].no_ammo = 0;
weapons.c:			Mix_PlayChannel(2, env->weapons[nb].sound, 0);
weapons.c:			env->weapons[nb].ammo--;
weapons.c:	if (!env->weapons[nb].no_ammo)
weapons.c:		if (env->time.milli_s > env->shot.start + 70 && ((env->time.milli_s - env->shot.start) / 70 < env->weapons[nb].nb_sprites))
weapons.c:			draw_weapon(env, env->weapons[nb].first_sprite + (int)((env->time.milli_s - env->shot.start) / 70));
weapons.c:			draw_weapon(env, env->weapons[nb].first_sprite);
weapons.c:		draw_weapon(env, env->weapons[nb].first_sprite);
weapons.c:	if ((int)((env->time.milli_s - env->shot.start)) >= env->weapons[nb].nb_sprites * 70)
weapons.c:		env->shot.start = 0;
weapons.c:		env->shot.on_going = 0;
weapons.c:	if (env->weapon_change.start == 0)
weapons.c:		env->weapon_change.start = SDL_GetTicks();
weapons.c:		env->weapon_change.on_going = 1;
weapons.c:	time_spent = env->time.milli_s - env->weapon_change.start;
weapons.c:		env->weapons[0].weapon_switch  = 75 * (int)(time_spent / 70);
weapons.c:		if (env->sdl.event.wheel.y > 0)
weapons.c:			env->player.curr_weapon = (env->player.curr_weapon >= NB_WEAPONS - 1 ? 0 : env->player.curr_weapon + 1);
weapons.c:		else if (env->sdl.event.wheel.y < 0)
weapons.c:			env->player.curr_weapon = (env->player.curr_weapon <= 0 ? NB_WEAPONS - 1 : env->player.curr_weapon - 1);
weapons.c:		env->weapons[0].weapon_switch = 0;
weapons.c:		env->weapon_change.start = 0;
weapons.c:		env->weapon_change.on_going = 0;
weapons.c:	str = ft_sitoa(env->weapons[env->player.curr_weapon].ammo);
weapons.c:	print_text(new_point(env->h - env->h / 12, env->w - env->w / 14 - 5), new_printable_text(str, env->sdl.fonts.amazdoom50, 0xA1A1A100, 0), env);
weapons.c:	print_text(new_point(env->h - env->h / 12, env->w - env->w / 19), new_printable_text(str, env->sdl.fonts.amazdoom50, 0xA1A1A100, 0), env);
weapons.c:	str = ft_sitoa(env->weapons[env->player.curr_weapon].max_ammo);
weapons.c:	print_text(new_point(env->h - env->h / 12, env->w - env->w / 24), new_printable_text(str, env->sdl.fonts.amazdoom50, 0xA1A1A100, 0), env);
write_enemies.c:	ft_dprintf(fd, "\nE %d\n", env->nb_enemies);
write_enemies.c:	while (i < env->nb_enemies)
write_enemies.c:		write_enemy(fd, env->enemies[i]);
write_objects.c:	ft_dprintf(fd, "\nO %d\n", env->nb_objects);
write_objects.c:	while (i < env->nb_objects)
write_objects.c:		write_object(fd, env->objects[i]);
write_player.c:			env->player.pos.y, env->player.pos.x,
write_player.c:			(int)(env->player.camera.angle * CONVERT_DEGREES) % 360);
write_sectors.c:	ft_dprintf(fd, "\nS %d\n", env->nb_sectors);
write_sectors.c:	while (i < env->nb_sectors)
write_sectors.c:		write_sector(fd, env->sectors[i]);
write_vertices.c:	ft_dprintf(fd, "V %d\n", env->nb_vertices);
write_vertices.c:	while (i < env->nb_vertices)
write_vertices.c:		size = ft_max(ft_getsize(env->vertices[i].y), ft_getsize(env->vertices[i].x));
write_vertices.c:	while (i < env->nb_vertices)
write_vertices.c:		ft_dprintf(fd, "%-*.5f %.5f\n", padding, env->vertices[i].y, env->vertices[i].x);
